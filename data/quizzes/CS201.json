[
    {
        "question": "Which of the following best describes the fundamental purpose of 'Programming' as defined in the CS201 course materials?",
        "options": [
            "The process of creating high-quality graphics for user interfaces.",
            "A precise sequence of steps to solve a particular problem.",
            "The manual translation of machine language into English commands.",
            "A method for upgrading computer hardware components."
        ],
        "correct": 1,
        "explanation": "According to the Lecture 1 handouts, programming is defined as 'a precise sequence of steps to solve a particular problem'. It involves knowing a complete set of activities to be performed in a specific order to achieve a goal. While user interfaces and hardware are related to computing, they do not define the core nature of programming itself.",
        "topic": "Introduction to Programming"
    },
    {
        "question": "What is the primary difference between a 'Compiler' and an 'Interpreter' in terms of program execution and optimization?",
        "options": [
            "Compilers execute programs line by line, allowing for better optimization.",
            "Interpreters translate the entire program at once, making them faster than compilers.",
            "Compilers read the whole program to create an overall picture for optimization, whereas interpreters read line by line.",
            "Interpreters generate standalone executable code on the disk, unlike compilers."
        ],
        "correct": 2,
        "explanation": "The handouts state that interpreters translate programs line by line, which prevents them from seeing the 'overall picture' needed for optimization. Conversely, compilers read the entire program and can optimize it more efficiently before generating executable code. Interpreters stop at the first error found during execution, while compilers require a syntactically correct program to produce any output.",
        "topic": "Translators"
    },
    {
        "question": "In C++, what is the functional role of the 'Linker' during the program development cycle?",
        "options": [
            "It allows the programmer to write and edit the source code text.",
            "It loads the program into primary memory for immediate execution by the CPU.",
            "It combines the object code of a program with necessary library routines into a standalone executable.",
            "It translates English-like C++ code into binary machine language."
        ],
        "correct": 2,
        "explanation": "The Linker is a tool that takes the object code generated by the compiler and includes necessary routines or functions located in different library files. This process, called 'Linking,' results in a standalone executable code that is ready to be stored on a disk. Loading the program into memory is the task of the 'Loader,' not the linker.",
        "topic": "Development Environment"
    },
    {
        "question": "Consider the C++ expression: 5 * 3 + 6 / 3. Based on operator precedence, what is the resulting value?",
        "options": [
            "7",
            "17",
            "10",
            "15"
        ],
        "correct": 1,
        "explanation": "Following C++ precedence rules, multiplication (*) and division (/) have higher precedence than addition (+) and are evaluated from left to right. First, 5 * 3 is calculated as 15. Next, 6 / 3 is calculated as 2. Finally, these results are added (15 + 2) to yield 17. A common misconception is to evaluate from left to right regardless of operators, which would lead to 7.",
        "topic": "Arithmetic Operators"
    },
    {
        "question": "Which specific software category does a 'Device Driver' belong to, and what is its primary function?",
        "options": [
            "Application Software; it provides tools for end-user productivity like word processing.",
            "System Software; it enables communication between hardware devices and the computer.",
            "Utility Software; it performs specialized tasks like disk defragmentation.",
            "Firmware; it provides permanent instructions for the CPU startup sequence."
        ],
        "correct": 1,
        "explanation": "Device drivers are a sub-category of 'System Software'. Their primary role is to act as a communication bridge between the computer's operating system and physical hardware devices like monitors, keyboards, and scanners. Application software is designed for end-users to perform tasks like accounting or word processing.",
        "topic": "Software Categories"
    },
    {
        "question": "In the context of data types, why might a programmer choose 'short' over 'int' for a variable intended to store a person's age?",
        "options": [
            "Short variables can store much larger numbers than standard integers.",
            "Short variables use less memory (2 bytes) compared to integers (4 bytes).",
            "The short data type is the only one capable of handling negative age values.",
            "Using short prevents the occurrence of runtime overflow errors."
        ],
        "correct": 1,
        "explanation": "A 'short' data type in C++ typically occupies 2 bytes of memory and can store values in the range of -32768 to 32767. Since a person's age will never exceed this range, using 'short' is more memory-efficient than using a standard 4-byte 'int'. Using a data type smaller than required for the data would cause an 'overflow'.",
        "topic": "Data Types"
    },
    {
        "question": "What occurs during an 'Overflow' condition in a C++ program?",
        "options": [
            "The program runs out of primary memory and crashes immediately.",
            "A variable is assigned a value that exceeds its allocated bit capacity, leading to incorrect results.",
            "The compiler detects a syntax error and refuses to generate object code.",
            "The logical expression in a loop remains true indefinitely, creating a hang."
        ],
        "correct": 1,
        "explanation": "Overflow occurs when a program attempts to store a value larger than the fixed space allocated for that data type in memory (e.g., trying to store a value requiring more than 32 bits in an 'int'). This results in either a runtime error or the 'wasting' of extra bits, leading to mathematically incorrect results. It is not a syntax error and cannot be detected by the compiler.",
        "topic": "Memory and Variables"
    },
    {
        "question": "Which of the following is a 'Rule of Structured Programming' emphasized in the CS201 curriculum for maintaining manageable code?",
        "options": [
            "Always use 'goto' statements to handle complex logical branches.",
            "Functions should be written as long as possible to keep related logic together.",
            "Each module or construct should follow the 'Single Entry, Single Exit' rule.",
            "Variable names should be kept as short as possible to save memory space."
        ],
        "correct": 2,
        "explanation": "Structured programming advocates for a 'Single Entry, Single Exit' approach for every module or construct to keep execution flow simple and readable. This rule helps prevent 'spaghetti code,' which often results from the excessive use of 'goto' statements. Other rules include 'Divide and Conquer' (splitting long functions into smaller ones) and liberal use of comments.",
        "topic": "Structured Programming"
    },
    {
        "question": "When using the 'cin' object for user input, what determines the direction of the data flow and the end of the input process?",
        "options": [
            "The '<<' sign indicates data flow; the process ends when the 'Enter' key is pressed.",
            "The '>>' sign indicates data flow; the process ends when a semicolon is typed.",
            "The '>>' sign indicates data flow; the process ends when the 'Enter' key is pressed.",
            "The '<<' sign indicates data flow; the process ends automatically after 10 seconds."
        ],
        "correct": 2,
        "explanation": "In the statement 'cin >> variable', the '>>' sign is the stream extraction operator that indicates the direction of data flow from the user into the variable. The program stops execution and waits for input; the user signals that they have finished by pressing the 'Enter' key. The '<<' operator is used with 'cout' for output flow.",
        "topic": "Standard I/O"
    },
    {
        "question": "What is the scholarly justification for 'commenting code liberally' in software development?",
        "options": [
            "Comments increase the execution speed of the final program.",
            "Comments provide instructions to the compiler on how to optimize loops.",
            "Comments help both the original creator and other programmers understand the program's logic.",
            "Comments are used to reserve memory blocks for future variable declarations."
        ],
        "correct": 2,
        "explanation": "Comments are ignored by the compiler and do not occupy memory or affect the performance of the program. Their sole purpose is to explain the functioning and logic of the code to humans, which is essential for maintenance and collaboration. Liberal commenting is a hallmark of a good programmer who understands that details matter.",
        "topic": "Programming Skills"
    },
    {
        "question": "In C++, how does the result of 'integer division' (e.g., 5 / 2) differ from 'floating-point division'?",
        "options": [
            "Integer division automatically rounds to the nearest whole number.",
            "Integer division results in a runtime error if the result is not a whole number.",
            "Integer division truncates the fractional part, yielding only the whole number portion.",
            "Floating-point division is only possible if both operands are of the 'int' type."
        ],
        "correct": 2,
        "explanation": "When both operands in a division are integers, C++ performs integer division, which truncates the fractional part (e.g., 5 / 2 yields 2 instead of 2.5). To obtain the correct decimal result, at least one operand should be a real number (float or double). This is a frequent source of logical errors in calculations like finding averages.",
        "topic": "Arithmetic Operations"
    },
    {
        "question": "Which operator is used to determine the remainder of an integer division in C++?",
        "options": [
            "/",
            "%",
            "&",
            "#"
        ],
        "correct": 1,
        "explanation": "C++ provides the modulus operator (%) specifically to return the remainder after one integer is divided by another. For example, '5 % 2' would result in 1. This operator is highly useful for tasks like determining if a number is even or odd. It can only be used with integer operands.",
        "topic": "Arithmetic Operators"
    },
    {
        "question": "What is the primary technical reason for including the '#include <iostream.h>' directive in a C++ program?",
        "options": [
            "To declare the 'main()' function as the starting point of execution.",
            "To include the library definition file for Input/Output streams like cin and cout.",
            "To allocate 32 bits of memory for every integer variable used.",
            "To translate user comments into a format readable by the linker."
        ],
        "correct": 1,
        "explanation": "'#include <iostream.h>' is a pre-processor directive that tells the compiler to include the contents of the 'iostream.h' system file. This file contains the necessary code definitions for using input/output streams, allowing the program to read from the keyboard and send data to the screen. Without this directive, the compiler would not recognize 'cin' or 'cout'.",
        "topic": "Pre-processor Directives"
    },
    {
        "question": "How are character strings represented and delimited in C++ source code?",
        "options": [
            "Strings are enclosed in single quotes (e.g., 'Hello').",
            "Strings are preceded by the '#' symbol (e.g., #Hello).",
            "Strings are enclosed in double quotes (e.g., \"Hello\").",
            "Strings are delimited by braces (e.g., {Hello})."
        ],
        "correct": 2,
        "explanation": "In C++ programming, character strings must be written between double quotation marks (\"\"). Anything written within these marks is treated as a string literal and can be directed to 'cout' for display. Braces ({}) are used to group blocks of statements , while single quotes are used for individual 'char' literals.",
        "topic": "Strings"
    },
    {
        "question": "Why is it considered 'good programming practice' to initialize variables at the time of declaration?",
        "options": [
            "It prevents the compiler from generating syntax errors.",
            "It ensures that variables do not contain unpredictable 'garbage' values from memory.",
            "It reduces the physical size of the executable file on the disk.",
            "It allows the variable to be used as a constant throughout the program."
        ],
        "correct": 1,
        "explanation": "When a variable is declared, a space in memory is reserved for it, but that space may contain random data from previous use. Initializing the variable (e.g., 'int x = 0;') ensures it starts in a known, predictable state. This is a matter of style and safety that helps avoid logical errors during execution.",
        "topic": "Variables and Initialization"
    },
    {
        "question": "In the C++ 'if' statement, what is the consequence of using the assignment operator (=) instead of the equality operator (==) in the condition?",
        "options": [
            "The compiler will issue a syntax error and stop.",
            "The program will crash immediately upon reaching the statement.",
            "The condition will perform an assignment and may result in a logical error.",
            "The assignment operator and equality operator are interchangeable in C++."
        ],
        "correct": 2,
        "explanation": "Using a single '=' in an 'if' condition is not a syntax error; it performs an assignment and returns a value. Since this value might not be the intended Boolean result of a comparison (==), it creates a dangerous logical error where the condition may always evaluate to true or false unexpectedly. Be careful: '==' is for comparison, and '=' is for assignment.",
        "topic": "Conditional Statements"
    },
    {
        "question": "Which logical operator is used to 'reverse' the Boolean value of a condition in C++?",
        "options": [
            "&&",
            "||",
            "!",
            "~"
        ],
        "correct": 2,
        "explanation": "The '!' (logical negation) operator is a unary operator used to reverse the meaning of a condition. If a condition is false, '!condition' becomes true, and vice versa. '&&' is the AND operator, and '||' is the OR operator, both of which are binary operators used to combine multiple conditions.",
        "topic": "Logical Operators"
    },
    {
        "question": "Which of the following describes a key characteristic of the 'while' loop structure?",
        "options": [
            "It always executes its body at least once regardless of the condition.",
            "It tests the condition after executing the loop body.",
            "It may execute its body zero or more times depending on the initial condition.",
            "It is primarily used for cases where the exact number of iterations is unknown."
        ],
        "correct": 2,
        "explanation": "A 'while' loop is a pre-test loop that checks the logical expression *before* entering the loop body. If the initial condition is false, the body is never executed, meaning it can run zero or more times. This differs from the 'do-while' loop, which is a post-test loop that always executes at least once.",
        "topic": "Repetition Structures"
    },
    {
        "question": "In a 'for' loop, when is the 'incrementing/decrementing' part of the statement executed?",
        "options": [
            "Before the first iteration of the loop body.",
            "Simultaneously with the loop condition test.",
            "Immediately after each execution of the loop body.",
            "Only once when the loop termination condition is finally met."
        ],
        "correct": 2,
        "explanation": "In a 'for' loop structure, the initialization happens first. Then the continuation condition is tested; if true, the body is executed. Crucially, the increment statement (the third part of the 'for' statement) is executed *after* the body finishes, right before the control jumps back to re-test the condition.",
        "topic": "Repetition Structures"
    },
    {
        "question": "What is the primary technical advantage of using an 'Array' over individual variables for related data (e.g., 100 student ages)?",
        "options": [
            "Arrays automatically sort the data in ascending order.",
            "Arrays allow for the aggregation of multiple variables of different data types.",
            "Arrays allow related data to be managed as a single entity and manipulated using loops.",
            "Arrays ensure that data is stored in non-volatile permanent storage."
        ],
        "correct": 2,
        "explanation": "Arrays are used to aggregate variables of the same data type into a single named data structure. This allows programmers to use loops to efficiently process large collections of identical data (like 100 student ages) without having to declare 100 individual variables. Arrays occupy contiguous areas of memory and are accessed via indices.",
        "topic": "Arrays"
    },
    {
        "question": "Which of the following is a strict requirement for a 'Switch' statement in C++?",
        "options": [
            "The switch variable can be of any data type, including 'float' and 'double'.",
            "The case constants must be integer-type (including 'char') constants.",
            "Logical operators like '&&' must be used to combine cases.",
            "The 'default' case is mandatory for the program to compile."
        ],
        "correct": 1,
        "explanation": "A switch statement requires an integer variable or an expression that evaluates to an integer type (whole numbers only). Consequently, the case constants must also be integer constants, which includes characters since they are represented internally as ASCII whole numbers. Decimal numbers (floats/doubles) are not allowed. The 'default' case is optional.",
        "topic": "Switch Statement"
    },
    {
        "question": "What is the specific function of the 'break' statement when used inside a 'Switch' structure?",
        "options": [
            "It terminates the entire program and returns to the operating system.",
            "It causes the control to jump to the 'default' case automatically.",
            "It interrupts the flow of control and exits the switch block after a matching case is executed.",
            "It forces the compiler to re-evaluate the switch expression for a new match."
        ],
        "correct": 2,
        "explanation": "In a switch statement, cases 'fall through' if no break is present, meaning all statements after a true case will execute until the end of the block. The 'break' statement is used to interrupt this flow, ensuring that only the statements for the matched case are executed before jumping out of the switch structure. Without 'break', the switch behavior is often illogical.",
        "topic": "Switch Statement"
    },
    {
        "question": "In the context of 'File I/O,' what is the purpose of the 'seekg()' and 'seekp()' functions?",
        "options": [
            "To search for specific text strings within a file.",
            "To move the file pointer to a desired location for random access.",
            "To determine the current position of the pointer within the file stream.",
            "To check if the file has been successfully opened for reading."
        ],
        "correct": 1,
        "explanation": "Seek functions ('seekg' for input and 'seekp' for output) are essential for random file movement, allowing a programmer to move the file pointer to a specific position (backward or forward) rather than reading sequentially from the beginning. In contrast, 'tellg' and 'tellp' are used to retrieve (tell) the current location of the pointer.",
        "topic": "File Handling"
    },
    {
        "question": "A 'Pointer' is defined as a special type of variable that stores:",
        "options": [
            "The name of another variable as a string literal.",
            "A memory address of another variable or object.",
            "A constant integer that cannot be changed once initialized.",
            "The binary code of a library routine."
        ],
        "correct": 1,
        "explanation": "Pointers are a unique category of variables in C++ that do not store actual values (like numbers or characters) but instead store the memory address of another variable or object. By using this address, a program can indirectly reference and manipulate the data stored at that location. This is a core concept for 'call by reference'.",
        "topic": "Pointers"
    },
    {
        "question": "Which C++ keyword is used to define a custom collection of variables of different types under a single name?",
        "options": [
            "array",
            "class",
            "struct",
            "union"
        ],
        "correct": 2,
        "explanation": "The 'struct' keyword is used to define a 'structure,' which is a collection of related variables (data members) of different types grouped under one name. This allows programmers to create new data types to represent real-world entities like a 'student' or a 'car'. While 'class' is similar, 'struct' members are public by default in C++.",
        "topic": "Structures"
    },
    {
        "question": "In the C++ compilation process, which tool is responsible for resolving symbols and combining multiple object files into a single '.exe' file?",
        "options": [
            "Compiler",
            "Linker",
            "Loader",
            "Preprocessor"
        ],
        "correct": 1,
        "explanation": "The Linker is the specific utility that takes one or more object files (generated by the compiler) and combines them with library files to create a standalone executable. The Compiler (Option 0) only translates source code to object code, while the Loader (Option 2) brings the executable into RAM for the CPU to run. The Preprocessor (Option 3) handles directives like #include before compilation begins.",
        "topic": "Program Development Cycle"
    },
    {
        "question": "Which of the following is a valid C++ identifier naming convention according to the CS201 handouts?",
        "options": [
            "2_student_count",
            "student count",
            "$student_total",
            "student_age"
        ],
        "correct": 3,
        "explanation": "C++ identifiers must start with a letter or an underscore and cannot contain spaces or special symbols like '$'. Option 0 is invalid because it starts with a digit. Option 1 is invalid due to the space. Option 2 is invalid because of the '$' symbol. 'student_age' is a professional and valid identifier.",
        "topic": "Identifiers"
    },
    {
        "question": "What is the resulting value of the expression 'int x = 7 / 2 * 3.0;'?",
        "options": [
            "10.5",
            "10",
            "9.0",
            "9"
        ],
        "correct": 3,
        "explanation": "Evaluation follows precedence: first, 7 / 2 is integer division, which truncates to 3. Then, 3 * 3.0 promotes the operation to floating-point, resulting in 9.0. Finally, because 'x' is declared as an 'int', the value is truncated back to 9. A common mistake is assuming 7/2 becomes 3.5, which would lead to 10.5.",
        "topic": "Arithmetic Operators"
    },
    {
        "question": "A variable declared with the 'static' keyword inside a function will:",
        "options": [
            "Be destroyed as soon as the function returns.",
            "Retain its value between multiple calls to that function.",
            "Be accessible from any other function in the program.",
            "Cause a syntax error if not initialized with a constant."
        ],
        "correct": 1,
        "explanation": "A static local variable is initialized only once and persists in memory for the duration of the program. It retains its value even after the function exits, allowing it to 'remember' data for the next time the function is called. It is not global (Option 2) as its scope remains limited to the function.",
        "topic": "Static Variables"
    },
    {
        "question": "What is the primary technical reason for using a 'Header Guard' (#ifndef, #define, #endif) in C++ header files?",
        "options": [
            "To speed up the execution time of the final program.",
            "To prevent multiple definitions of the same class or function if a header is included more than once.",
            "To encrypt the source code to protect intellectual property.",
            "To tell the linker which libraries to exclude from the project."
        ],
        "correct": 1,
        "explanation": "Header guards are preprocessor directives that ensure the contents of a header file are only processed once by the compiler, even if multiple files in the project include that header. Without them, the compiler would see duplicate definitions, leading to a compilation error.",
        "topic": "Preprocessor Directives"
    },
    {
        "question": "In a 'Switch' statement, what happens if the 'break' keyword is omitted after a matching case?",
        "options": [
            "The program terminates immediately with an error.",
            "The switch statement exits automatically after executing the matching case.",
            "The execution 'falls through' to the next case regardless of whether its constant matches.",
            "The compiler automatically inserts a hidden break at the end of the case."
        ],
        "correct": 2,
        "explanation": "C++ switch logic is designed to 'fall through' unless a break is encountered. If omitted, the program continues executing statements in subsequent cases until it hits a break or the end of the switch block. This is often used intentionally for grouping cases but can be a source of logical bugs if done accidentally.",
        "topic": "Control Structures"
    },
    {
        "question": "Which operator is used to access a member of a structure through a pointer to that structure?",
        "options": [
            ".",
            "->",
            "&",
            "*"
        ],
        "correct": 1,
        "explanation": "The arrow operator (->) is shorthand for dereferencing a pointer and then accessing a member (e.g., (*ptr).member). The dot operator (Option 0) is used for direct object access, & (Option 2) is the address-of operator, and * (Option 3) is the dereference operator.",
        "topic": "Structures and Pointers"
    },
    {
        "question": "In C++, an 'Array' name acts as a:",
        "options": [
            "Constant pointer to its first element.",
            "Variable that stores the total size of the array.",
            "Function that returns the last element.",
            "Reference to a dynamic memory block in the heap."
        ],
        "correct": 0,
        "explanation": "The name of an array is technically a constant pointer to the memory address of the first element (index 0). This is why passing an array to a function actually passes its address, allowing the function to modify the original array content.",
        "topic": "Arrays"
    },
    {
        "question": "Which function is used to dynamically allocate a block of memory on the 'Heap' in C++?",
        "options": [
            "malloc()",
            "alloc()",
            "new",
            "create"
        ],
        "correct": 2,
        "explanation": "While C uses malloc(), C++ introduces the 'new' operator for dynamic memory allocation. It not only allocates memory but also calls the constructor for objects. Memory allocated with 'new' must be manually released using the 'delete' operator to avoid memory leaks.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "What is the size of a 'char' data type in C++ on most modern systems?",
        "options": [
            "1 byte",
            "2 bytes",
            "4 bytes",
            "8 bytes"
        ],
        "correct": 0,
        "explanation": "A 'char' is designed to store a single character (based on ASCII) and occupies exactly 1 byte (8 bits) of memory. Integers (int) typically take 4 bytes, while 'double' takes 8 bytes.",
        "topic": "Data Types"
    },
    {
        "question": "When a function is 'Overloaded', it means:",
        "options": [
            "The function has too many lines of code to execute efficiently.",
            "Multiple functions have the same name but different parameter lists.",
            "A function calls itself recursively until the stack overflows.",
            "The function is declared in a library that is too large for the linker."
        ],
        "correct": 1,
        "explanation": "Function Overloading is a feature of C++ that allows multiple functions to share the same name as long as their signatures (number or types of parameters) are different. The compiler distinguishes which function to call based on the arguments provided.",
        "topic": "Function Overloading"
    },
    {
        "question": "Which mode is used with 'ofstream' to open a file for writing such that new data is added to the end of the existing content?",
        "options": [
            "ios::in",
            "ios::out",
            "ios::app",
            "ios::trunc"
        ],
        "correct": 2,
        "explanation": "'ios::app' stands for append mode. It ensures that every write operation occurs at the end of the file, preserving existing data. 'ios::out' (Option 1) overwrites existing data by default, and 'ios::trunc' (Option 3) explicitly deletes the existing content upon opening.",
        "topic": "File I/O"
    },
    {
        "question": "What is the value of 'y' after the execution: int x = 5; int y = ++x * 2;?",
        "options": [
            "10",
            "11",
            "12",
            "15"
        ],
        "correct": 2,
        "explanation": "The prefix increment operator (++x) increments the value of x to 6 *before* it is used in the expression. Therefore, 6 * 2 = 12. If it were a postfix operator (x++), the result would have been 10, and x would become 6 afterward.",
        "topic": "Increment/Decrement Operators"
    },
    {
        "question": "A 'Null Pointer' is a pointer that:",
        "options": [
            "Points to the address 0 or 'nowhere'.",
            "Has been deleted but still points to a memory location.",
            "Is used to store character strings only.",
            "Points to the memory address of the CPU."
        ],
        "correct": 0,
        "explanation": "A Null Pointer is a pointer that is assigned the value 0 (or NULL/nullptr). It signifies that the pointer does not currently point to a valid memory address. It is a safety practice to initialize pointers to NULL to avoid 'dangling pointers'.",
        "topic": "Pointers"
    },
    {
        "question": "In a 'for' loop, which part of the statement is executed only once?",
        "options": [
            "Initialization",
            "Condition",
            "Increment/Decrement",
            "Body"
        ],
        "correct": 0,
        "explanation": "The initialization part of a for-loop (e.g., int i = 0) is executed only once when the loop starts. The condition is checked at every iteration, and the increment is performed after every body execution.",
        "topic": "Loops"
    },
    {
        "question": "What is the purpose of the 'default' keyword in a switch statement?",
        "options": [
            "To reset all variables to zero.",
            "To provide a fallback block of code if no case match is found.",
            "To define the first case that should always be executed.",
            "To tell the compiler to ignore errors in the switch block."
        ],
        "correct": 1,
        "explanation": "The 'default' case acts like the 'else' in an if-else chain. If none of the 'case' constants match the switch expression, the code inside the default block is executed. It is optional but recommended for robust programming.",
        "topic": "Control Structures"
    },
    {
        "question": "Which of the following describes the 'Call by Value' mechanism?",
        "options": [
            "A copy of the actual argument is passed to the function.",
            "The memory address of the argument is passed to the function.",
            "The function can modify the original variable used as an argument.",
            "The function returns a reference to a global variable."
        ],
        "correct": 0,
        "explanation": "In 'Call by Value', a separate copy of the variable's data is created for the function. Any changes made to the parameter inside the function do not affect the original variable in the calling function. 'Call by Reference' (Option 1) is what allows original data modification.",
        "topic": "Function Parameters"
    },
    {
        "question": "The 'main()' function in C++ must return an integer value to:",
        "options": [
            "The user of the computer.",
            "The compiler.",
            "The Operating System.",
            "The Linker."
        ],
        "correct": 2,
        "explanation": "The return value of 'main' (usually 0 for success) is an exit code sent back to the Operating System. It informs the system whether the program executed successfully or encountered an error.",
        "topic": "Functions"
    },
    {
        "question": "Which of the following is true about 'Structures' in C++?",
        "options": [
            "They can only store variables of the same data type.",
            "They are defined using the 'class' keyword only.",
            "They allow grouping of different data types into a single unit.",
            "They cannot be passed as arguments to functions."
        ],
        "correct": 2,
        "explanation": "Structures (struct) are used to group variables of *different* data types together under a single name. This allows for the creation of complex data models, like a 'Student' structure containing a string for name and an int for roll number.",
        "topic": "Structures"
    },
    {
        "question": "What is the escape sequence for a 'newline' character in C++?",
        "options": [
            "\\t",
            "\\n",
            "\\b",
            "\\r"
        ],
        "correct": 1,
        "explanation": "'\\n' is the escape sequence for a newline. '\\t' (Option 0) is for a horizontal tab, '\\b' (Option 2) is for a backspace, and '\\r' (Option 3) is for a carriage return.",
        "topic": "Strings and Characters"
    },
    {
        "question": "Which operator has the highest precedence in C++ among the following?",
        "options": [
            "+",
            "=",
            "*",
            "()"
        ],
        "correct": 3,
        "explanation": "Parentheses '()' have the highest precedence in C++. They are used to override the default order of operations. Among the others, '*' is higher than '+', and '=' (assignment) has the lowest precedence.",
        "topic": "Operator Precedence"
    },
    {
        "question": "In the declaration 'int *ptr;', what does 'ptr' store?",
        "options": [
            "An integer value.",
            "A memory address.",
            "A character string.",
            "A floating-point result."
        ],
        "correct": 1,
        "explanation": "The asterisk (*) indicates that 'ptr' is a pointer variable. Pointer variables are specifically designed to store memory addresses of other variables, not raw data values.",
        "topic": "Pointers"
    },
    {
        "question": "What is the index of the last element in an array of size 10?",
        "options": [
            "10",
            "9",
            "0",
            "11"
        ],
        "correct": 1,
        "explanation": "C++ arrays use zero-based indexing. For an array of size 'n', the indices range from 0 to n-1. Therefore, in an array of size 10, the last index is 9.",
        "topic": "Arrays"
    },
    {
        "question": "Which loop is a 'Post-Test' loop, meaning it checks the condition after executing the body?",
        "options": [
            "for",
            "while",
            "do-while",
            "if-else"
        ],
        "correct": 2,
        "explanation": "A 'do-while' loop is a post-test loop. It executes the body first and then checks the condition. This ensures that the code inside the loop runs at least once, regardless of whether the condition is true or false initially.",
        "topic": "Loops"
    },
    {
        "question": "The process of 'Debugging' involves:",
        "options": [
            "Writing the initial source code.",
            "Converting source code to machine code.",
            "Finding and fixing errors in a program.",
            "Installing the program on a user's computer."
        ],
        "correct": 2,
        "explanation": "Debugging is the systematic process of identifying, locating, and correcting errors (bugs) in software code. It is a critical part of the software development life cycle.",
        "topic": "Software Development"
    },
    {
        "question": "What does 'cout' represent in C++?",
        "options": [
            "A function for input.",
            "The standard output stream (usually the screen).",
            "A variable that counts program lines.",
            "A compiler directive."
        ],
        "correct": 1,
        "explanation": "'cout' is the standard output stream object in C++. It is used in conjunction with the insertion operator (<<) to display data on the monitor.",
        "topic": "Standard I/O"
    },
    {
        "question": "Which keyword is used to prevent a variable's value from being modified after initialization?",
        "options": [
            "final",
            "static",
            "const",
            "fixed"
        ],
        "correct": 2,
        "explanation": "The 'const' (constant) keyword is used to declare variables whose value cannot be changed by the program once they are initialized. It is useful for defining fixed values like PI.",
        "topic": "Constants"
    },
    {
        "question": "What is 'Syntax' in programming?",
        "options": [
            "The logic used to solve a problem.",
            "The set of rules defining the structure of a language.",
            "A type of virus that affects compilers.",
            "The speed at which a program runs."
        ],
        "correct": 1,
        "explanation": "Syntax refers to the formal rules of a programming language (like grammar in English). If these rules are violated (e.g., missing a semicolon), the compiler will generate a 'Syntax Error'.",
        "topic": "Language Basics"
    },
    {
        "question": "Which library must be included to use 'cin' and 'cout'?",
        "options": [
            "math.h",
            "conio.h",
            "iostream",
            "stdio.h"
        ],
        "correct": 2,
        "explanation": "The 'iostream' (Input/Output Stream) library contains the definitions for cin and cout. Modern C++ uses <iostream> without the .h extension and requires the 'std' namespace.",
        "topic": "Standard Libraries"
    },
    {
        "question": "The '&&' operator returns true only if:",
        "options": [
            "One of the operands is true.",
            "Both operands are true.",
            "Both operands are false.",
            "The first operand is true."
        ],
        "correct": 1,
        "explanation": "'&&' is the logical AND operator. It only evaluates to true if both conditions on its left and right sides are true. If either one is false, the result is false.",
        "topic": "Logical Operators"
    },
    {
        "question": "Which specific design flaw in early C++ code led to the 'Y2K' concern, and how was it structurally addressed in modern standards?",
        "options": [
            "The use of 32-bit integers for timestamps.",
            "The getYear() method returning only two digits representing years since 1900.",
            "The inability of the compiler to process dates beyond December 31, 1999.",
            "A hardware limitation in the original Intel 4004 microprocessor."
        ],
        "correct": 1,
        "explanation": "As noted in the CS201 context of legacy systems, the getYear() method in early libraries returned the year minus 1900 (e.g., 99 for 1999). This caused logic errors when the year 2000 was represented as 100 or 00 depending on the implementation. The scholarly solution was the transition to getFullYear(), which provides a precise four-digit representation, ensuring chronological integrity.",
        "topic": "History and Data Types"
    },
    {
        "question": "In C++, what is the functional result of an 'Arithmetic Overflow' when an unsigned integer reaches its maximum bit-capacity and is incremented?",
        "options": [
            "The program throws a runtime exception and terminates.",
            "The value wraps around to zero.",
            "The variable is automatically promoted to a 'long' data type.",
            "The compiler issues a warning and pauses execution."
        ],
        "correct": 1,
        "explanation": "Overflow in C++ for unsigned integers is well-defined as modulo arithmetic. When a variable exceeds the maximum value its bits can represent, it 'wraps around' to the minimum value (zero). This is a critical logical risk because it does not trigger a crash, often leading to silent data corruption in financial or safety-critical calculations.",
        "topic": "Memory and Variables"
    },
    {
        "question": "Which of the following describes the behavior of a 'Short-Circuit Evaluation' in a logical AND (&&) operation?",
        "options": [
            "The second condition is evaluated only if the first is true.",
            "Both conditions are evaluated simultaneously by the CPU.",
            "The first condition is ignored if the second is true.",
            "The operation is skipped to save clock cycles if the variables are constant."
        ],
        "correct": 0,
        "explanation": "Short-circuiting is an optimization where the compiler stops evaluating a logical expression as soon as the outcome is certain. In an '&&' operation, if the first operand is false, the entire expression must be false; therefore, the second operand is never evaluated. This is often used to prevent errors, such as checking if a pointer is null before accessing its members.",
        "topic": "Logical Operators"
    },
    {
        "question": "Why is the use of 'Magic Numbers' (unnamed numerical constants) considered poor academic practice in programming?",
        "options": [
            "They consume more RAM than declared constants.",
            "They make the code difficult to maintain and obscure the logic's intent.",
            "They are not supported by the C++ linker.",
            "They cause the compiler to bypass the preprocessor."
        ],
        "correct": 1,
        "explanation": "Magic numbers are literals used in code without explanation (e.g., using 3.14 instead of a constant named PI). This is discouraged because if the value needs to change, it must be found and replaced in every instance manually. Using 'const' variables or macro definitions improves readability and allows for single-point updates.",
        "topic": "Coding Standards"
    },
    {
        "question": "In a C++ source file, what is the specific effect of the '#define' preprocessor directive?",
        "options": [
            "It reserves a memory address for a global variable.",
            "It performs a literal text substitution before the compilation phase.",
            "It includes a library file into the current project.",
            "It tells the linker to optimize a specific function."
        ],
        "correct": 1,
        "explanation": "The '#define' directive is used for macro substitution. The preprocessor scans the code and replaces every occurrence of the macro identifier with the defined text literal before the actual compiler starts. Unlike 'const', macros do not have a data type and are not subject to scope rules, which can occasionally lead to side effects.",
        "topic": "Preprocessor Directives"
    },
    {
        "question": "When passing an array to a function, why is the 'size' of the array usually passed as a separate argument?",
        "options": [
            "Because C++ arrays are automatically encrypted during transmission.",
            "Because the function only receives a pointer to the first element and loses 'size' information.",
            "Because the linker requires the size to allocate heap memory.",
            "Because it is a syntax requirement of the 'main' function."
        ],
        "correct": 1,
        "explanation": "In C++, when an array is passed to a function, it 'decays' into a pointer to its first element. The function has no internal way of knowing how many elements are in that array. Therefore, providing the size as a second parameter is essential for preventing 'Out of Bounds' errors during loop iterations within the function.",
        "topic": "Arrays and Functions"
    },
    {
        "question": "Which C++ loop construct is most appropriate when the number of iterations is known exactly before entering the loop?",
        "options": [
            "while loop",
            "do-while loop",
            "for loop",
            "if-else recursion"
        ],
        "correct": 2,
        "explanation": "The 'for' loop is specifically designed for 'count-controlled' iterations. Its structure—combining initialization, condition, and increment in one line—makes it the most readable and logical choice when the range (e.g., 1 to 100) is predetermined. While a 'while' loop could achieve the same result, it is conceptually better suited for 'event-controlled' loops.",
        "topic": "Control Structures"
    },
    {
        "question": "What is the scholarly significance of the 'Null Terminator' (\\0) in C-style strings?",
        "options": [
            "It indicates that the string is encrypted.",
            "It marks the end of the character sequence in memory.",
            "It tells the compiler to capitalize the first letter.",
            "It is used to separate the real part from the imaginary part of a number."
        ],
        "correct": 1,
        "explanation": "C-style strings are arrays of characters. Because the array size might be larger than the actual text, C++ uses the null character '\\0' (ASCII 0) to signal the end of the string. Functions like 'cout' read memory sequentially until they encounter this character; if it is missing, the program may continue reading adjacent memory, resulting in 'garbage' output or a crash.",
        "topic": "Strings"
    },
    {
        "question": "Which of the following is a primary difference between 'float' and 'double' data types in C++?",
        "options": [
            "Float can store characters, while double only stores numbers.",
            "Double provides approximately twice the significant digits of precision compared to float.",
            "Float is a 64-bit type, while double is a 32-bit type.",
            "Double variables cannot be used in mathematical formulas."
        ],
        "correct": 1,
        "explanation": "Precision is the primary differentiator. A 'float' typically offers about 7 decimal digits of precision and uses 4 bytes, while a 'double' (double precision) offers about 15-17 digits and uses 8 bytes. For scientific or financial calculations where accuracy is paramount, 'double' is the standard choice in C++.",
        "topic": "Data Types"
    },
    {
        "question": "In the context of 'Scope', what happens to a local variable when the function that contains it finishes execution?",
        "options": [
            "It is moved to a global registry.",
            "Its memory is deallocated and it ceases to exist.",
            "It is saved to the hard drive automatically.",
            "It remains in memory until the program is closed."
        ],
        "correct": 1,
        "explanation": "Local variables have 'Automatic Storage Duration'. They are created on the stack when the function is called and are 'popped' off or destroyed when the function returns. Attempting to access a local variable from outside its function is a syntax error, and returning a pointer to a local variable leads to 'undefined behavior'.",
        "topic": "Variable Scope"
    },
    {
        "question": "What is the output of the following logical expression: (true || false) && !true?",
        "options": [
            "true",
            "false",
            "1",
            "Syntax Error"
        ],
        "correct": 1,
        "explanation": "Evaluation starts inside the parentheses: (true || false) is true. The expression becomes (true && !true). The '!' operator has high precedence, so !true becomes false. Finally, (true && false) evaluates to false. Logical operations are the foundation of decision-making in C++ structures.",
        "topic": "Logical Operators"
    },
    {
        "question": "Which storage class is used to declare a variable that is shared across multiple files in a C++ project?",
        "options": [
            "static",
            "register",
            "extern",
            "auto"
        ],
        "correct": 2,
        "explanation": "The 'extern' keyword tells the compiler that a variable exists but is defined in another translation unit (file). This allows different parts of a large software project to share global state. 'static' (Option 0) does the opposite—it restricts a variable's visibility to the file in which it is defined.",
        "topic": "Storage Classes"
    },
    {
        "question": "In C++, the 'default' case in a switch statement is comparable to which part of an if-else chain?",
        "options": [
            "The first 'if' condition.",
            "The 'else if' condition.",
            "The final 'else' clause.",
            "The variable initialization."
        ],
        "correct": 2,
        "explanation": "The 'default' case acts as a catch-all. If none of the 'case' labels match the switch expression, the code under 'default' executes. Similarly, the 'else' clause in an if-else chain executes only if all preceding 'if' and 'else if' conditions evaluate to false.",
        "topic": "Switch Statement"
    },
    {
        "question": "What is the purpose of the 'break' statement in a loop (for/while)?",
        "options": [
            "To skip the current iteration and move to the next one.",
            "To exit the loop entirely and move to the next line of code after the loop.",
            "To restart the loop from the beginning.",
            "To pause the execution for a set number of seconds."
        ],
        "correct": 1,
        "explanation": "The 'break' statement provides an immediate exit from the innermost enclosing loop. It is often used when a specific search target is found or an error condition occurs, making further iterations unnecessary. 'continue' (Option 0) is the statement used to skip only the remainder of the current iteration.",
        "topic": "Control Structures"
    },
    {
        "question": "Which of the following character representations is a 'char' literal in C++?",
        "options": [
            "\"A\"",
            "'A'",
            "char(A)",
            "{A}"
        ],
        "correct": 1,
        "explanation": "C++ distinguishes between characters and strings using quotes. Single quotes (' ') denote a single 'char' literal, which is stored as its ASCII integer value. Double quotes (\" \") denote a string literal (an array of characters), which includes a hidden null terminator at the end.",
        "topic": "Data Types"
    },
    {
        "question": "In C++, what is the result of '5 % 10'?",
        "options": [
            "0",
            "2",
            "5",
            "0.5"
        ],
        "correct": 2,
        "explanation": "The modulus operator (%) returns the remainder of integer division. When the dividend (5) is smaller than the divisor (10), the division result is 0 and the entire dividend remains as the remainder. Thus, 5 % 10 is 5. This is frequently used in algorithms for circular indexing or digit extraction.",
        "topic": "Arithmetic Operators"
    },
    {
        "question": "Which function is used to check if a file has reached the end during a read operation in C++?",
        "options": [
            "file.stop()",
            "file.eof()",
            "file.finish()",
            "file.end()"
        ],
        "correct": 1,
        "explanation": "The 'eof()' (end-of-file) member function returns true if the last read operation reached the end of the file. It is commonly used as a condition in a while loop to process a file until all data has been consumed. Attempting to read past 'eof' will set the fail bit on the file stream.",
        "topic": "File I/O"
    },
    {
        "question": "What is the primary characteristic of an 'Algorithm' as discussed in the VU handouts?",
        "options": [
            "It must be written in C++ code.",
            "It must be a finite set of well-defined instructions.",
            "It must always involve mathematical division.",
            "It must be stored in a '.h' header file."
        ],
        "correct": 1,
        "explanation": "An algorithm is a conceptual solution to a problem, independent of any programming language. It must be finite (it must end), definite (each step is clear), and effective (it can be performed). Programming is the act of translating an algorithm into a language the computer can execute.",
        "topic": "Introduction to Programming"
    },
    {
        "question": "What is the function of the 'dereference' operator (*) when applied to a pointer variable?",
        "options": [
            "To find the memory address of the pointer itself.",
            "To access the value stored at the memory address the pointer is holding.",
            "To delete the pointer from memory.",
            "To multiply the address by two."
        ],
        "correct": 1,
        "explanation": "Dereferencing is the act of 'following' a pointer to its destination. If 'ptr' holds the address of 'x', then '*ptr' is equivalent to 'x'. It allows the program to read or modify the data at that specific address indirectly, which is the core of dynamic memory management and linked lists.",
        "topic": "Pointers"
    },
    {
        "question": "In the C++ standard library, 'cout' is an object of which class?",
        "options": [
            "ifstream",
            "ofstream",
            "ostream",
            "iostream"
        ],
        "correct": 2,
        "explanation": "'cout' is the standard output stream object, belonging to the 'ostream' class. It is used to send data to the standard output device (usually the screen). 'iostream' (Option 3) is the library that includes both 'ostream' and 'istream' definitions.",
        "topic": "Standard I/O"
    },
    {
        "question": "Which of the following is the correct way to declare a constant named 'TAX_RATE' with a value of 0.05?",
        "options": [
            "constant float TAX_RATE = 0.05;",
            "const double TAX_RATE = 0.05;",
            "TAX_RATE const = 0.05;",
            "#define TAX_RATE = 0.05"
        ],
        "correct": 1,
        "explanation": "In C++, the 'const' keyword is used to declare read-only variables. The syntax requires 'const' followed by the data type, the name, and the initialization. Using 'const' is superior to '#define' (Option 3) because it provides type safety and respects scope rules.",
        "topic": "Constants"
    },
    {
        "question": "What happens if a programmer fails to include a 'base case' in a recursive function?",
        "options": [
            "The function will return zero automatically.",
            "The program will crash due to a 'Stack Overflow'.",
            "The compiler will fix the logic during optimization.",
            "The function will execute only once."
        ],
        "correct": 1,
        "explanation": "Recursion requires a base case to terminate. Without one, the function calls itself infinitely. Each call adds a new 'frame' to the system stack; eventually, the stack memory is exhausted, leading to a stack overflow error and a program crash. This is a common logical error in advanced C++ programming.",
        "topic": "Recursion"
    },
    {
        "question": "In C++, which operator is used for 'Logical OR'?",
        "options": [
            "&",
            "|",
            "&&",
            "||"
        ],
        "correct": 3,
        "explanation": "The double vertical bar '||' represents Logical OR. It returns true if at least one of the conditions is true. The single bar '|' (Option 1) is the Bitwise OR operator, which performs operations on individual bits rather than Boolean values.",
        "topic": "Logical Operators"
    },
    {
        "question": "Which C++ data type would be most efficient for storing a 'True/False' value?",
        "options": [
            "int",
            "char",
            "bool",
            "double"
        ],
        "correct": 2,
        "explanation": "The 'bool' data type is specifically designed for Boolean values. It can only hold two states: 'true' (1) or 'false' (0). While 'int' could be used, 'bool' clearly communicates the intent of the variable and is the semantic standard in C++.",
        "topic": "Data Types"
    },
    {
        "question": "What is the index of the first element in any C++ array?",
        "options": [
            "1",
            "0",
            "-1",
            "Any number defined by the programmer."
        ],
        "correct": 1,
        "explanation": "C++ uses zero-based indexing. This means the first element of an array is accessed at index 0, and the last element of an array of size 'N' is at index 'N-1'. This is a fundamental rule inherited from the C language and is consistent across almost all data structures in C++.",
        "topic": "Arrays"
    },
    {
        "question": "Which of the following is NOT a valid escape sequence in C++?",
        "options": [
            "\\n",
            "\\t",
            "\\s",
            "\\\\"
        ],
        "correct": 2,
        "explanation": "'\\n' is newline, '\\t' is tab, and '\\\\' is a literal backslash. '\\s' is not a standard C++ escape sequence (though it is used in regular expressions in other languages). To represent a space in a string, one simply uses a space character.",
        "topic": "Strings and Characters"
    },
    {
        "question": "In C++, what is the purpose of the 'return 0;' statement at the end of the main() function?",
        "options": [
            "To tell the compiler to clear the RAM.",
            "To indicate to the Operating System that the program ended successfully.",
            "To display a zero on the computer screen.",
            "To restart the program from the beginning."
        ],
        "correct": 1,
        "explanation": "The main function is an entry point called by the OS. The integer it returns is an 'Exit Code'. By convention, 0 signifies that the program completed its task without errors. Non-zero values are used to signal specific error types to the system or calling scripts.",
        "topic": "Functions"
    },
    {
        "question": "Which header file is required to perform mathematical operations like 'sqrt()' or 'pow()' in C++?",
        "options": [
            "iostream",
            "math.h (or cmath)",
            "stdlib.h",
            "conio.h"
        ],
        "correct": 1,
        "explanation": "The 'cmath' (or the legacy 'math.h') header contains the prototypes for standard mathematical functions. Without including this header, the compiler will not recognize 'sqrt', 'sin', 'pow', etc., leading to an 'undeclared identifier' error.",
        "topic": "Standard Libraries"
    },
    {
        "question": "What is the characteristic of a 'Global Variable'?",
        "options": [
            "It can only be used inside the 'main' function.",
            "It is accessible from any function within the same file.",
            "It is automatically deleted after 10 seconds of use.",
            "It cannot be modified once it is initialized."
        ],
        "correct": 1,
        "explanation": "Global variables are declared outside of all functions. Their 'Scope' is the entire file, meaning any function in that file can read or change their value. While useful, excessive use of global variables is discouraged because it makes the program state difficult to track and debug.",
        "topic": "Variable Scope"
    },
    {
        "question": "Which operator is used to extract data from a stream (like 'cin') into a variable?",
        "options": [
            "<<",
            ">>",
            "==",
            "&&"
        ],
        "correct": 1,
        "explanation": "The '>>' operator is known as the 'Extraction Operator' (or get-from). It takes data from the input stream and places it into the variable on the right. '<<' (Option 0) is the 'Insertion Operator' (or put-to), used with 'cout'.",
        "topic": "Standard I/O"
    },
    {
        "question": "Which of the following describes the 'Top-Down Design' approach in C++ software development?",
        "options": [
            "Starting with small coding details and joining them to form a larger system.",
            "Defining the main problem first and then breaking it into smaller, manageable sub-problems.",
            "Writing the entire code in the main() function without using external libraries.",
            "Developing the user interface before determining the underlying program logic."
        ],
        "correct": 1,
        "explanation": "Top-Down Design, also known as 'Stepwise Refinement', is a core strategy in structured programming. It involves taking a complex problem and decomposing it into simpler tasks (modules). This makes the logic easier to trace and debug. Option 0 describes 'Bottom-Up Design', while Option 2 describes poor programming practice that leads to monolithic, unmanageable code.",
        "topic": "Structured Programming"
    },
    {
        "question": "What is the primary difference between a 'Global Variable' and a 'Local Variable' regarding memory duration?",
        "options": [
            "Local variables stay in memory for the life of the program, while global variables are temporary.",
            "Global variables are created on the stack, whereas local variables are stored in the data segment.",
            "Global variables exist as long as the program is running, while local variables are destroyed when the function exits.",
            "There is no difference in memory duration; both are destroyed when the CPU clears the cache."
        ],
        "correct": 2,
        "explanation": "Global variables have 'Static Storage Duration', meaning they are allocated when the program starts and deallocated only when the program terminates. Local variables have 'Automatic Storage Duration'; they are created on the stack when a function is called and automatically removed when the function returns. This distinction is critical for managing memory efficiency and preventing data persistence bugs.",
        "topic": "Variable Scope and Visibility"
    },
    {
        "question": "In C++, which specific error occurs if a programmer attempts to access 'array[10]' in an array declared as 'int array[10];'?",
        "options": [
            "The compiler will generate a syntax error and stop the build.",
            "The program will result in a logical 'Index Out of Bounds' runtime error or undefined behavior.",
            "The computer will automatically expand the array to 11 elements to prevent a crash.",
            "The value at array[0] will be returned by default."
        ],
        "correct": 1,
        "explanation": "C++ uses zero-based indexing. An array of size 10 has valid indices from 0 to 9. Accessing index 10 is an 'off-by-one' error. Since C++ does not perform automatic boundary checking at runtime for performance reasons, this will access an adjacent memory location, leading to unpredictable results (undefined behavior) or a memory access violation (segmentation fault).",
        "topic": "Arrays"
    },
    {
        "question": "Which logical operator is used to perform a 'Short-Circuit' OR operation in C++?",
        "options": [
            "&",
            "|",
            "&&",
            "||"
        ],
        "correct": 3,
        "explanation": "The '||' (Logical OR) operator uses short-circuit evaluation. If the first operand is true, the entire expression must be true, so the second operand is not evaluated. This is highly efficient and prevents unnecessary calculations or errors in the second part of the condition. In contrast, '|' (Option 1) is a bitwise operator that evaluates both sides.",
        "topic": "Logical Operators"
    },
    {
        "question": "What is the purpose of the 'const' qualifier in a function parameter, such as 'void display(const int arr[])'?",
        "options": [
            "To tell the compiler that the array size is a constant number.",
            "To prevent the function from modifying the contents of the passed array.",
            "To speed up the function call by bypassing the stack.",
            "To allow the function to return multiple constant values."
        ],
        "correct": 1,
        "explanation": "When an array is passed to a function, it is passed by reference (the address is sent). Using 'const' is a safety mechanism; it ensures that the function treats the data as read-only. If the function attempts to change a value in the array, the compiler will generate an error. This is a scholarly way of protecting data integrity.",
        "topic": "Function Parameters"
    },
    {
        "question": "Which of the following is a characteristic of 'Call by Reference' using pointers?",
        "options": [
            "A copy of the variable's value is passed to the function.",
            "The function receives the memory address of the actual variable.",
            "Any changes made in the function are lost when the function returns.",
            "It uses more memory than 'Call by Value' for large structures."
        ],
        "correct": 1,
        "explanation": "In 'Call by Reference' via pointers, the address of the variable is passed. This allows the function to access and modify the original data directly in memory. This is more efficient for large data structures like arrays or structs because it avoids the overhead of copying the entire data set into the function's local memory.",
        "topic": "Pointers and Functions"
    },
    {
        "question": "What is the resulting value of 'z' after the following code executes: 'int x = 10, y = 3; float z = x / y;'?",
        "options": [
            "3.333",
            "3.0",
            "4",
            "0.3"
        ],
        "correct": 1,
        "explanation": "In C++, dividing an integer by an integer results in 'Integer Division', which truncates the decimal portion. 10 / 3 equals 3. Even though 'z' is a float, the calculation 'x / y' is performed first as an integer operation. The result (3) is then promoted to a float (3.0) for storage in 'z'. To get 3.333, at least one operand would need to be cast to a float.",
        "topic": "Arithmetic Operations"
    },
    {
        "question": "Which C++ header file must be included to use formatted I/O manipulators like 'setw' and 'setprecision'?",
        "options": [
            "iostream",
            "iomanip",
            "stdlib.h",
            "math.h"
        ],
        "correct": 1,
        "explanation": "The <iomanip> header stands for 'Input/Output Manipulation'. It contains the definitions for parameterized stream manipulators that allow programmers to format the output, such as setting field widths (setw) or the number of decimal places (setprecision). <iostream> (Option 0) only provides basic stream functionality.",
        "topic": "Formatted Output"
    },
    {
        "question": "A 'Dangling Pointer' occurs when:",
        "options": [
            "A pointer is declared but not initialized to NULL.",
            "A pointer still points to a memory location after that memory has been deallocated.",
            "A pointer points to a global variable that is too large for the CPU.",
            "A pointer is used to perform arithmetic on a float variable."
        ],
        "correct": 1,
        "explanation": "A dangling pointer is a dangerous logical error. It happens when the memory a pointer was pointing to is freed (using delete) or goes out of scope, but the pointer still holds that address. If the program attempts to access that 'dead' memory, it can cause a crash or unpredictable data corruption.",
        "topic": "Pointers"
    },
    {
        "question": "In C++, the 'sizeof' operator returns the size of a data type in:",
        "options": [
            "Bits",
            "Nibbles",
            "Bytes",
            "Kilobytes"
        ],
        "correct": 2,
        "explanation": "The 'sizeof' operator is a compile-time operator that returns the size of a type or variable in bytes. For example, 'sizeof(int)' typically returns 4 on modern systems. This is essential for calculating memory requirements for dynamic allocation and for understanding hardware-specific data representation.",
        "topic": "Operators"
    },
    {
        "question": "Which specific 'Vir' protein in Agrobacterium is responsible for 'nicking' the T-DNA at the border sequences to initiate transfer?",
        "options": [
            "VirA",
            "VirG",
            "VirD2",
            "VirE2"
        ],
        "correct": 2,
        "explanation": "VirD2 is an endonuclease that recognizes the border repeats on the Ti plasmid and makes a precise single-stranded cut (nick). It then remains covalently attached to the 5' end of the T-strand during the transfer process. VirA/VirG are signaling proteins, and VirE2 coats and protects the DNA.",
        "topic": "Agriculture Biotechnology"
    },
    {
        "question": "In the growth curve of a cell suspension culture, which phase is reached when the growth rate equals the death rate due to nutrient depletion?",
        "options": [
            "Lag Phase",
            "Exponential Phase",
            "Stationary Phase",
            "Death Phase"
        ],
        "correct": 2,
        "explanation": "The Stationary Phase is reached when the available nutrients in the medium are exhausted or toxic by-products accumulate. At this point, the rate of new cell production equals the rate of cell death, resulting in no net growth. The Exponential phase (Option 1) is the period of maximum growth.",
        "topic": "Cell Suspension Culture"
    },
    {
        "question": "What is the result of the JavaScript expression 'typeof [1, 2, 3]'?",
        "options": [
            "\"array\"",
            "\"list\"",
            "\"object\"",
            "\"collection\""
        ],
        "correct": 2,
        "explanation": "In JavaScript, arrays are technically a specialized type of 'object'. Therefore, the 'typeof' operator returns 'object' when used on an array. To specifically check if something is an array, developers usually use 'Array.isArray()'.",
        "topic": "Data Types"
    },
    {
        "question": "In a loop used to traverse an array, what is the standard condition to ensure the loop stops at the end of the array?",
        "options": [
            "i <= array.length",
            "i < array.length",
            "i == array.length",
            "i > array.length"
        ],
        "correct": 1,
        "explanation": "Because array indexing starts at 0, the last index is always 'length - 1'. Therefore, the loop should continue as long as the index 'i' is *strictly less than* the length. Using '<=' (Option 0) would cause the loop to run one extra time, attempting to access an undefined index.",
        "topic": "Loops and Arrays"
    },
    {
        "question": "Which mode is used with 'ofstream' to open a file for writing such that new data is added to the end of the existing content?",
        "options": [
            "ios::in",
            "ios::out",
            "ios::app",
            "ios::trunc"
        ],
        "correct": 2,
        "explanation": "'ios::app' stands for append mode. It ensures that every write operation occurs at the end of the file, preserving existing data. 'ios::out' (Option 1) overwrites existing data by default, and 'ios::trunc' (Option 3) explicitly deletes the existing content upon opening.",
        "topic": "File I/O"
    },
    {
        "question": "What is the value of 'y' after the execution: int x = 5; int y = ++x * 2;?",
        "options": [
            "10",
            "11",
            "12",
            "15"
        ],
        "correct": 2,
        "explanation": "The prefix increment operator (++x) increments the value of x to 6 *before* it is used in the expression. Therefore, 6 * 2 = 12. If it were a postfix operator (x++), the result would have been 10, and x would become 6 afterward.",
        "topic": "Increment/Decrement Operators"
    },
    {
        "question": "A 'Null Pointer' is a pointer that:",
        "options": [
            "Points to the address 0 or 'nowhere'.",
            "Has been deleted but still points to a memory location.",
            "Is used to store character strings only.",
            "Points to the memory address of the CPU."
        ],
        "correct": 0,
        "explanation": "A Null Pointer is a pointer that is assigned the value 0 (or NULL/nullptr). It signifies that the pointer does not currently point to a valid memory address. It is a safety practice to initialize pointers to NULL to avoid 'dangling pointers'.",
        "topic": "Pointers"
    },
    {
        "question": "In a 'for' loop, which part of the statement is executed only once?",
        "options": [
            "Initialization",
            "Condition",
            "Increment/Decrement",
            "Body"
        ],
        "correct": 0,
        "explanation": "The initialization part of a for-loop (e.g., int i = 0) is executed only once when the loop starts. The condition is checked at every iteration, and the increment is performed after every body execution.",
        "topic": "Loops"
    },
    {
        "question": "What is the purpose of the 'default' keyword in a switch statement?",
        "options": [
            "To reset all variables to zero.",
            "To provide a fallback block of code if no case match is found.",
            "To define the first case that should always be executed.",
            "To tell the compiler to ignore errors in the switch block."
        ],
        "correct": 1,
        "explanation": "The 'default' case acts like the 'else' in an if-else chain. If none of the 'case' constants match the switch expression, the code inside the default block is executed. It is optional but recommended for robust programming.",
        "topic": "Control Structures"
    },
    {
        "question": "Which of the following describes the 'Call by Value' mechanism?",
        "options": [
            "A copy of the actual argument is passed to the function.",
            "The memory address of the argument is passed to the function.",
            "The function can modify the original variable used as an argument.",
            "The function returns a reference to a global variable."
        ],
        "correct": 0,
        "explanation": "In 'Call by Value', a separate copy of the variable's data is created for the function. Any changes made to the parameter inside the function do not affect the original variable in the calling function. 'Call by Reference' (Option 1) is what allows original data modification.",
        "topic": "Function Parameters"
    },
    {
        "question": "The 'main()' function in C++ must return an integer value to:",
        "options": [
            "The user of the computer.",
            "The compiler.",
            "The Operating System.",
            "The Linker."
        ],
        "correct": 2,
        "explanation": "The return value of 'main' (usually 0 for success) is an exit code sent back to the Operating System. It informs the system whether the program executed successfully or encountered an error.",
        "topic": "Functions"
    },
    {
        "question": "Which of the following is true about 'Structures' in C++?",
        "options": [
            "They can only store variables of the same data type.",
            "They are defined using the 'class' keyword only.",
            "They allow grouping of different data types into a single unit.",
            "They cannot be passed as arguments to functions."
        ],
        "correct": 2,
        "explanation": "Structures (struct) are used to group variables of *different* data types together under a single name. This allows for the creation of complex data models, like a 'Student' structure containing a string for name and an int for roll number.",
        "topic": "Structures"
    },
    {
        "question": "What is the escape sequence for a 'newline' character in C++?",
        "options": [
            "\\t",
            "\\n",
            "\\b",
            "\\r"
        ],
        "correct": 1,
        "explanation": "'\\n' is the escape sequence for a newline. '\\t' (Option 0) is for a horizontal tab, '\\b' (Option 2) is for a backspace, and '\\r' (Option 3) is for a carriage return.",
        "topic": "Strings and Characters"
    },
    {
        "question": "Which operator has the highest precedence in C++ among the following?",
        "options": [
            "+",
            "=",
            "*",
            "()"
        ],
        "correct": 3,
        "explanation": "Parentheses '()' have the highest precedence in C++. They are used to override the default order of operations. Among the others, '*' is higher than '+', and '=' (assignment) has the lowest precedence.",
        "topic": "Operator Precedence"
    },
    {
        "question": "In the declaration 'int *ptr;', what does 'ptr' store?",
        "options": [
            "An integer value.",
            "A memory address.",
            "A character string.",
            "A floating-point result."
        ],
        "correct": 1,
        "explanation": "The asterisk (*) indicates that 'ptr' is a pointer variable. Pointer variables are specifically designed to store memory addresses of other variables, not raw data values.",
        "topic": "Pointers"
    },
    {
        "question": "What is the index of the last element in an array of size 10?",
        "options": [
            "10",
            "9",
            "0",
            "11"
        ],
        "correct": 1,
        "explanation": "C++ arrays use zero-based indexing. For an array of size 'n', the indices range from 0 to n-1. Therefore, in an array of size 10, the last index is 9.",
        "topic": "Arrays"
    },
    {
        "question": "Which loop is a 'Post-Test' loop, meaning it checks the condition after executing the body?",
        "options": [
            "for",
            "while",
            "do-while",
            "if-else"
        ],
        "correct": 2,
        "explanation": "A 'do-while' loop is a post-test loop. It executes the body first and then checks the condition. This ensures that the code inside the loop runs at least once, regardless of whether the condition is true or false initially.",
        "topic": "Loops"
    },
    {
        "question": "The process of 'Debugging' involves:",
        "options": [
            "Writing the initial source code.",
            "Converting source code to machine code.",
            "Finding and fixing errors in a program.",
            "Installing the program on a user's computer."
        ],
        "correct": 2,
        "explanation": "Debugging is the systematic process of identifying, locating, and correcting errors (bugs) in software code. It is a critical part of the software development life cycle.",
        "topic": "Software Development"
    },
    {
        "question": "What does 'cout' represent in C++?",
        "options": [
            "A function for input.",
            "The standard output stream (usually the screen).",
            "A variable that counts program lines.",
            "A compiler directive."
        ],
        "correct": 1,
        "explanation": "'cout' is the standard output stream object in C++. It is used in conjunction with the insertion operator (<<) to display data on the monitor.",
        "topic": "Standard I/O"
    },
    {
        "question": "Which keyword is used to prevent a variable's value from being modified after initialization?",
        "options": [
            "final",
            "static",
            "const",
            "fixed"
        ],
        "correct": 2,
        "explanation": "The 'const' (constant) keyword is used to declare variables whose value cannot be changed by the program once they are initialized. It is useful for defining fixed values like PI.",
        "topic": "Constants"
    },
    {
        "question": "Which specific design objective in C++ involves providing 'Abstraction', allowing a programmer to focus on 'what' a module does rather than 'how' it is implemented?",
        "options": [
            "Encapsulation",
            "Stepwise Refinement",
            "Information Hiding",
            "Linear Execution"
        ],
        "correct": 1,
        "explanation": "Stepwise Refinement (also known as Top-Down Design) is the process of breaking a complex problem into smaller, abstract modules. By defining the high-level logic first, the programmer creates an abstraction layer. Encapsulation and Information Hiding (Options 0 and 2) are related but specifically deal with bundling data and restricting access to internal states, while Abstraction is about simplifying complexity at the design level.",
        "topic": "Structured Programming"
    },
    {
        "question": "In the C++ memory model, which segment is used for the dynamic allocation of memory via the 'new' operator during program execution?",
        "options": [
            "Stack",
            "Heap",
            "Data Segment",
            "Code Segment"
        ],
        "correct": 1,
        "explanation": "The Heap (or Free Store) is the area of memory reserved for dynamic allocation. Unlike the Stack (Option 0), which handles local variables and function calls automatically, the Heap allows the programmer to determine the lifetime of a variable manually. Memory in the Heap must be explicitly freed using 'delete' to prevent memory leaks.",
        "topic": "Memory Management"
    },
    {
        "question": "According to the CS201 handouts, what is the 'Dangling Pointer' problem?",
        "options": [
            "A pointer that has been declared but not yet initialized.",
            "A pointer that holds the address of a memory block that has already been deallocated.",
            "A pointer that is pointing to a variable of a different data type.",
            "A pointer that is stored in the code segment instead of the data segment."
        ],
        "correct": 1,
        "explanation": "A dangling pointer arises when the memory it points to is freed (using delete) or goes out of scope, but the pointer still retains that memory address. Accessing such a pointer leads to undefined behavior or crashes because the program is trying to access 'stale' or 'dead' memory that may have been reassigned to another process.",
        "topic": "Pointers"
    },
    {
        "question": "What is the resulting output of the expression: cout << (15 % 4 + 7 / 2);",
        "options": [
            "6",
            "6.5",
            "7",
            "10"
        ],
        "correct": 0,
        "explanation": "The modulo and division operators have equal precedence and are evaluated left-to-right. First, 15 % 4 calculates the remainder, which is 3. Next, 7 / 2 is integer division, which truncates the decimal and results in 3. Finally, the addition 3 + 3 results in 6. If floating-point division were used (7 / 2.0), the result would be 6.5, but C++ defaults to integer division for int operands.",
        "topic": "Arithmetic Operators"
    },
    {
        "question": "Which of the following describes the 'Short-Circuit' behavior of the logical AND (&&) operator in C++?",
        "options": [
            "The entire expression is evaluated regardless of the values.",
            "If the first operand is true, the second operand is not evaluated.",
            "If the first operand is false, the second operand is not evaluated.",
            "It converts all non-zero integers to the value of 1."
        ],
        "correct": 2,
        "explanation": "C++ optimizes logical AND operations via short-circuiting. Since an AND expression requires both sides to be true, if the first side is false, the entire expression must be false. The compiler skips the second part to save processing time and to avoid potential errors (like dividing by zero or dereferencing a null pointer) in the second operand.",
        "topic": "Logical Operators"
    },
    {
        "question": "In a 'do-while' loop, which of the following is a guaranteed characteristic?",
        "options": [
            "The loop condition is tested before the first execution of the body.",
            "The loop body will execute at least once.",
            "The loop will continue indefinitely if the condition is initialized to false.",
            "It is more memory-efficient than a standard 'for' loop."
        ],
        "correct": 1,
        "explanation": "The 'do-while' is a post-test loop. It executes the statements within the 'do' block first and only then evaluates the condition at the 'while' statement. This structure guarantees that the code inside the loop runs at least one time, whereas 'while' and 'for' loops (pre-test loops) may run zero times.",
        "topic": "Control Structures"
    },
    {
        "question": "Which keyword is used to return the size of a variable or data type in bytes during compilation?",
        "options": [
            "lengthof",
            "bitsize",
            "sizeof",
            "memsize"
        ],
        "correct": 2,
        "explanation": "The 'sizeof' operator is a built-in C++ operator used to determine the exact amount of memory (in bytes) occupied by a data type or a variable. This is essential when performing manual memory allocation or when writing code that needs to be portable across different hardware architectures where 'int' sizes might vary.",
        "topic": "Memory and Variables"
    },
    {
        "question": "When defining a structure (struct), what is the default access level for its members?",
        "options": [
            "Private",
            "Protected",
            "Public",
            "Static"
        ],
        "correct": 2,
        "explanation": "In C++, the only technical difference between a 'struct' and a 'class' is the default access level. Structure members are 'public' by default, meaning they can be accessed from outside the struct. Class members are 'private' by default. This reflects the historical roots of 'struct' in C, where data was generally accessible.",
        "topic": "Structures"
    },
    {
        "question": "What is the effect of using the 'const' keyword in the declaration 'void myFunc(const int *ptr);'?",
        "options": [
            "The pointer address itself cannot be changed.",
            "The integer value pointed to by the pointer cannot be changed.",
            "Both the address and the value are locked.",
            "The function can only be called once."
        ],
        "correct": 1,
        "explanation": "This is a pointer to a constant integer. The function can move the pointer to a different address, but it is forbidden from modifying the value stored at the current address. This is a common way to pass large data to functions for reading purposes without risking accidental modification.",
        "topic": "Pointers and Constants"
    },
    {
        "question": "Which tool in the C++ environment is responsible for including the contents of header files into the source code before the actual translation begins?",
        "options": [
            "The Linker",
            "The Compiler",
            "The Preprocessor",
            "The Debugger"
        ],
        "correct": 2,
        "explanation": "The Preprocessor scans the source code for directives starting with '#'. When it sees '#include', it physically copies the text of the specified file into the source. This happens before the Compiler (Option 1) begins turning the code into assembly or object code. The Linker (Option 0) works only after object files are created.",
        "topic": "Program Development Cycle"
    },
    {
        "question": "What is the primary technical function of 'Function Overloading'?",
        "options": [
            "To allow a function to call itself recursively.",
            "To allow multiple functions to have the same name with different parameter lists.",
            "To increase the execution speed of mathematical functions.",
            "To allow a function to return multiple data types simultaneously."
        ],
        "correct": 1,
        "explanation": "Function Overloading allows the programmer to define several functions with the same name, provided their 'signature' (number or types of parameters) is different. The compiler uses 'Name Mangling' to distinguish them and calls the version that matches the arguments provided. This improves code readability and consistency.",
        "topic": "Function Overloading"
    },
    {
        "question": "In C++, an 'Array' name is technically treated as:",
        "options": [
            "A variable that holds the total count of elements.",
            "A constant pointer to the first element of the array.",
            "A function that returns the last element of the array.",
            "A reference to a dynamic memory block in the stack."
        ],
        "correct": 1,
        "explanation": "The name of an array (e.g., 'arr' for 'int arr[5]') is a constant pointer to the memory address of the very first element (index 0). Because it is a constant pointer, you cannot change where the array name points (e.g., 'arr++' is illegal), but you can use it for pointer arithmetic to access elements.",
        "topic": "Arrays"
    },
    {
        "question": "Which 'ios' flag is used to open a file for output and ensures that all new data is written at the end of the existing content?",
        "options": [
            "ios::out",
            "ios::trunc",
            "ios::app",
            "ios::beg"
        ],
        "correct": 2,
        "explanation": "The 'ios::app' (append) flag ensures that the file pointer is moved to the very end of the file before every write operation. This prevents existing data from being overwritten. 'ios::out' (Option 0) is for general output, and 'ios::trunc' (Option 1) is used to delete existing contents when the file is opened.",
        "topic": "File I/O"
    },
    {
        "question": "What is the significance of the 'Null Terminator' (\\0) in C++ string handling?",
        "options": [
            "It tells the compiler to capitalize the string.",
            "It marks the end of a C-style character array (string).",
            "It is used to separate the integer part from the decimal part.",
            "It clears the memory after a string is displayed."
        ],
        "correct": 1,
        "explanation": "C-style strings (char arrays) do not have a built-in property to track their length. Instead, C++ uses the null character '\\0' (ASCII value 0) to signal where the string ends. Functions like 'cout' read memory byte-by-byte until they hit this character. If it is missing, the program will continue reading adjacent memory, often resulting in 'garbage' output.",
        "topic": "Strings"
    },
    {
        "question": "Which of the following is a strict requirement for a variable used as a 'Switch' expression in C++?",
        "options": [
            "It must be a floating-point number.",
            "It must be an integral type (int, char, enum).",
            "It must be a constant literal.",
            "It must be a Boolean value only."
        ],
        "correct": 1,
        "explanation": "The 'switch' statement works by comparing a variable against constant case values. C++ requires the expression to evaluate to an integral type (whole numbers or characters). It cannot use 'float' or 'double' because exact equality is difficult to guarantee with decimal precision in binary.",
        "topic": "Control Structures"
    },
    {
        "question": "What is the output of: int i=5; cout << i++ << ++i;",
        "options": [
            "57",
            "66",
            "56",
            "Undefined behavior (compiler dependent)"
        ],
        "correct": 3,
        "explanation": "In older C++ standards (C++11 and prior), modifying the same variable multiple times within a single sequence point (like a single 'cout' statement) resulted in 'Undefined Behavior'. While newer standards have clarified evaluation order, it is considered a significant logical error and poor academic practice because different compilers may produce different results (e.g., 57 or 66).",
        "topic": "Increment/Decrement Operators"
    },
    {
        "question": "In the context of 'Call by Reference', how does the function's treatment of an argument differ from 'Call by Value'?",
        "options": [
            "It creates a temporary copy of the data on the stack.",
            "It receives the memory address of the original variable.",
            "It prevents the function from accessing the original data.",
            "It automatically converts integers to floating-point numbers."
        ],
        "correct": 1,
        "explanation": "In 'Call by Value', a copy of the data is made; changes inside the function do not affect the original variable. In 'Call by Reference' (using & or pointers), the function works directly with the original variable's memory address. This allows the function to modify the original data and is more efficient for passing large structures like arrays.",
        "topic": "Function Parameters"
    },
    {
        "question": "Which function is used to physically move the file position pointer for an 'ifstream' object?",
        "options": [
            "seekp()",
            "tellg()",
            "seekg()",
            "tellp()"
        ],
        "correct": 2,
        "explanation": "The 'seekg()' (seek get) function is used with input streams to move the pointer to a specific byte location in a file. 'seekp()' (seek put) is for output streams. 'tellg()' and 'tellp()' are used to report (tell) the current location of the pointer rather than moving it.",
        "topic": "File Handling"
    },
    {
        "question": "What is the primary danger of using a 'recursive' function without a properly defined base case?",
        "options": [
            "The program will execute faster but use more power.",
            "The program will enter an infinite loop and eventually cause a stack overflow.",
            "The compiler will ignore the function entirely.",
            "The result will be automatically rounded to zero."
        ],
        "correct": 1,
        "explanation": "Recursion relies on the system stack to keep track of function calls. If there is no base case (termination condition), the function will call itself infinitely. Each call adds a new layer to the stack memory; eventually, the stack runs out of space, leading to a 'Stack Overflow' error and a crash.",
        "topic": "Recursion"
    },
    {
        "question": "Which of the following is the correct way to declare a constant character pointer to a constant integer?",
        "options": [
            "const int *ptr;",
            "int *const ptr;",
            "const int *const ptr;",
            "int const *ptr;"
        ],
        "correct": 2,
        "explanation": "The syntax 'const int *const ptr' means two things: 1) the integer value being pointed to is constant (cannot be changed via the pointer), and 2) the pointer itself is constant (it cannot be changed to point to a different memory address). This provides the highest level of data protection for pointers.",
        "topic": "Pointers and Constants"
    },
    {
        "question": "In the CS201 curriculum, 'Top-Down Design' is also referred to as:",
        "options": [
            "Object-Oriented Design",
            "Stepwise Refinement",
            "Binary Abstraction",
            "Recursive Decomposition"
        ],
        "correct": 1,
        "explanation": "Stepwise Refinement is the process of defining a high-level solution and then iteratively refining the details of each component until they can be implemented in code. This is a hallmark of structured programming, designed to manage the complexity of large software projects by dividing and conquering problems.",
        "topic": "Structured Programming"
    },
    {
        "question": "What is the size of a 'double' data type in C++ on most modern 32-bit and 64-bit systems?",
        "options": [
            "2 bytes",
            "4 bytes",
            "8 bytes",
            "16 bytes"
        ],
        "correct": 2,
        "explanation": "A 'double' (double precision floating-point) is standardized to occupy 8 bytes (64 bits). It provides much higher precision and a larger range of values than the 4-byte 'float' type. This is the standard data type for scientific and financial calculations in C++ where precision is critical.",
        "topic": "Data Types"
    },
    {
        "question": "Which operator is used to determine the memory address of a variable?",
        "options": [
            "*",
            "&",
            "->",
            "#"
        ],
        "correct": 1,
        "explanation": "The ampersand (&) is the 'Address-of' operator. When placed before a variable name, it returns the memory address where that variable is stored. This address can then be stored in a pointer variable. The asterisk (*) is used for dereferencing (getting the value at an address).",
        "topic": "Pointers"
    },
    {
        "question": "In C++, which of the following is true about 'Global Variables'?",
        "options": [
            "They are stored on the stack and destroyed after function calls.",
            "They are accessible to all functions within the same file (or across files if using extern).",
            "They cannot be modified once they are initialized.",
            "They must be declared inside the main() function."
        ],
        "correct": 1,
        "explanation": "Global variables are declared outside of all function bodies. Their scope is the entire file, making them visible to every function. While they provide an easy way to share data, their use is often discouraged because they make it difficult to track changes to the program state and can lead to bugs in large systems.",
        "topic": "Variable Scope"
    },
    {
        "question": "What is the purpose of the 'break' statement when used in a 'for' or 'while' loop?",
        "options": [
            "To skip the current iteration and move to the next one.",
            "To exit the loop entirely and continue with the next statement after the loop.",
            "To restart the current iteration from the beginning.",
            "To terminate the entire program immediately."
        ],
        "correct": 1,
        "explanation": "The 'break' statement is a control flow tool that immediately terminates the innermost loop it is contained within. It is commonly used when a search target is found or a specific exit condition is met, saving unnecessary iterations. To skip only the current iteration, 'continue' (Option 0) is used.",
        "topic": "Control Structures"
    },
    {
        "question": "Which mode is the default when opening a file with 'ifstream'?",
        "options": [
            "ios::out",
            "ios::in",
            "ios::binary",
            "ios::app"
        ],
        "correct": 1,
        "explanation": "'ifstream' stands for Input File Stream. Therefore, its default mode is 'ios::in', which opens the file for reading. If the file does not exist, the stream will enter a 'fail' state. For writing, 'ofstream' defaults to 'ios::out'.",
        "topic": "File I/O"
    },
    {
        "question": "In the declaration 'int *p = &x;', what is 'p' storing?",
        "options": [
            "The value of x.",
            "A copy of x.",
            "The memory address of x.",
            "The binary name of x."
        ],
        "correct": 2,
        "explanation": "'p' is a pointer to an integer. The assignment 'p = &x' uses the address-of operator to put the memory address of 'x' into 'p'. This allows 'p' to indirectly point to the data stored in 'x'.",
        "topic": "Pointers"
    },
    {
        "question": "What does the 'endl' manipulator do in a C++ output stream?",
        "options": [
            "It prints a horizontal tab and clears the buffer.",
            "It inserts a newline character and flushes the output buffer.",
            "It ends the program execution immediately.",
            "It converts the output into hexadecimal format."
        ],
        "correct": 1,
        "explanation": "'endl' serves two functions: it inserts the '\\n' (newline) character to move the cursor to the next line, and it 'flushes' the buffer, ensuring all pending output is physically written to the screen or file immediately. This is safer but slightly slower than using '\\n' alone.",
        "topic": "Standard I/O"
    },
    {
        "question": "Which of the following is NOT a valid C++ identifier?",
        "options": [
            "_myVar",
            "studentCount",
            "2nd_Result",
            "total_sum"
        ],
        "correct": 2,
        "explanation": "C++ identifier rules state that a name can contain letters, digits, and underscores, but it *must not* start with a digit. '2nd_Result' violates this rule. Identifiers also cannot be C++ reserved keywords like 'int' or 'while'.",
        "topic": "Identifiers"
    },
    {
        "question": "What is the scholarly definition of a 'Logic Error' in programming?",
        "options": [
            "The program fails to compile due to a missing semicolon.",
            "The program runs but produces the wrong output because of a mistake in the algorithm.",
            "The program crashes because the computer ran out of memory.",
            "The program is written in a language the compiler does not understand."
        ],
        "correct": 1,
        "explanation": "A logic error is the most difficult type of bug to find. The code is syntactically perfect (no red squiggles or compiler errors), but the 'thinking' is wrong. For example, if a programmer uses '+' when they should have used '*', the program will run to completion but the results will be incorrect.",
        "topic": "Introduction to Programming"
    },
    {
        "question": "Which of the following describes the 'Dangling Pointer' phenomenon in C++ memory management?",
        "options": [
            "A pointer that is declared but not yet initialized to any memory address.",
            "A pointer that continues to store the address of a memory block after it has been deallocated.",
            "A pointer that is used to access an array index that is out of bounds.",
            "A pointer that is stored in the code segment instead of the data segment."
        ],
        "correct": 1,
        "explanation": "A dangling pointer arises when the memory it points to is freed (using 'delete') or goes out of scope, but the pointer still retains that address. Attempting to dereference such a pointer leads to undefined behavior or system crashes because the memory may have been reassigned. This is a significant logical risk in dynamic memory management.",
        "topic": "Pointers and Memory Management"
    },
    {
        "question": "In C++, what is the primary distinction between a 'struct' and a 'class' regarding member accessibility?",
        "options": [
            "Classes allow functions as members, while structures only allow variables.",
            "Structure members are private by default, while class members are public.",
            "Structure members are public by default, while class members are private.",
            "Classes are stored on the heap, whereas structures are always on the stack."
        ],
        "correct": 2,
        "explanation": "The only technical difference between a 'struct' and a 'class' in C++ is the default access specifier. Members of a 'struct' are public by default to maintain compatibility with C, whereas members of a 'class' are private by default to encourage encapsulation and information hiding.",
        "topic": "Classes and Structures"
    },
    {
        "question": "Which specific C++ manipulator is used to set the number of decimal places displayed for floating-point values in the output stream?",
        "options": [
            "setw()",
            "setfill()",
            "setprecision()",
            "fixed()"
        ],
        "correct": 2,
        "explanation": "'setprecision()' is an I/O manipulator found in the <iomanip> header that controls the number of digits displayed for floating-point numbers. When used with the 'fixed' manipulator, it specifies the exact number of digits to appear after the decimal point.",
        "topic": "Stream Manipulation"
    },
    {
        "question": "What is the scholarly justification for the 'Divide and Conquer' strategy in structured programming?",
        "options": [
            "It allows the CPU to execute multiple functions simultaneously.",
            "It simplifies complexity by breaking a large problem into smaller, independent sub-problems.",
            "It reduces the physical size of the source code files on the disk.",
            "It prevents the use of global variables in the program."
        ],
        "correct": 1,
        "explanation": "Divide and Conquer is a fundamental principle of Stepwise Refinement. By decomposing a complex problem into manageable modules or functions, the programmer makes the logic easier to design, test, and maintain. This modularity is essential for large-scale software engineering.",
        "topic": "Structured Programming"
    },
    {
        "question": "When an array is passed to a function in C++, why is it inherently passed 'by reference'?",
        "options": [
            "Because the compiler creates a full copy of the array for the function.",
            "Because the name of the array is treated as a constant pointer to its first element.",
            "Because C++ does not allow arrays to be passed to functions at all.",
            "Because the 'static' keyword is automatically applied to all array parameters."
        ],
        "correct": 1,
        "explanation": "In C++, passing an array name to a function effectively passes the memory address of the first element (index 0). Consequently, the function operates on the original memory, and any changes made to the array inside the function persist after the function returns. This avoids the overhead of copying large data sets.",
        "topic": "Arrays and Functions"
    },
    {
        "question": "Which keyword is used to release memory that was previously allocated dynamically on the heap using the 'new' operator?",
        "options": [
            "free",
            "remove",
            "delete",
            "clear"
        ],
        "correct": 2,
        "explanation": "In C++, the 'delete' operator is used to deallocate memory on the heap. Using 'new' reserves a block of memory, and failing to use 'delete' once that memory is no longer needed results in a 'Memory Leak'. 'free' is the equivalent function used in the C language.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "In the C++ memory model, where are local variables and function call parameters typically stored?",
        "options": [
            "The Heap",
            "The Stack",
            "The Data Segment",
            "The Code Segment"
        ],
        "correct": 1,
        "explanation": "The Stack is used for automatic memory management. When a function is called, a 'stack frame' is created to store its local variables and parameters. This memory is automatically reclaimed when the function exits. This is contrasted with the Heap, which requires manual management.",
        "topic": "Memory Management"
    },
    {
        "question": "What is the resulting value of 'result' in the following integer division: int result = 17 / 5;?",
        "options": [
            "3.4",
            "3",
            "4",
            "3.0"
        ],
        "correct": 1,
        "explanation": "In C++, dividing two integers results in 'Integer Division'. The fractional or decimal part (0.4) is truncated (discarded), not rounded. Therefore, 17 divided by 5 results in exactly 3. To obtain a decimal result, at least one operand would need to be a float or double.",
        "topic": "Arithmetic Operators"
    },
    {
        "question": "Which logical operator has the lowest precedence in C++ among the options provided?",
        "options": [
            "!",
            "&&",
            "||",
            "=="
        ],
        "correct": 2,
        "explanation": "In C++ operator precedence, the logical OR (||) operator has lower precedence than both logical AND (&&) and equality (==). The logical NOT (!) has the highest precedence among the logical operators. This hierarchy determines the order in which complex Boolean expressions are evaluated.",
        "topic": "Operator Precedence"
    },
    {
        "question": "What is the primary function of a 'Constructor' in a C++ class?",
        "options": [
            "To delete the object and free its memory.",
            "To initialize the data members of an object when it is created.",
            "To allow the class to be used as a global variable.",
            "To translate the class methods into machine language."
        ],
        "correct": 1,
        "explanation": "A constructor is a special member function that is automatically called whenever an instance (object) of a class is created. Its main purpose is to set initial values for the object's data members, ensuring the object starts in a valid state.",
        "topic": "Object Oriented Programming"
    },
    {
        "question": "In a 'for' loop, which part of the statement is evaluated before every iteration of the loop body to determine if the loop should continue?",
        "options": [
            "Initialization",
            "Condition",
            "Increment",
            "Body"
        ],
        "correct": 1,
        "explanation": "The 'Condition' part of the for-loop (the second part) is a Boolean expression. It is checked *before* the body is executed. If it evaluates to false, the loop terminates. The initialization happens only once at the start, and the increment happens after the body.",
        "topic": "Repetition Structures"
    },
    {
        "question": "Which of the following describes a 'Syntax Error'?",
        "options": [
            "The program produces incorrect mathematical results.",
            "The program crashes when trying to divide by zero.",
            "The code violates the grammatical rules of the C++ language.",
            "The program enters an infinite loop."
        ],
        "correct": 2,
        "explanation": "A syntax error occurs when the code does not follow the language rules (e.g., missing a semicolon or a closing brace). These errors are caught by the compiler during the translation process, preventing the creation of an executable file.",
        "topic": "Error Types"
    },
    {
        "question": "Which specific 'ios' mode is used to open a file for both reading and writing simultaneously?",
        "options": [
            "ios::in",
            "ios::out",
            "ios::app",
            "ios::in | ios::out"
        ],
        "correct": 3,
        "explanation": "C++ allows the combination of file modes using the bitwise OR operator (|). By combining 'ios::in' (reading) and 'ios::out' (writing), the file stream can perform both operations on the same file, provided the file exists and permissions allow it.",
        "topic": "File I/O"
    },
    {
        "question": "In C++, the 'default' keyword in a switch statement acts as a/an:",
        "options": [
            "Infinite loop generator.",
            "Catch-all for cases that do not match any specified case constant.",
            "Requirement that must be the first line of the switch block.",
            "Instruction to reset all case variables to zero."
        ],
        "correct": 1,
        "explanation": "The 'default' case in a switch statement is optional. It executes its block of code if none of the 'case' labels match the value of the switch expression. It is logically equivalent to the final 'else' in an if-else-if chain.",
        "topic": "Control Structures"
    },
    {
        "question": "What happens if a programmer uses the 'break' statement inside a nested loop?",
        "options": [
            "The program terminates entirely.",
            "Only the innermost loop containing the break is exited.",
            "All loops (inner and outer) are exited simultaneously.",
            "The program skips to the next iteration of the outer loop."
        ],
        "correct": 1,
        "explanation": "The 'break' statement only affects the 'nearest' enclosing loop. If used inside a nested loop, it terminates the inner loop and returns control to the outer loop. To exit multiple levels of nesting, other logic or 'return' statements would be required.",
        "topic": "Nested Loops"
    },
    {
        "question": "Which C++ header file is required to use string stream processing (treating strings like input/output streams)?",
        "options": [
            "iostream",
            "fstream",
            "sstream",
            "string"
        ],
        "correct": 2,
        "explanation": "The <sstream> header defines the 'stringstream', 'istringstream', and 'ostringstream' classes. These allow a programmer to associate a string with a stream, making it easy to parse data from a string or format data into a string using the '>>' and '<<' operators.",
        "topic": "String Streams"
    },
    {
        "question": "What is the primary technical function of the 'dereference' operator (*) when used with a pointer?",
        "options": [
            "To double the value of the pointer address.",
            "To access the value stored at the memory address the pointer is holding.",
            "To delete the pointer variable from the stack.",
            "To change the data type of the pointer to an integer."
        ],
        "correct": 1,
        "explanation": "Dereferencing a pointer means 'going to the address' stored in the pointer to interact with the actual data at that location. For example, if 'ptr' points to 'x', then '*ptr = 10' will change the value of 'x' to 10.",
        "topic": "Pointers"
    },
    {
        "question": "In C++, which of the following is true about 'Static' variables declared inside a function?",
        "options": [
            "They are destroyed every time the function returns.",
            "They retain their value between different calls to the same function.",
            "They can be accessed from any other function in the file.",
            "They cannot be initialized with a constant value."
        ],
        "correct": 1,
        "explanation": "Static local variables have 'Static Storage Duration'. They are initialized only once, the first time the function is called, and they 'persist' in memory until the program ends. This allows a function to 'remember' information from its previous executions.",
        "topic": "Storage Classes"
    },
    {
        "question": "Which operator is used to determine the remainder of an integer division in C++?",
        "options": [
            "/",
            "&",
            "%",
            "#"
        ],
        "correct": 2,
        "explanation": "The modulo operator (%) calculates the remainder after dividing one integer by another. For example, '10 % 3' returns 1. This operator is only valid for integer data types and is frequently used for finding even/odd numbers or circular indexing.",
        "topic": "Arithmetic Operators"
    },
    {
        "question": "What is the index of the first element in any C++ array?",
        "options": [
            "1",
            "0",
            "-1",
            "Any index defined by the programmer."
        ],
        "correct": 1,
        "explanation": "C++ uses zero-based indexing for arrays. This means the first element is at index 0 and the last element of an array of size 'N' is at index 'N-1'. This is a fundamental rule of the language derived from its relationship with pointers and memory offsets.",
        "topic": "Arrays"
    },
    {
        "question": "Which of the following is NOT a valid C++ identifier?",
        "options": [
            "_count",
            "totalSum",
            "3rd_value",
            "value_2"
        ],
        "correct": 2,
        "explanation": "C++ identifiers (variable names) must not start with a digit. They can start with a letter or an underscore and can contain letters, digits, and underscores thereafter. '3rd_value' is invalid because it begins with '3'.",
        "topic": "Identifiers"
    },
    {
        "question": "The 'main()' function in C++ is required to return a value of which data type?",
        "options": [
            "void",
            "char",
            "int",
            "float"
        ],
        "correct": 2,
        "explanation": "The 'main' function is the entry point of the program. According to C++ standards, it must return an 'int'. This integer is an 'exit code' sent to the operating system; a return value of 0 typically signifies successful completion.",
        "topic": "Function Basics"
    },
    {
        "question": "What is 'Encapsulation' in the context of Object-Oriented Programming?",
        "options": [
            "The ability of a function to call itself.",
            "The process of bundling data and the methods that operate on that data into a single unit.",
            "The automatic translation of source code into machine code.",
            "The practice of dividing a program into multiple source files."
        ],
        "correct": 1,
        "explanation": "Encapsulation is a core OOP concept. It involves grouping data (members) and the logic (functions) that manipulates that data into a single container called a 'class'. It often involves 'Information Hiding' to protect the internal state of an object.",
        "topic": "Object Oriented Programming"
    },
    {
        "question": "Which C++ keyword is used to handle exceptions and errors during runtime?",
        "options": [
            "if",
            "switch",
            "try",
            "while"
        ],
        "correct": 2,
        "explanation": "The 'try' keyword is used to define a block of code in which exceptions might occur. It is accompanied by 'catch' blocks that define how to respond to specific types of errors, allowing for more robust and graceful program recovery.",
        "topic": "Exception Handling"
    },
    {
        "question": "In a C++ string literal, what does the escape sequence '\\t' represent?",
        "options": [
            "A newline",
            "A backspace",
            "A horizontal tab",
            "A carriage return"
        ],
        "correct": 2,
        "explanation": "'\\t' is the escape sequence for a horizontal tab. It moves the cursor to the next tab stop, which is commonly used to align output in columns. '\\n' is used for a newline and '\\b' for a backspace.",
        "topic": "Data Representation"
    },
    {
        "question": "What is the primary role of the 'Linker' in the C++ compilation process?",
        "options": [
            "To check for syntax errors in the source code.",
            "To translate the source code into assembly language.",
            "To combine object files and library files into a single executable file.",
            "To load the program from the hard drive into RAM."
        ],
        "correct": 2,
        "explanation": "The Linker is the final tool used in the build process. It takes one or more object files (output from the compiler) and joins them with pre-compiled library functions (like those for I/O) to create a final '.exe' file.",
        "topic": "Compilation Process"
    },
    {
        "question": "Which of the following is true regarding 'Constants' declared with the 'const' keyword?",
        "options": [
            "Their value can be changed at any time during execution.",
            "They must be initialized at the time of declaration.",
            "They are only accessible within the 'main' function.",
            "They take up more memory than regular variables."
        ],
        "correct": 1,
        "explanation": "A 'const' variable is a read-only variable. Because its value cannot be modified after it is created, C++ requires that it be assigned a value immediately upon declaration. Attempting to change a constant later will result in a compiler error.",
        "topic": "Constants"
    },
    {
        "question": "Which operator is used to access members of a structure or class when using a pointer to that object?",
        "options": [
            ".",
            "->",
            "&",
            "*"
        ],
        "correct": 1,
        "explanation": "The arrow operator (->) is used for member access through a pointer. It is shorthand for dereferencing the pointer and then using the dot operator (e.g., 'ptr->member' is the same as '(*ptr).member').",
        "topic": "Pointers and Structures"
    },
    {
        "question": "What is the binary representation of the decimal number 10?",
        "options": [
            "1001",
            "1010",
            "1100",
            "1111"
        ],
        "correct": 1,
        "explanation": "In binary (base-2), the digits represent powers of 2 (8, 4, 2, 1). For decimal 10, we have one 8 and one 2 (8 + 2 = 10). Thus, the binary value is 1010.",
        "topic": "Number Systems"
    },
    {
        "question": "In C++, which function is used to get the current position of the 'get' pointer in an input file stream?",
        "options": [
            "seekg()",
            "tellg()",
            "seekp()",
            "tellp()"
        ],
        "correct": 1,
        "explanation": "The 'tellg()' function returns the current position (in bytes) of the file pointer in an 'ifstream'. The 'seekg()' function is used to *set* or move that pointer. The 'p' versions (seekp/tellp) are used for output streams ('ofstream').",
        "topic": "File Handling"
    },
    {
        "question": "Which logical control structure is most suitable for a scenario where a program must execute a specific block of code repeatedly as long as a condition remains true, but may not execute it at all if the initial condition is false?",
        "options": [
            "do-while loop",
            "while loop",
            "if-else statement",
            "switch statement"
        ],
        "correct": 1,
        "explanation": "The 'while' loop is a pre-test loop, meaning it evaluates the condition before entering the loop body. If the condition is false at the very beginning, the body is never executed. In contrast, a 'do-while' loop (Option 0) is a post-test loop that always executes at least once. If-else and switch (Options 2 and 3) are selection structures, not repetition structures.",
        "topic": "Control Structures"
    },
    {
        "question": "In C++, what is the primary purpose of using the 'default' label within a switch statement block?",
        "options": [
            "To initialize the switch variable to a system-defined constant.",
            "To provide an execution path when none of the 'case' labels match the expression.",
            "To force the program to jump to the first case regardless of the value.",
            "To terminate the program if an invalid character is entered."
        ],
        "correct": 1,
        "explanation": "The 'default' label acts as a catch-all. If the value of the expression in the switch statement does not match any of the provided 'case' constants, the code following the 'default' label is executed. It is functionally similar to the final 'else' in an if-else-if chain, providing a fallback for unexpected or unhandled inputs.",
        "topic": "Switch Statement"
    },
    {
        "question": "Consider a nested loop where an outer loop runs 'i' times and an inner loop runs 'j' times. What is the total number of iterations performed by the inner loop's body?",
        "options": [
            "i + j",
            "i * j",
            "j ^ i",
            "i / j"
        ],
        "correct": 1,
        "explanation": "In nested loops, for every single iteration of the outer loop, the inner loop completes its full cycle of 'j' iterations. Therefore, the total number of times the innermost code executes is the product of the two limits (i multiplied by j). This multiplicative relationship is why nested loops significantly impact algorithmic complexity.",
        "topic": "Nested Loops"
    },
    {
        "question": "Which of the following is a characteristic of the 'do-while' loop that distinguishes it from the 'for' and 'while' loops?",
        "options": [
            "It can only be used with integer counters.",
            "It is the only loop that requires a semicolon at the end of its syntax.",
            "It evaluates its termination condition before the first iteration.",
            "It is optimized specifically for mathematical summations."
        ],
        "correct": 1,
        "explanation": "Syntactically, the 'do-while' loop is unique because it must end with a semicolon after the while condition: 'do { ... } while (condition);'. While 'for' and 'while' loops are pre-test loops that check the condition first, the 'do-while' is a post-test loop, ensuring the body executes at least once before the condition is even checked.",
        "topic": "Control Structures"
    },
    {
        "question": "What happens if a programmer omits the 'break' statement between two cases in a C++ switch structure?",
        "options": [
            "The compiler generates a syntax error.",
            "The program skips the second case and moves to the default.",
            "The execution 'falls through' into the subsequent case's statements.",
            "The switch statement restarts from the first case."
        ],
        "correct": 2,
        "explanation": "C++ switch logic employs 'fall-through' behavior. If a 'break' is missing, the execution does not stop at the end of the matched case; instead, it continues executing the code for the next case regardless of whether that case's constant matches the expression. This can lead to logical errors if not handled intentionally.",
        "topic": "Switch Statement"
    },
    {
        "question": "Which of the following code snippets correctly implements an infinite loop using a 'for' structure?",
        "options": [
            "for (int i=0; i<10; i--)",
            "for ( ; ; )",
            "for (int i=10; i>0; i++)",
            "All of the given options"
        ],
        "correct": 3,
        "explanation": "All three options result in infinite loops. Option 1 decrements a value away from a positive limit. Option 2 is the standard 'null' for loop which has no condition (defaulting to true). Option 3 increments a value that is already greater than the exit condition. These are common logical errors that cause programs to 'hang' or stop responding.",
        "topic": "Loops"
    },
    {
        "question": "In the context of the CS201 handouts, which selection structure is preferred when testing a single variable against a large set of specific integer constants?",
        "options": [
            "if-else-if chain",
            "Nested if statements",
            "switch statement",
            "while loop"
        ],
        "correct": 2,
        "explanation": "The 'switch' statement is specifically designed for multi-way branching based on the value of a single integral expression. It is generally more readable and can be more efficient than a long if-else-if chain (Option 0) because compilers can often optimize switch statements using jump tables.",
        "topic": "Switch Statement"
    },
    {
        "question": "What is the output of the following code fragment? \nint x = 10; \ndo { x++; } while (x < 10); \ncout << x;",
        "options": [
            "10",
            "11",
            "9",
            "Infinite Loop"
        ],
        "correct": 1,
        "explanation": "Since this is a 'do-while' loop, the body executes first without checking the condition. 'x' is incremented from 10 to 11. Then, the condition (11 < 10) is checked; it evaluates to false, so the loop terminates. The final value printed is 11. A 'while' loop would have checked the condition first and printed 10.",
        "topic": "do-while Loop"
    },
    {
        "question": "Which operator is used within a 'switch' case to define the value to be compared against the switch expression?",
        "options": [
            "==",
            ":",
            "case",
            "->"
        ],
        "correct": 2,
        "explanation": "The 'case' keyword is followed by a constant value and a colon (:) to define a branch in a switch statement. For example: 'case 1:'. The '==' operator (Option 0) is used for comparisons in 'if' statements but is not used within the syntax of a switch case label.",
        "topic": "Switch Statement"
    },
    {
        "question": "In C++, the condition in a 'while' loop must eventually evaluate to ________ to prevent an infinite loop.",
        "options": [
            "true",
            "false",
            "zero",
            "Both false and zero"
        ],
        "correct": 3,
        "explanation": "In C++, Boolean 'false' and the integer '0' are equivalent in logical tests. A loop continues as long as its condition is 'true' (non-zero). To exit the loop, the condition must become 'false' or '0'. If the condition remains non-zero indefinitely, the loop becomes infinite.",
        "topic": "Loops"
    },
    {
        "question": "How many times will the message be printed? \nfor (int i = 1; i <= 5; i++) \n  for (int j = 1; j <= 2; j++) \n    cout << \"VU\";",
        "options": [
            "5",
            "7",
            "10",
            "2"
        ],
        "correct": 2,
        "explanation": "The outer loop runs 5 times (i = 1, 2, 3, 4, 5). For each of those 5 times, the inner loop runs 2 times (j = 1, 2). Total iterations = 5 * 2 = 10. Therefore, the message \"VU\" will be printed exactly 10 times.",
        "topic": "Nested Loops"
    },
    {
        "question": "Which of the following is NOT an integral type allowed as an expression in a C++ switch statement?",
        "options": [
            "int",
            "char",
            "double",
            "enum"
        ],
        "correct": 2,
        "explanation": "The 'switch' expression must result in an 'integer' type. 'int', 'char' (represented by ASCII values), and 'enum' are all integral. 'double' (Option 2) is a floating-point type; because of precision issues in binary representation, C++ does not allow switching on float or double values.",
        "topic": "Switch Statement"
    },
    {
        "question": "The 'continue' statement, when used inside a loop body, causes the program to:",
        "options": [
            "Exit the loop and terminate the program.",
            "Skip the remaining statements in the current iteration and move to the next iteration.",
            "Restart the loop from the initial value.",
            "Pause for a specified amount of time."
        ],
        "correct": 1,
        "explanation": "The 'continue' statement interrupts only the current pass through the loop. It skips any code following it within the loop body and jumps immediately to the loop's update/condition check for the next iteration. This is different from 'break', which exits the loop entirely.",
        "topic": "Control Structures"
    },
    {
        "question": "Which part of a 'for' loop is executed *after* the loop body but *before* the next condition check?",
        "options": [
            "Initialization",
            "Condition",
            "Increment/Decrement",
            "Termination"
        ],
        "correct": 2,
        "explanation": "The order of a for loop is: 1. Initialization (once), 2. Condition check, 3. Body execution, 4. Increment/Decrement, 5. Repeat from step 2. The increment part (e.g., i++) is logically the very last thing that happens in a single iteration before the next cycle begins.",
        "topic": "for Loop"
    },
    {
        "question": "What is the primary risk of using a 'goto' statement in modern C++ programming?",
        "options": [
            "It consumes too much CPU power.",
            "It makes the program flow difficult to follow and debug (spaghetti code).",
            "It is only compatible with 16-bit systems.",
            "It automatically deletes all local variables."
        ],
        "correct": 1,
        "explanation": "While 'goto' is a valid C++ keyword, its use is strongly discouraged in structured programming. It allows jumping to arbitrary points in the code, breaking the logical 'top-down' flow. This results in 'spaghetti code' that is nearly impossible to maintain or audit for errors.",
        "topic": "Structured Programming"
    },
    {
        "question": "In a switch statement, multiple 'case' labels can be grouped together to execute the same block of code. This is achieved by:",
        "options": [
            "Using a comma between values (e.g., case 1, 2:).",
            "Placing case labels sequentially without a 'break' between them.",
            "Using the 'OR' operator (e.g., case 1 || 2:).",
            "Nesting switch statements."
        ],
        "correct": 1,
        "explanation": "To have multiple values trigger the same logic, you list them one after another: 'case 1: case 2: [code] break;'. Because of the 'fall-through' nature of switch statements, if the expression matches case 1, it will execute the code following it, including the code for case 2, until a break is found.",
        "topic": "Switch Statement"
    },
    {
        "question": "Which loop structure is often referred to as a 'Count-Controlled' loop?",
        "options": [
            "while loop",
            "for loop",
            "do-while loop",
            "if-else"
        ],
        "correct": 1,
        "explanation": "The 'for' loop is primarily used when the number of iterations is known in advance (e.g., repeating 100 times). It explicitly includes a counter, a limit, and an update rule. 'while' and 'do-while' are typically 'event-controlled' loops that run until a certain condition changes.",
        "topic": "for Loop"
    },
    {
        "question": "If the condition in a 'while' loop is initially false, how many times will the body of the loop execute?",
        "options": [
            "0",
            "1",
            "Infinite",
            "Until the user presses a key"
        ],
        "correct": 0,
        "explanation": "As a pre-test loop, the 'while' loop checks the condition *before* any code in the body runs. If the condition is false on the first check, the entire loop is bypassed. This is the safest way to ensure code only runs when valid conditions are met.",
        "topic": "while Loop"
    },
    {
        "question": "In a 'switch' statement, the value following the 'case' keyword must be a ________.",
        "options": [
            "Variable",
            "Constant expression",
            "Function call",
            "Logical condition (e.g., x > 5)"
        ],
        "correct": 1,
        "explanation": "The compiler must be able to determine the case values at compile-time to build the branch logic (like a jump table). Therefore, case values must be constants (e.g., '1', ''A'', or a 'const' variable). You cannot use a regular variable or a logical comparison like 'x > 5' as a case label.",
        "topic": "Switch Statement"
    },
    {
        "question": "What is the maximum number of times a 'default' case can appear in a single switch statement?",
        "options": [
            "0",
            "1",
            "As many as there are cases",
            "Unlimited"
        ],
        "correct": 1,
        "explanation": "A switch statement can have at most one 'default' case. Its purpose is to handle any value not caught by the specific 'case' labels. Having more than one would create ambiguity for the compiler, resulting in a syntax error.",
        "topic": "Switch Statement"
    },
    {
        "question": "Which of the following is true about 'break' and 'continue' inside nested loops?",
        "options": [
            "They affect all levels of the nested loops.",
            "They only affect the innermost loop in which they are placed.",
            "They only affect the outermost loop.",
            "They are not allowed inside nested loops."
        ],
        "correct": 1,
        "explanation": "Both 'break' and 'continue' are local to the specific loop block they are in. A 'break' inside an inner loop will terminate that inner loop and return control to the next iteration of the outer loop. It does not 'break' the outer loop.",
        "topic": "Control Structures"
    },
    {
        "question": "What is the purpose of the initialization part in a 'for' loop?",
        "options": [
            "To check if the loop should continue.",
            "To update the loop variable after each pass.",
            "To set the starting value of the loop control variable.",
            "To define the data type of the entire loop."
        ],
        "correct": 2,
        "explanation": "The initialization (e.g., 'int i = 0') happens exactly once, before the first condition check. It establishes the initial state of the loop counter or control variable. It can also be used to declare the variable so that its scope is limited to the loop.",
        "topic": "for Loop"
    },
    {
        "question": "What is the output of: \nfor(int i=0; i<3; i++) { \n  if(i==1) continue; \n  cout << i; \n}",
        "options": [
            "012",
            "02",
            "12",
            "0"
        ],
        "correct": 1,
        "explanation": "When i=0, it prints '0'. When i=1, the 'if' condition is met and 'continue' is executed, skipping the 'cout' and moving to i++. When i=2, it prints '2'. The loop then ends because 3 is not less than 3. Final output: 02.",
        "topic": "continue Statement"
    },
    {
        "question": "Which loop is best used when you want to process a menu and ensure the menu is shown to the user at least once?",
        "options": [
            "while loop",
            "do-while loop",
            "for loop",
            "switch"
        ],
        "correct": 1,
        "explanation": "A 'do-while' loop is ideal for menus because the program needs to display the options (the 'do' part) before checking if the user wants to quit (the 'while' part). This ensures the user sees the menu at least once, even if they choose the 'Exit' option immediately.",
        "topic": "do-while Loop"
    },
    {
        "question": "In a 'switch' statement, if a case matches but has no statements associated with it (and no break), what happens?",
        "options": [
            "The program does nothing and exits the switch.",
            "The program executes the statements of the next case down the list.",
            "The program crashes.",
            "The compiler generates an error."
        ],
        "correct": 1,
        "explanation": "Due to 'fall-through', if a case is empty and lacks a break, the execution simply moves into the next case's block of code. This is why you can stack multiple cases (e.g., 'case 'a': case 'A':') to share a single block of code.",
        "topic": "Switch Statement"
    },
    {
        "question": "Which of the following is equivalent to 'for( ; ; )'?",
        "options": [
            "while(true)",
            "while(false)",
            "do { } while(false)",
            "if(true)"
        ],
        "correct": 0,
        "explanation": "'for( ; ; )' and 'while(true)' both represent infinite loops in C++. In the 'for' version, the absence of a condition is interpreted as a 'true' condition. In the 'while' version, the condition is explicitly 'true'.",
        "topic": "Loops"
    },
    {
        "question": "A 'switch' statement is fundamentally a ________.",
        "options": [
            "Repetition structure",
            "Selection structure",
            "Sequence structure",
            "Data structure"
        ],
        "correct": 1,
        "explanation": "Like 'if' and 'if-else', the 'switch' statement is used to select one path of execution among many based on a condition. Therefore, it is classified as a selection structure. 'while' and 'for' are repetition structures.",
        "topic": "Control Structures"
    },
    {
        "question": "How many semicolons are required in the header of a 'for' loop?",
        "options": [
            "0",
            "1",
            "2",
            "3"
        ],
        "correct": 2,
        "explanation": "A 'for' loop header always contains two semicolons to separate the three parts: 'for (init; condition; update)'. Even if one or more parts are left empty (e.g., 'for( ; ; )'), the two semicolons must remain to define the structure.",
        "topic": "for Loop"
    },
    {
        "question": "Which of the following describes the execution of a 'break' inside a switch that is inside a while loop?",
        "options": [
            "Both the switch and the while loop are terminated.",
            "Only the switch statement is terminated; the while loop continues.",
            "Only the while loop is terminated; the switch continues.",
            "The program terminates entirely."
        ],
        "correct": 1,
        "explanation": "The 'break' keyword only exits the innermost control structure it is in. If a 'break' is inside a 'switch', it exits the 'switch'. It does not 'reach' out to affect the 'while' loop that contains the switch.",
        "topic": "Control Structures"
    },
    {
        "question": "What is the result of 'while(x = 0)' where x is an integer?",
        "options": [
            "The loop runs once.",
            "The loop runs infinitely.",
            "The loop body is never executed.",
            "Syntax error."
        ],
        "correct": 2,
        "explanation": "This is a common logical error. 'x = 0' is an assignment, not a comparison. The result of the assignment 'x = 0' is the value '0'. In a Boolean context, '0' is 'false'. Therefore, the while condition is false from the start, and the loop body never runs.",
        "topic": "while Loop"
    },
    {
        "question": "Which of the following is a fundamental characteristic of 'Arrays' in C++ regarding their memory allocation?",
        "options": [
            "Array elements are stored in random, non-contiguous memory locations.",
            "Array elements are stored in contiguous memory locations under a single name.",
            "Arrays can automatically resize themselves when they become full.",
            "Arrays can store multiple variables of different data types simultaneously."
        ],
        "correct": 1,
        "explanation": "According to the CS201 handouts, an array is a collection of variables of the same data type stored in contiguous (adjacent) memory locations. This contiguous nature allows the computer to calculate the exact address of any element using its index. Arrays are static in size (Option 2) and must contain elements of the same type, unlike structures.",
        "topic": "Arrays"
    },
    {
        "question": "In C++, if an array is declared as 'int age[10];', what is the valid range of indices for this array?",
        "options": [
            "1 to 10",
            "0 to 10",
            "0 to 9",
            "1 to 9"
        ],
        "correct": 2,
        "explanation": "C++ uses zero-based indexing. For an array of size 'n', the indices range from 0 to n-1. Therefore, for an array of 10 elements, the first element is at age[0] and the last is at age[9]. Attempting to access age[10] results in an 'index out of bounds' error, which is a common cause of logic errors and crashes.",
        "topic": "Arrays"
    },
    {
        "question": "What is the primary benefit of using an array to store the marks of 100 students instead of 100 individual variables?",
        "options": [
            "It reduces the amount of RAM required to store the data.",
            "It allows the programmer to use loops for efficient data manipulation.",
            "It prevents the user from entering incorrect data types.",
            "It automatically sorts the marks in descending order."
        ],
        "correct": 1,
        "explanation": "The most significant advantage of arrays is the ability to process large amounts of related data using loops. Instead of writing 100 lines of code to read 100 variables, a programmer can use a single 'for' loop to iterate through an array. This aligns with the 'Divide and Conquer' strategy of keeping code manageable.",
        "topic": "Arrays"
    },
    {
        "question": "When an array 'int marks[5] = {10, 20, 30};' is initialized, what are the values of marks[3] and marks[4]?",
        "options": [
            "They contain unpredictable 'garbage' values.",
            "They are automatically initialized to 0.",
            "The program results in a compilation error.",
            "They are initialized to the last value (30)."
        ],
        "correct": 1,
        "explanation": "In C++, if an array is partially initialized, the remaining elements are automatically set to zero (for numeric types). In this case, marks[0]=10, marks[1]=20, marks[2]=30, while marks[3] and marks[4] become 0. If no initializer list were used at all, the array would contain garbage values.",
        "topic": "Array Initialization"
    },
    {
        "question": "How does the 'Linear Search' algorithm find a specific value in an array?",
        "options": [
            "By jumping to the middle and checking if the value is higher or lower.",
            "By checking every element sequentially from the first to the last.",
            "By only checking the first and last elements.",
            "By converting the array into a binary tree structure."
        ],
        "correct": 1,
        "explanation": "Linear Search (or sequential search) involves a loop that compares the target value with each element of the array one by one, starting from index 0. It stops when a match is found or the end of the array is reached. While simple to implement, it is less efficient than binary search for very large sorted datasets.",
        "topic": "Searching Algorithms"
    },
    {
        "question": "In the context of the CS201 handouts, what is the 'Array Name' technically considered to be?",
        "options": [
            "A constant that stores the total size of the array.",
            "A constant pointer to the first element (index 0) of the array.",
            "A variable that can be reassigned to point to another array.",
            "A function that returns the average of all elements."
        ],
        "correct": 1,
        "explanation": "The name of an array is a constant pointer to the memory address of the first element. For example, if you have 'int arr[5]', the identifier 'arr' is equivalent to '&arr[0]'. Because it is a *constant* pointer, you cannot change the address it holds (e.g., 'arr = &otherVar' is illegal).",
        "topic": "Arrays and Pointers"
    },
    {
        "question": "Which of the following is the correct syntax for declaring an array of 50 integers in C++?",
        "options": [
            "int array(50);",
            "int[50] array;",
            "int array[50];",
            "array int[50];"
        ],
        "correct": 2,
        "explanation": "The standard C++ syntax for array declaration requires the data type, followed by the array name, and the size enclosed in square brackets: 'type name[size];'. The size must be a constant or a literal value known at compile-time for static arrays.",
        "topic": "Arrays"
    },
    {
        "question": "What happens if a program attempts to write data to 'arr[5]' when the array was declared as 'int arr[5];'?",
        "options": [
            "The compiler will issue a syntax error.",
            "The array will automatically grow to accommodate the sixth element.",
            "The program will overwrite adjacent memory, leading to undefined behavior.",
            "The value will be stored in a temporary buffer."
        ],
        "correct": 2,
        "explanation": "This is a classic 'off-by-one' error. An array of size 5 has indices 0, 1, 2, 3, and 4. Accessing index 5 is 'out of bounds'. Since C++ does not perform automatic boundary checking, the program will write to whatever memory address follows the array, which can corrupt other variables or cause a crash.",
        "topic": "Array Boundaries"
    },
    {
        "question": "Why is it often necessary to pass the 'size' of an array as a separate argument to a function in C++?",
        "options": [
            "To tell the function the data type of the array.",
            "Because arrays are passed as pointers and the function doesn't know the array's original size.",
            "To prevent the function from using too much CPU power.",
            "It is an optional practice and not strictly necessary."
        ],
        "correct": 1,
        "explanation": "When an array is passed to a function, it 'decays' into a pointer to its first element. The function only knows the memory address; it has no built-in way to determine how many elements the array contains. Therefore, passing the size as a separate parameter is required to allow the function to iterate safely through the array.",
        "topic": "Functions and Arrays"
    },
    {
        "question": "Which of the following describes a 'Two-Dimensional Array'?",
        "options": [
            "An array where each element is a pointer to another array.",
            "An array represented as a table with rows and columns.",
            "An array that can store both characters and integers.",
            "An array that is stored in two different memory segments."
        ],
        "correct": 1,
        "explanation": "A two-dimensional array is conceptually a grid or table. In C++, it is declared as 'type name[rows,columns];'. In memory, it is still stored as a single contiguous block, but the compiler handles the mapping of the two indices to the appropriate memory offset.",
        "topic": "Multi-dimensional Arrays"
    },
    {
        "question": "In a 2D array declared as 'int matrix[3,4];', how many total integer elements can it store?",
        "options": [
            "7",
            "12",
            "34",
            "10"
        ],
        "correct": 1,
        "explanation": "The total number of elements in a multi-dimensional array is the product of its dimensions. For a 3x4 matrix, it can store 3 * 4 = 12 integers. The indices for rows would be 0-2 and for columns 0-3.",
        "topic": "Multi-dimensional Arrays"
    },
    {
        "question": "Which of the following is the correct way to initialize a 2D array during declaration?",
        "options": [
            "int arr[2,2] = {1, 2, 3, 4};",
            "int arr[2,2] = {{1, 2}, {3, 4}};",
            "int arr[2,2] = (1, 2), (3, 4);",
            "Both Options 0 and 1 are correct."
        ],
        "correct": 3,
        "explanation": "C++ allows both 'flat' initialization and 'nested' initialization. In flat initialization (Option 0), elements are filled row by row. Nested initialization (Option 1) is generally preferred as it is more readable and explicitly shows the row/column structure.",
        "topic": "Array Initialization"
    },
    {
        "question": "What is the result of using 'sizeof(arr)' if 'arr' is an array of 10 integers (assuming 4 bytes per int)?",
        "options": [
            "10",
            "4",
            "40",
            "1"
        ],
        "correct": 2,
        "explanation": "The 'sizeof' operator applied to a statically declared array returns the total size in bytes occupied by the entire array. Since there are 10 integers and each takes 4 bytes, the result is 10 * 4 = 40 bytes.",
        "topic": "Memory and Size"
    },
    {
        "question": "In a multi-dimensional array 'int table[2,3,4];', which dimension is processed first in memory (row-major order)?",
        "options": [
            "The last dimension (4)",
            "The middle dimension (3)",
            "The first dimension (2)",
            "Memory allocation is random."
        ],
        "correct": 2,
        "explanation": "C++ uses 'Row-Major Order'. This means the elements of the first row (or the first index of the highest dimension) are stored together, followed by the second row, and so on. Understanding this is important for optimizing nested loops for cache performance.",
        "topic": "Multi-dimensional Arrays"
    },
    {
        "question": "What is the 'Null Terminator' specifically used for in C++ character arrays?",
        "options": [
            "To mark the beginning of a string.",
            "To indicate that the array contains only numbers.",
            "To signal the end of a character string.",
            "To encrypt the data within the array."
        ],
        "correct": 2,
        "explanation": "In C-style strings (character arrays), the null character '\\0' is used to identify where the string ends. Without this terminator, functions like 'cout' would continue reading memory past the end of the intended string, leading to 'garbage' output.",
        "topic": "C-Style Strings"
    },
    {
        "question": "Which header file is required to use the 'strlen()' and 'strcpy()' functions for character arrays?",
        "options": [
            "iostream",
            "string.h",
            "iomanip",
            "math.h"
        ],
        "correct": 1,
        "explanation": "The standard C-library functions for manipulating character arrays (C-style strings) are defined in <string.h> (or <cstring> in modern C++). The <string> header is for the C++ string class, which is a different object-oriented approach.",
        "topic": "String Manipulation"
    },
    {
        "question": "What is the main difference between 'char name[20];' and 'string name;'?",
        "options": [
            "The char array is faster; the string class is slower.",
            "The char array has a fixed size; the string class can grow dynamically.",
            "The char array can only store one character; the string class stores many.",
            "There is no difference; they are different names for the same thing."
        ],
        "correct": 1,
        "explanation": "A character array is a fixed-size 'primitive' structure. A 'string' is a C++ class that manages its own memory, allowing it to expand as more text is added. Using the string class is generally safer and more convenient in modern C++.",
        "topic": "Strings"
    },
    {
        "question": "How do you access the element in the 2nd row and 3rd column of a 2D array named 'data'?",
        "options": [
            "data[2,3]",
            "data(2,3)",
            "data[1,2]",
            "data[3,2]"
        ],
        "correct": 2,
        "explanation": "Because of zero-based indexing, the 2nd row has index 1 and the 3rd column has index 2. Therefore, the element is accessed via 'data[1,2]'.",
        "topic": "Multi-dimensional Arrays"
    },
    {
        "question": "Which of the following loops is best suited for traversing every element of a 1D array?",
        "options": [
            "A switch statement",
            "An if-else chain",
            "A for loop",
            "A do-while loop"
        ],
        "correct": 2,
        "explanation": "The 'for' loop is the standard choice for array traversal because it allows the programmer to define a counter that corresponds exactly to the array indices (from 0 to size-1) in a concise format.",
        "topic": "Array Traversal"
    },
    {
        "question": "A 'Buffer Overflow' most commonly occurs in C++ when:",
        "options": [
            "A variable is assigned a value of 0.",
            "Data is written past the boundary of an array into adjacent memory.",
            "A program uses more than 50% of the computer's CPU.",
            "A file is opened for reading but is empty."
        ],
        "correct": 1,
        "explanation": "Buffer overflow is a type of out-of-bounds error. If a programmer writes more data to an array than it was designed to hold, the extra data 'spills over' into neighboring memory. This is a significant security vulnerability as it can be used to overwrite return addresses or other critical data.",
        "topic": "Memory Safety"
    },
    {
        "question": "In the declaration 'int *p = &arr[0];', what is the relationship between 'p' and 'arr'?",
        "options": [
            "p is an integer that stores the value of the first element.",
            "p is a pointer that holds the memory address of the first element of arr.",
            "p is a new array that is a copy of arr.",
            "p and arr are completely unrelated."
        ],
        "correct": 1,
        "explanation": "This statement initializes a pointer 'p' with the address of the first element of the array. Since an array name is also a pointer to the first element, 'int *p = arr;' would be functionally identical.",
        "topic": "Pointers and Arrays"
    },
    {
        "question": "Which algorithm is used to reorder elements in an array into a specific sequence (like ascending order)?",
        "options": [
            "Searching",
            "Sorting",
            "Hashing",
            "Indexing"
        ],
        "correct": 1,
        "explanation": "Sorting is the process of arranging data in a logical order. Common algorithms discussed in introductory programming include Bubble Sort, Selection Sort, and Insertion Sort.",
        "topic": "Sorting"
    },
    {
        "question": "What is 'Pointer Arithmetic' in the context of arrays?",
        "options": [
            "Using a calculator to find the size of a pointer.",
            "Adding or subtracting integers to a pointer to move to different array elements.",
            "The process of multiplying two pointers together.",
            "A method for converting pointers into float values."
        ],
        "correct": 1,
        "explanation": "Pointer arithmetic allows you to navigate an array using memory addresses. For example, if 'ptr' points to arr[0], then 'ptr + 1' points to arr[1]. The compiler automatically accounts for the size of the data type when performing these additions.",
        "topic": "Pointers"
    },
    {
        "question": "In a 2D array, which index represents the 'Row' and which represents the 'Column'?",
        "options": [
            "The first index is the row; the second is the column.",
            "The first index is the column; the second is the row.",
            "Both indices are interchangeable.",
            "It depends on the operating system."
        ],
        "correct": 0,
        "explanation": "By C++ convention, the first bracketed index 'arr[i]' refers to the row, and the second 'arr[i,j]' refers to the column within that row.",
        "topic": "Multi-dimensional Arrays"
    },
    {
        "question": "What is the output of 'cout << marks;' if 'marks' is an array of integers?",
        "options": [
            "The first value in the array.",
            "The memory address of the first element of the array.",
            "All the values in the array separated by spaces.",
            "The total number of elements in the array."
        ],
        "correct": 1,
        "explanation": "Because the name of an array acts as a pointer to its first element, printing the name directly (without an index) will display the hexadecimal memory address where the array begins in RAM.",
        "topic": "Arrays"
    },
    {
        "question": "Which of the following is true about 'Static Arrays' in C++?",
        "options": [
            "They are allocated on the Heap.",
            "Their size must be a constant value known at compile-time.",
            "They can be deleted using the 'delete' keyword.",
            "They can only store positive numbers."
        ],
        "correct": 1,
        "explanation": "Static arrays are allocated on the Stack. Because the compiler must know how much space to reserve before the program runs, the size cannot be a variable—it must be a literal or a 'const' variable.",
        "topic": "Arrays"
    },
    {
        "question": "How do you calculate the number of elements in a 1D array 'arr' using 'sizeof'?",
        "options": [
            "sizeof(arr)",
            "sizeof(arr) / sizeof(arr[0])",
            "sizeof(arr[0])",
            "arr.length()"
        ],
        "correct": 1,
        "explanation": "To find the count of elements, you divide the total size of the array (in bytes) by the size of one individual element. For example, 40 bytes / 4 bytes per int = 10 elements.",
        "topic": "Memory Management"
    },
    {
        "question": "In a 2D array 'int arr[3,3]', what is the index of the middle element?",
        "options": [
            "arr[1,1]",
            "arr[2,2]",
            "arr[0,0]",
            "arr[3,3]"
        ],
        "correct": 0,
        "explanation": "For a 3x3 matrix (indices 0, 1, 2), the middle row is 1 and the middle column is 1. Thus, the center is arr[1,1].",
        "topic": "Multi-dimensional Arrays"
    },
    {
        "question": "When an array is passed as a 'const' to a function, what is the effect?",
        "options": [
            "The function cannot read the values in the array.",
            "The function can read the values but cannot modify them.",
            "The function can only access the first element.",
            "The function creates a copy of the array."
        ],
        "correct": 1,
        "explanation": "Passing an array as 'const type arr[]' is a safeguard. It allows the function to use the data without the risk of accidentally changing the original array in the calling function.",
        "topic": "Security and Safety"
    },
    {
        "question": "Which of the following can be used as an index for an array?",
        "options": [
            "A floating-point number (e.g., arr[1.5])",
            "A character (e.g., arr['A'])",
            "A string (e.g., arr[\"index\"])",
            "An integer expression (e.g., arr[i + 2])"
        ],
        "correct": 3,
        "explanation": "Array indices must be integers or expressions that evaluate to an integer. While Option 1 technically works because characters have ASCII integer values, Option 3 is the most standard and versatile way to use variables as indices.",
        "topic": "Array Access"
    },
    {
        "question": "Which of the following describes the fundamental nature of a 'Pointer' variable in the C++ memory model?",
        "options": [
            "A variable that stores a numerical value used for mathematical calculations.",
            "A variable that holds the memory address of another variable.",
            "A constant that defines the maximum size of the system stack.",
            "A function that returns the binary representation of a character."
        ],
        "correct": 1,
        "explanation": "As detailed in the CS201 handouts, a pointer is a unique category of variable that does not store data values directly (like 10 or 'A'). Instead, it stores the memory address (a hexadecimal location in RAM) of another variable. This allows for indirect data manipulation and is the foundation for dynamic memory allocation and complex data structures like linked lists.",
        "topic": "Pointers"
    },
    {
        "question": "Which C++ operator is specifically used to obtain the memory address of a variable?",
        "options": [
            "The dereference operator (*)",
            "The scope resolution operator (::)",
            "The address-of operator (&)",
            "The membership operator (->)"
        ],
        "correct": 2,
        "explanation": "The ampersand (&) is known as the 'address-of' operator. When placed before a variable name (e.g., &x), it retrieves the specific location in memory where that variable is stored. This address can then be assigned to a pointer variable of a matching data type. The asterisk (*) is used for the opposite action: accessing the value at an address.",
        "topic": "Pointer Operators"
    },
    {
        "question": "What is the scholarly significance of the 'Dereferencing' process in C++ programming?",
        "options": [
            "It allows the program to jump to a different function without using a call.",
            "It allows the programmer to access or modify the value stored at the address held by a pointer.",
            "It automatically clears the memory address to prevent data leaks.",
            "It converts a pointer variable into a standard integer variable permanently."
        ],
        "correct": 1,
        "explanation": "Dereferencing is performed using the asterisk (*) operator on an existing pointer (e.g., *ptr). It tells the computer to 'follow the address' stored in the pointer to the actual memory location and interact with the data there. This allows a function to modify a variable declared in a different scope, which is the mechanism behind 'Call by Reference'.",
        "topic": "Pointers"
    },
    {
        "question": "In the declaration 'int *ptr = &count;', what does the asterisk (*) signify to the C++ compiler?",
        "options": [
            "That 'ptr' is being multiplied by the value of 'count'.",
            "That 'ptr' is a pointer variable capable of storing the address of an integer.",
            "That 'count' is a constant that cannot be changed.",
            "That the memory address of 'ptr' is being hidden from the linker."
        ],
        "correct": 1,
        "explanation": "When used in a declaration, the asterisk (*) identifies the variable as a pointer. It specifies that 'ptr' is not an integer itself, but a variable that points to an integer. The assignment part (= &count) immediately initializes this pointer with the address of the variable 'count'.",
        "topic": "Pointer Declaration"
    },
    {
        "question": "What is the resulting output of the following code fragment? \nint x = 5; \nint *p = &x; \n*p = 10; \ncout << x;",
        "options": [
            "5",
            "10",
            "The memory address of x",
            "Compilation Error"
        ],
        "correct": 1,
        "explanation": "Initially, x is 5. The pointer 'p' is set to the address of x. The statement '*p = 10' is a dereferencing assignment; it goes to the address stored in 'p' (which is x's address) and changes the value there to 10. Consequently, the value of x is updated indirectly. This demonstrates how pointers provide an alias to existing data.",
        "topic": "Pointer Manipulation"
    },
    {
        "question": "Which of the following is a critical safety rule when working with pointers in C++?",
        "options": [
            "Pointers must always be declared as 'global' variables.",
            "A pointer should never be dereferenced unless it points to a valid memory address.",
            "Pointers can only point to variables of the 'double' data type.",
            "The address-of operator can only be used inside the 'main' function."
        ],
        "correct": 1,
        "explanation": "Dereferencing an uninitialized or 'null' pointer is a common cause of program crashes (segmentation faults). Pointers store arbitrary memory addresses by default; if you 'follow' an invalid address, you may attempt to access memory reserved by the operating system. It is best practice to initialize pointers to 'NULL' or 'nullptr' if a valid address is not yet available.",
        "topic": "Pointer Safety"
    },
    {
        "question": "When a pointer is incremented (e.g., ptr++), how does the compiler determine the new memory address?",
        "options": [
            "It always adds exactly 1 byte to the current address.",
            "It adds the number of bytes corresponding to the size of the pointer's data type.",
            "It generates a random new address within the stack segment.",
            "It moves the pointer to the address of the next global variable."
        ],
        "correct": 1,
        "explanation": "C++ employs 'Pointer Arithmetic'. If an integer pointer (pointing to a 4-byte int) is incremented, the compiler adds 4 bytes to the address. This ensures the pointer moves to the start of the *next* integer in memory, which is essential for navigating arrays. If it only added 1 byte, the pointer would point to the middle of the current integer, leading to corrupted data.",
        "topic": "Pointer Arithmetic"
    },
    {
        "question": "Consider the declaration: 'int arr[5];'. Which of the following expressions is equivalent to 'arr[2]'?",
        "options": [
            "*(arr + 2)",
            "&arr + 2",
            "*arr + 2",
            "arr + *2"
        ],
        "correct": 0,
        "explanation": "Array indexing is essentially a shorthand for pointer arithmetic. Since the array name 'arr' is a constant pointer to the first element (index 0), 'arr + 2' calculates the address of the third element. Placing the dereference operator (*) outside the parentheses, '*(arr + 2)', accesses the value stored at that calculated address.",
        "topic": "Arrays and Pointers"
    },
    {
        "question": "What is a 'Null Pointer' as discussed in the VU CS201 handouts?",
        "options": [
            "A pointer that points to a variable with a value of zero.",
            "A pointer that is assigned the value 0, indicating it points to 'nothing'.",
            "A pointer that has been deleted from the hard drive.",
            "A pointer that can only be used once before it disappears."
        ],
        "correct": 1,
        "explanation": "A Null Pointer is a pointer that points to memory address 0. By convention, address 0 is never used for valid data. Assigning 0 (or the constant NULL) to a pointer acts as a signal that the pointer is currently 'empty' or 'disconnected'. This allows programmers to check 'if (ptr != NULL)' before attempting to use it, preventing crashes.",
        "topic": "Pointers"
    },
    {
        "question": "Which of the following describes the relationship between a pointer and a 'Constant' in the declaration 'const int *ptr;'?",
        "options": [
            "The pointer address is constant and cannot be moved.",
            "The value stored at the address is constant and cannot be changed through this pointer.",
            "Both the address and the value are permanent.",
            "The pointer can only point to other pointers."
        ],
        "correct": 1,
        "explanation": "In 'const int *ptr', the 'const' applies to the integer, not the pointer. This means you can change which address the pointer holds (ptr++ is allowed), but you cannot use the pointer to modify the value at that address (*ptr = 10 is illegal). This is often used to pass data to functions securely.",
        "topic": "Pointers and Constants"
    },
    {
        "question": "In a 32-bit system, what is the typical size of a 'Pointer' variable regardless of the data type it points to?",
        "options": [
            "1 byte",
            "4 bytes",
            "8 bytes",
            "It depends on the size of the variable being pointed to."
        ],
        "correct": 1,
        "explanation": "A pointer stores a memory address. In a 32-bit architecture, an address is 32 bits (4 bytes) long. Whether a pointer points to a 1-byte 'char' or an 8-byte 'double', the pointer itself only needs enough space to store the address. In 64-bit systems, pointers are 8 bytes.",
        "topic": "Memory and Variables"
    },
    {
        "question": "What happens when a programmer attempts to perform arithmetic (like addition) on two pointers (e.g., ptr1 + ptr2)?",
        "options": [
            "The addresses are added to create a new, larger address.",
            "The values pointed to by the pointers are added together.",
            "The compiler generates a syntax error because adding two addresses is illogical.",
            "The second pointer is automatically converted into an integer."
        ],
        "correct": 2,
        "explanation": "While you can add an integer to a pointer to move it, adding two pointers together is an illegal operation in C++. There is no logical reason to add two memory addresses. However, subtracting one pointer from another (of the same array) is allowed and returns the number of elements between them.",
        "topic": "Pointer Arithmetic"
    },
    {
        "question": "Which of the following is true regarding the name of an array in C++?",
        "options": [
            "It is a variable pointer that can be reassigned to another array.",
            "It is a constant pointer to the first element of the array.",
            "It is a function that calculates the total memory used by the array.",
            "It is a string that represents the array's identifier."
        ],
        "correct": 1,
        "explanation": "The name of an array (e.g., 'marks') is a constant pointer. While it holds the address of the first element just like a pointer variable, you cannot change its value. For example, 'marks = &otherVar' would cause a compilation error because you cannot reassign the starting location of a static array.",
        "topic": "Arrays and Pointers"
    },
    {
        "question": "Which operator is used to access the members of a 'Structure' when using a pointer to that structure?",
        "options": [
            "The dot operator (.)",
            "The arrow operator (->)",
            "The asterisk operator (*)",
            "The ampersand operator (&)"
        ],
        "correct": 1,
        "explanation": "The arrow operator (->) is specifically designed for pointer-to-structure access. If 'ptr' is a pointer to a 'Student' structure, 'ptr->name' is a cleaner shorthand for '(*ptr).name'. It first dereferences the pointer to get the structure and then accesses the specific member.",
        "topic": "Structures and Pointers"
    },
    {
        "question": "What is the primary technical function of the 'void pointer' (void *) in C++?",
        "options": [
            "To point to a memory location that contains no data.",
            "To act as a generic pointer that can hold the address of any data type.",
            "To indicate that a pointer has been deleted from the heap.",
            "To prevent any other pointers from accessing a specific memory segment."
        ],
        "correct": 1,
        "explanation": "A void pointer is a 'typeless' pointer. It can store the address of an int, a float, or a char. However, because the compiler doesn't know the type of data at the address, a void pointer cannot be dereferenced directly. It must be 'cast' back to a specific data type pointer before the data can be accessed.",
        "topic": "Pointers"
    },
    {
        "question": "In the statement 'int **ptr;', what does the double asterisk signify?",
        "options": [
            "A pointer that is twice as fast as a normal pointer.",
            "A pointer that points to another pointer (pointer to a pointer).",
            "A pointer that can only store even-numbered memory addresses.",
            "A pointer that is stored in the code segment."
        ],
        "correct": 1,
        "explanation": "This is a 'multi-level' pointer. 'ptr' stores the address of a second variable, which is itself a pointer holding the address of an actual integer. This is commonly used in creating dynamic 2D arrays (arrays of pointers) and in certain advanced data structures.",
        "topic": "Advanced Pointers"
    },
    {
        "question": "Which of the following is the correct way to initialize a pointer 'p' to point to an integer variable 'n'?",
        "options": [
            "int *p = n;",
            "int *p = &n;",
            "int p = &n;",
            "*p = n;"
        ],
        "correct": 1,
        "explanation": "Option 1 is incorrect because it tries to assign an integer value to an address. Option 2 is correct: it declares 'p' as a pointer to an int and assigns it the address of 'n'. Option 3 tries to store an address in a standard integer variable, and Option 4 tries to dereference a pointer that hasn't been declared or initialized.",
        "topic": "Pointer Initialization"
    },
    {
        "question": "What is the output of 'cout << p;' if 'p' is a pointer holding the address of 'x'?",
        "options": [
            "The value of x",
            "The word 'pointer'",
            "The hexadecimal memory address of x",
            "A syntax error"
        ],
        "correct": 2,
        "explanation": "When you send a pointer variable to 'cout' without dereferencing it, C++ prints the actual value stored in the pointer variable itself, which is the memory address in hexadecimal format (e.g., 0x22ff44). To see the data at that address, you must use '*p'.",
        "topic": "Standard I/O and Pointers"
    },
    {
        "question": "Which of the following describes 'Pointer-to-Pointer' logic in C++?",
        "options": [
            "Two pointers pointing to the same memory location.",
            "A pointer that stores the address of another pointer variable.",
            "Adding the values of two pointers together.",
            "A pointer that has been copied to another pointer."
        ],
        "correct": 1,
        "explanation": "A pointer-to-pointer (declared as type **name) is a variable that holds the memory location of another pointer. By dereferencing it once, you get the address of the data; dereferencing it twice gives you the data itself. This level of indirection is useful for dynamic memory management.",
        "topic": "Advanced Pointers"
    },
    {
        "question": "What is the memory address of the first byte of a 4-byte integer variable known as?",
        "options": [
            "The base address",
            "The offset address",
            "The logical address",
            "The relative address"
        ],
        "correct": 0,
        "explanation": "Even if a variable occupies multiple bytes, it is represented by a single memory address: the address of its first byte. This is known as the 'base address'. When a pointer stores an address, it is always storing the base address of the variable.",
        "topic": "Memory and Variables"
    },
    {
        "question": "What happens to the pointer 'p' in the following code? \nint *p = new int; \ndelete p;",
        "options": [
            "The pointer 'p' is removed from the stack.",
            "The memory on the heap pointed to by 'p' is freed, but 'p' still holds the address.",
            "The pointer 'p' is automatically set to NULL.",
            "The entire program terminates."
        ],
        "correct": 1,
        "explanation": "The 'delete' operator frees the memory on the 'Heap'. However, the pointer 'p' (which exists on the 'Stack') still contains the now-invalid address. This makes 'p' a 'Dangling Pointer'. It is vital to set 'p = NULL;' after deleting to prevent accidental use of that stale address.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "Which operator is used to access the value of a variable indirectly through its pointer?",
        "options": [
            "&",
            "*",
            "->",
            "sizeof"
        ],
        "correct": 1,
        "explanation": "The asterisk (*) when used on an existing pointer is the 'Dereference' operator. It allows the program to read or write the data stored at the address contained in the pointer. Without the asterisk, you are only interacting with the address itself.",
        "topic": "Pointer Operators"
    },
    {
        "question": "In C++, 'Pointer Arithmetic' is most useful for which of the following tasks?",
        "options": [
            "Calculating the square root of a number.",
            "Iterating through the elements of an array.",
            "Converting characters to uppercase.",
            "Changing the value of a constant."
        ],
        "correct": 1,
        "explanation": "Because array elements are stored in contiguous memory, incrementing a pointer allows you to move from one element to the next efficiently. This is often faster than standard array indexing and is a common practice in low-level string and buffer processing.",
        "topic": "Pointer Arithmetic"
    },
    {
        "question": "What is the result of 'sizeof(ptr)' if 'ptr' is a pointer to an array of 100 integers in a 32-bit system?",
        "options": [
            "4 bytes",
            "400 bytes",
            "800 bytes",
            "100 bytes"
        ],
        "correct": 0,
        "explanation": "A pointer only stores a single address. No matter how large the object it points to (even an array of 100 integers), the size of the pointer itself remains 4 bytes on a 32-bit system. To get 400 bytes, you would need to use 'sizeof' on the actual array variable, not a pointer to it.",
        "topic": "Pointers and Memory"
    },
    {
        "question": "Which of the following is the correct syntax to declare a pointer to a constant integer?",
        "options": [
            "int const *p;",
            "const int *p;",
            "int *const p;",
            "Both Options 0 and 1 are correct."
        ],
        "correct": 3,
        "explanation": "In C++, 'const int *p' and 'int const *p' are identical. They both declare a pointer to an integer that cannot be modified through the pointer. Option 2 ('int *const p') is a 'constant pointer', meaning the address cannot change, but the value at the address can.",
        "topic": "Pointers and Constants"
    },
    {
        "question": "In the context of pointers, what is 'Indirection'?",
        "options": [
            "Using a 'goto' statement to jump to a label.",
            "The ability to access a variable's value through its memory address.",
            "Hiding the source code of a function from the compiler.",
            "Passing a variable by value to a function."
        ],
        "correct": 1,
        "explanation": "Indirection (or referencing) is the core power of pointers. Instead of using a variable's name (direct access), you use its address (indirect access). This allows for dynamic memory, data sharing between functions, and complex data structures.",
        "topic": "Pointers"
    },
    {
        "question": "Which of the following is true about 'Array-Pointer' duality in C++?",
        "options": [
            "Arrays and pointers are exactly the same in every way.",
            "An array name can be used as a pointer, but a pointer cannot be used as an array.",
            "An array name acts as a constant pointer to its first element.",
            "Pointers are stored on the hard drive, while arrays are in RAM."
        ],
        "correct": 2,
        "explanation": "While they are related, arrays and pointers are distinct. An array reserves a specific block of memory; a pointer only reserves space for an address. However, for most operations (like indexing), the compiler treats the array name as the base address, allowing for the 'duality' in syntax.",
        "topic": "Arrays and Pointers"
    },
    {
        "question": "What is the output of the following code? \nint x = 10; \nint *p = &x; \ncout << *p + 1;",
        "options": [
            "10",
            "11",
            "The address of x plus one",
            "Compilation Error"
        ],
        "correct": 1,
        "explanation": "The dereference operator (*) has higher precedence than addition (+). First, '*p' is evaluated to get the value of x (10). Then, 1 is added to that value, resulting in 11. If the code was '*(p + 1)', it would attempt to access the next memory location after x.",
        "topic": "Pointer Arithmetic"
    },
    {
        "question": "Which pointer type should be used when you want a function to accept the address of any data type without a specific cast at the call site?",
        "options": [
            "int *",
            "void *",
            "char *",
            "float *"
        ],
        "correct": 1,
        "explanation": "The 'void pointer' is the universal pointer in C++. It can be assigned any address. This is frequently used in system-level functions (like 'malloc' or memory copy functions) that need to handle raw memory blocks regardless of what data they contain.",
        "topic": "Pointers"
    },
    {
        "question": "When a pointer 'p' points to the first element of an array, what does '*(p + 3)' access?",
        "options": [
            "The value of the first element plus 3.",
            "The value of the third element (index 2).",
            "The value of the fourth element (index 3).",
            "The memory address of the fourth element."
        ],
        "correct": 2,
        "explanation": "Following zero-based logic: p points to index 0. p+1 points to index 1, p+2 points to index 2, and p+3 points to index 3. Dereferencing that address with '*' gives you the actual value stored in the fourth element of the array.",
        "topic": "Arrays and Pointers"
    },
    {
        "question": "Which of the following describes the difference between a 'Constant Pointer' and a 'Pointer to a Constant' in C++ syntax?",
        "options": [
            "A constant pointer cannot change its address; a pointer to a constant cannot change the value at the address.",
            "A constant pointer cannot change its value; a pointer to a constant cannot change its address.",
            "They are two different names for the exact same pointer behavior.",
            "Constant pointers are stored on the heap, while pointers to constants are stored on the stack."
        ],
        "correct": 0,
        "explanation": "In C++, 'int * const ptr' is a constant pointer; the address stored in 'ptr' is fixed. 'const int * ptr' is a pointer to a constant; the address can change (ptr++), but the data at that address is read-only. This distinction is vital for memory safety and ensuring that certain data remains immutable while others remain localized.",
        "topic": "Pointers and Constants"
    },
    {
        "question": "What is the primary technical function of the 'cin.get()' function compared to the standard 'cin >>' operator?",
        "options": [
            "cin.get() can only read numerical values, while cin >> reads text.",
            "cin.get() reads a single character including whitespace, while cin >> skips whitespace characters.",
            "cin.get() automatically converts characters to their uppercase equivalents.",
            "cin.get() is used to read data directly from the hard drive instead of the keyboard."
        ],
        "correct": 1,
        "explanation": "The standard stream extraction operator (>>) skips 'white space' characters (spaces, tabs, newlines). In contrast, 'cin.get()' reads the very next character in the input buffer regardless of what it is. This is essential for processing text where spaces or tab-delimited formatting are significant.",
        "topic": "Character I/O"
    },
    {
        "question": "In the context of 'C-style strings', why must the array size be at least one character longer than the actual text being stored?",
        "options": [
            "To provide space for a hidden checksum used by the linker.",
            "To accommodate the mandatory Null Terminator (\\0) at the end of the string.",
            "To allow the string to be encrypted by the compiler.",
            "Because C++ arrays always start at index 1 for string data."
        ],
        "correct": 1,
        "explanation": "C-style strings are arrays of characters. To identify where the string ends in memory, C++ uses the Null Terminator ('\\0'). If you want to store the word 'HELLO' (5 characters), you need an array of at least 6 characters. Without the terminator, string functions will continue reading adjacent memory until they crash or find a zero byte.",
        "topic": "Strings"
    },
    {
        "question": "Which of the following is the correct way to initialize a character array with a string literal in C++?",
        "options": [
            "char str[] = {'H', 'e', 'l', 'l', 'o'};",
            "char str[] = \"Hello\";",
            "char str[5] = \"Hello\";",
            "Both Options 0 and 1 are correct."
        ],
        "correct": 1,
        "explanation": "Option 0 creates an array of characters but does NOT include the null terminator, so it is not a valid C-string. Option 1 automatically appends the '\\0' and determines the size (6). Option 2 is a syntax error because \"Hello\" requires 6 bytes (5 for letters + 1 for null), but only 5 were allocated.",
        "topic": "String Initialization"
    },
    {
        "question": "What happens when you pass a 'Pointer to a Pointer' (e.g., int **ptr) as an argument to a function?",
        "options": [
            "The function receives a copy of the actual integer value.",
            "The function can modify the address stored in the original pointer.",
            "The function is automatically executed twice for redundancy.",
            "It causes a stack overflow because pointers cannot be nested."
        ],
        "correct": 1,
        "explanation": "Using a pointer-to-pointer (double indirection) allows a function to change where a pointer in the calling function is pointing. This is commonly used in dynamic memory management, such as reallocating arrays or managing linked data structures where the 'head' pointer itself might need to move.",
        "topic": "Advanced Pointers"
    },
    {
        "question": "Which C++ standard library function is used to copy the contents of one C-style string to another?",
        "options": [
            "strcopy()",
            "strcpy()",
            "str_assign()",
            "memcpy()"
        ],
        "correct": 1,
        "explanation": "The 'strcpy(destination, source)' function, found in the <cstring> or <string.h> header, copies the source string (including the null terminator) into the destination array. Programmers must ensure the destination is large enough to avoid a buffer overflow.",
        "topic": "String Manipulation"
    },
    {
        "question": "What is the resulting value of the expression 'strlen(\"CS201\")'?",
        "options": [
            "5",
            "6",
            "0",
            "Undefined"
        ],
        "correct": 0,
        "explanation": "The 'strlen()' function returns the number of characters in a string *excluding* the null terminator. For \"CS201\", there are 5 characters. While the array size required to store this string is 6, the 'length' of the string itself is 5.",
        "topic": "String Manipulation"
    },
    {
        "question": "In C++, 'Pointer Arithmetic' on a 'char' pointer (char *p) increments the address by how many bytes?",
        "options": [
            "1 byte",
            "2 bytes",
            "4 bytes",
            "8 bytes"
        ],
        "correct": 0,
        "explanation": "Pointer arithmetic is based on the size of the underlying data type. Since a 'char' is 1 byte, incrementing a character pointer (p++) adds exactly 1 to the memory address, moving the pointer to the very next character in the array.",
        "topic": "Pointer Arithmetic"
    },
    {
        "question": "Which operator is used to determine if two C-style strings are identical in content?",
        "options": [
            "==",
            "strcmp()",
            "=",
            "equals()"
        ],
        "correct": 1,
        "explanation": "In C++, using '==' on two C-style strings compares their *memory addresses*, not their content. To compare the actual text, you must use 'strcmp(s1, s2)'. It returns 0 if the strings are identical, a positive value if s1 > s2, and a negative value if s1 < s2.",
        "topic": "String Comparison"
    },
    {
        "question": "What is a 'Dangling Pointer' as described in the VU CS201 handouts?",
        "options": [
            "A pointer that is not pointing to any variable yet.",
            "A pointer that points to a memory location that has been deallocated (freed).",
            "A pointer that points to the beginning of a class.",
            "A pointer that has been declared as 'static'."
        ],
        "correct": 1,
        "explanation": "A dangling pointer occurs when you delete a block of memory on the heap but do not reset the pointer to NULL. The pointer still 'remembers' the address, but that memory is no longer valid. Using it can cause unpredictable crashes or data corruption.",
        "topic": "Memory Management"
    },
    {
        "question": "Which character represents the 'Newline' escape sequence in C++?",
        "options": [
            "\\t",
            "\\r",
            "\\n",
            "\\0"
        ],
        "correct": 2,
        "explanation": "'\\n' is the newline character. '\\t' (Option 0) is for a tab, '\\r' (Option 1) is a carriage return, and '\\0' (Option 3) is the null terminator used to end strings.",
        "topic": "Escape Sequences"
    },
    {
        "question": "What is the correct syntax for declaring a pointer to a function that returns an int and takes an int as an argument?",
        "options": [
            "int *func(int);",
            "int (*funcPtr)(int);",
            "int funcPtr*(int);",
            "(*int)funcPtr(int);"
        ],
        "correct": 1,
        "explanation": "Function pointers require parentheses around the pointer name and the asterisk to distinguish them from a function that returns a pointer. 'int (*funcPtr)(int)' is a pointer to a function, whereas 'int *func(int)' is a function declaration that returns an 'int*'.",
        "topic": "Function Pointers"
    },
    {
        "question": "How do you access the first character of a string pointed to by 'char *ptr'?",
        "options": [
            "ptr[0]",
            "*ptr",
            "Both Options 0 and 1 are correct.",
            "ptr->char"
        ],
        "correct": 2,
        "explanation": "In C++, array indexing and pointer dereferencing are interchangeable. 'ptr[0]' and '*ptr' both refer to the data at the very first address the pointer is holding. This is known as 'Array-Pointer Duality'.",
        "topic": "Pointers and Arrays"
    },
    {
        "question": "Which of the following is true about 'Static' memory allocation for arrays?",
        "options": [
            "The size of the array is determined at runtime based on user input.",
            "The size of the array must be a constant known at compile-time.",
            "Static arrays are automatically moved to the heap to save stack space.",
            "Static arrays can be resized using the 'realloc' function."
        ],
        "correct": 1,
        "explanation": "Static arrays are allocated on the stack at the start of the program or function. Because the compiler must set aside this memory before the program runs, the size must be a fixed constant (e.g., 'int arr[100]'). Dynamic arrays (using 'new') allow for runtime sizing.",
        "topic": "Memory Management"
    },
    {
        "question": "What is the purpose of the 'cin.getline()' function?",
        "options": [
            "To read a single word from the keyboard.",
            "To read an entire line of text, including spaces, until a newline is reached.",
            "To read only the numeric digits from a string.",
            "To clear the entire input buffer of any existing characters."
        ],
        "correct": 1,
        "explanation": "'cin.getline(array, size)' is used to read a full string of text that may contain spaces. It stops reading when it reaches the specified size or the newline character. This is superior to 'cin >>' for reading names or addresses.",
        "topic": "String I/O"
    },
    {
        "question": "In C++, if you have 'char *p = \"VU\";', what does '*(p+1)' represent?",
        "options": [
            "The character 'V'",
            "The character 'U'",
            "The memory address of 'U'",
            "A syntax error"
        ],
        "correct": 1,
        "explanation": "'p' points to the 'V' (index 0). Adding 1 to the pointer moves it to the next memory address, which contains the 'U' (index 1). The asterisk (*) then dereferences that address to give the actual character 'U'.",
        "topic": "Pointer Arithmetic"
    },
    {
        "question": "Which of the following describes an 'Array of Pointers'?",
        "options": [
            "A single pointer that points to a large array of integers.",
            "A collection of variables where each element is itself a pointer to another location.",
            "An array that can only store hexadecimal values.",
            "A pointer that is stored inside a constant integer."
        ],
        "correct": 1,
        "explanation": "An array of pointers is declared as 'type *name[size]'. Each element in the array is a pointer variable. This is frequently used to create an array of strings, where each pointer in the array points to the start of a different character sequence in memory.",
        "topic": "Advanced Arrays"
    },
    {
        "question": "What is the effect of the 'delete[]' operator in C++?",
        "options": [
            "It deletes a single variable from the heap.",
            "It deallocates the memory for an entire dynamically allocated array.",
            "It deletes the source code of the program after execution.",
            "It resets all array elements to zero."
        ],
        "correct": 1,
        "explanation": "When you allocate an array using 'new type[size]', you MUST use 'delete[]' (with brackets) to free it. This tells the compiler to call the destructors for all elements in the array and free the entire block of memory on the heap.",
        "topic": "Dynamic Memory"
    },
    {
        "question": "Which header file is required to use character classification functions like 'isdigit()' or 'isalpha()'?",
        "options": [
            "iostream",
            "string.h",
            "cctype",
            "stdlib.h"
        ],
        "correct": 2,
        "explanation": "The <cctype> (or <ctype.h>) header contains functions used to test or manipulate individual characters, such as checking if a character is a letter, a digit, or converting it to uppercase.",
        "topic": "Character Handling"
    },
    {
        "question": "In the C++ memory model, what is 'Free Store' another name for?",
        "options": [
            "The Stack",
            "The Heap",
            "The Code Segment",
            "The Registers"
        ],
        "correct": 1,
        "explanation": "The 'Free Store' and 'Heap' are synonymous in C++. Both refer to the pool of memory available for dynamic allocation during program execution using the 'new' operator.",
        "topic": "Memory Management"
    },
    {
        "question": "What happens if you use 'strcpy' and the destination array is smaller than the source string?",
        "options": [
            "The extra characters are automatically discarded.",
            "A 'Buffer Overflow' occurs, which can crash the program or corrupt data.",
            "The compiler will fix the array size during the build process.",
            "The computer will double the RAM capacity temporarily."
        ],
        "correct": 1,
        "explanation": "'strcpy' does not perform boundary checks. If the source is too large, it will overwrite the memory following the destination array. This is a common security vulnerability and a frequent cause of 'segmentation fault' errors.",
        "topic": "Security and Strings"
    },
    {
        "question": "What is the resulting output of 'cout << (int)'A';'?",
        "options": [
            "A",
            "65",
            "97",
            "1"
        ],
        "correct": 1,
        "explanation": "Casting a character to an 'int' reveals its ASCII (American Standard Code for Information Interchange) value. The ASCII value for the uppercase 'A' is 65. Lowercase 'a' is 97.",
        "topic": "Data Types"
    },
    {
        "question": "Which of the following is an 'Arithmetic Operator' that can be used on pointers?",
        "options": [
            "Multiplication (*)",
            "Addition (+)",
            "Division (/)",
            "Modulo (%)"
        ],
        "correct": 1,
        "explanation": "Pointers support limited arithmetic: addition and subtraction. Adding an integer to a pointer moves it forward in memory. Multiplying or dividing a memory address is logically meaningless and is prohibited by the C++ compiler.",
        "topic": "Pointer Arithmetic"
    },
    {
        "question": "In a 2D array 'int arr[3,4]', what does the expression 'arr[1]' represent?",
        "options": [
            "The element at the second row and first column.",
            "A pointer to the beginning of the second row.",
            "The sum of all elements in the first row.",
            "A syntax error."
        ],
        "correct": 1,
        "explanation": "In C++, a 2D array is essentially an array of arrays. 'arr[1]' accesses the second element of the outer array, which is the entire second row. Thus, 'arr[1]' acts as a pointer to that row.",
        "topic": "Multi-dimensional Arrays"
    },
    {
        "question": "What is the significance of 'nullptr' in modern C++ (C++11 and later)?",
        "options": [
            "It is a pointer that points to a file on the disk.",
            "It is a type-safe replacement for the old NULL macro.",
            "It is a pointer that is stored in the CPU registers.",
            "It is a keyword that deletes a pointer automatically."
        ],
        "correct": 1,
        "explanation": "While 0 or NULL were traditionally used, 'nullptr' is specifically a pointer literal. It prevents ambiguity in function overloading where 0 might be interpreted as an integer instead of a pointer.",
        "topic": "Modern C++"
    },
    {
        "question": "How do you find the number of elements in a dynamically allocated array 'int *arr = new int[n];' using 'sizeof'?",
        "options": [
            "sizeof(arr) / sizeof(int)",
            "n",
            "sizeof(*arr)",
            "It is not possible to use 'sizeof' to find the size of a dynamic array."
        ],
        "correct": 3,
        "explanation": "When an array is on the heap, 'sizeof(arr)' only returns the size of the pointer (usually 4 or 8 bytes), NOT the size of the block it points to. The programmer must keep track of 'n' manually.",
        "topic": "Dynamic Memory"
    },
    {
        "question": "Which function is used to append one string to the end of another?",
        "options": [
            "stradd()",
            "strcat()",
            "strappend()",
            "strjoin()"
        ],
        "correct": 1,
        "explanation": "'strcat(destination, source)' concatenates strings. It finds the null terminator of the destination and starts copying the source from that point. The destination must be large enough to hold the combined result.",
        "topic": "String Manipulation"
    },
    {
        "question": "What does the 'const' keyword in 'int * const p' signify?",
        "options": [
            "The integer is constant.",
            "The pointer address is constant.",
            "The program is constant.",
            "The variable is static."
        ],
        "correct": 1,
        "explanation": "When 'const' appears after the asterisk (*), it modifies the pointer itself. 'p' is a constant pointer; you cannot say 'p++' or point it elsewhere, but you can change the value it points to (*p = 20).",
        "topic": "Pointers and Constants"
    },
    {
        "question": "Which of the following describes 'Double Indirection'?",
        "options": [
            "Using two different pointers to point to the same variable.",
            "Using a pointer that stores the address of another pointer.",
            "Assigning a value to a pointer twice.",
            "Multiplying an address by two."
        ],
        "correct": 1,
        "explanation": "Double indirection (pointer-to-pointer) means you have to 'dereference' twice to get to the actual data. This is useful for passing pointers to functions by reference so the function can modify the caller's pointer.",
        "topic": "Advanced Pointers"
    },
    {
        "question": "What is the output of 'cout << (char)('a' - 32);'?",
        "options": [
            "A",
            "a",
            "65",
            "Syntax Error"
        ],
        "correct": 0,
        "explanation": "The ASCII difference between lowercase and uppercase letters is 32. Subtracting 32 from 'a' (97) gives 65, which is the ASCII value for 'A'. Casting it back to 'char' displays the character 'A'.",
        "topic": "Character Handling"
    },
    {
        "question": "Which operator is used to allocate memory dynamically on the 'Heap' during the execution of a C++ program?",
        "options": [
            "malloc",
            "alloc",
            "new",
            "create"
        ],
        "correct": 2,
        "explanation": "In C++, the 'new' operator is used for dynamic memory allocation. Unlike static allocation on the stack, 'new' requests a block of memory from the 'Heap' (Free Store) at runtime. This allows the program to determine the size of arrays or objects based on user input during execution rather than being fixed at compile-time.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "What is the primary technical difference between 'Stack' memory and 'Heap' memory?",
        "options": [
            "Stack is managed manually by the programmer, while Heap is automatic.",
            "Stack is used for global variables, while Heap is for local variables.",
            "Stack memory is automatically allocated and deallocated, while Heap requires manual management.",
            "Stack is much larger in size compared to the virtually unlimited Heap."
        ],
        "correct": 2,
        "explanation": "The Stack is handled by the compiler; it automatically allocates memory for local variables when a function starts and deallocates it when the function ends. The Heap, however, provides persistent memory that stays allocated until the programmer explicitly releases it using the 'delete' operator. This manual control is powerful but requires discipline to avoid memory leaks.",
        "topic": "Memory Management"
    },
    {
        "question": "A 'Memory Leak' occurs in C++ when:",
        "options": [
            "The program tries to access a private member of a class.",
            "A programmer allocates memory on the heap but fails to deallocate it using 'delete'.",
            "The hard drive runs out of space while saving a file.",
            "Too many local variables are declared inside a single function."
        ],
        "correct": 1,
        "explanation": "Memory leaks happen when memory is requested from the heap using 'new' but is never returned using 'delete'. Over time, these 'orphaned' memory blocks accumulate, causing the program (and potentially the entire system) to run out of RAM and eventually crash. This is a critical logical error in long-running applications.",
        "topic": "Memory Management"
    },
    {
        "question": "Which of the following is the correct syntax to dynamically allocate an array of 10 integers?",
        "options": [
            "int arr = new int(10);",
            "int *arr = new int[10];",
            "int *arr = malloc(10 * sizeof(int));",
            "int arr[10] = new int;"
        ],
        "correct": 1,
        "explanation": "To allocate an array on the heap, you must use the 'new' operator with square brackets: 'new int[10]'. Since this operation returns the memory address of the first element, it must be stored in a pointer variable ('int *arr'). Option 2 is the C-style equivalent but is not the standard C++ approach.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "What is the specific purpose of the 'delete' operator in C++?",
        "options": [
            "To remove a variable's name from the source code.",
            "To deallocate a single block of memory previously allocated with 'new'.",
            "To clear the entire contents of the RAM.",
            "To reset a pointer's address to zero without freeing memory."
        ],
        "correct": 1,
        "explanation": "The 'delete' operator is the counterpart to 'new'. Its role is to inform the operating system that the memory block at a specific address (previously requested from the heap) is no longer needed. This makes that memory available for other parts of the program or other applications.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "When deallocating a dynamically created array (e.g., int *p = new int[5]), which syntax must be used?",
        "options": [
            "delete p;",
            "delete[] p;",
            "free(p);",
            "p.delete();"
        ],
        "correct": 1,
        "explanation": "In C++, there is a strict rule: if you use 'new' (single object), use 'delete'. If you use 'new[]' (array), you must use 'delete[]'. The brackets tell the compiler to look up the size of the array and properly call destructors for all elements in that block. Using the wrong version leads to undefined behavior.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "What is 'Undangling' or 'Resetting' a pointer after deletion, and why is it practiced?",
        "options": [
            "Setting the pointer to NULL after calling delete to prevent accidental reuse of a stale address.",
            "Deleting the pointer twice to ensure the memory is extra clean.",
            "Moving the pointer to the next memory address to find more data.",
            "Renaming the pointer variable to avoid conflicts with the linker."
        ],
        "correct": 0,
        "explanation": "After 'delete p;', the memory is freed, but 'p' still contains the old address (a dangling pointer). By immediately setting 'p = NULL;', the programmer ensures that any future accidental attempts to use 'p' can be caught (e.g., if (p != NULL)). Deleting a NULL pointer is safe, but dereferencing a dangling pointer causes crashes.",
        "topic": "Pointer Safety"
    },
    {
        "question": "In the C++ memory layout, where are 'Global Variables' typically stored?",
        "options": [
            "Stack",
            "Heap",
            "Data Segment (or Static Segment)",
            "Code Segment"
        ],
        "correct": 2,
        "explanation": "Global and static variables are stored in a dedicated 'Data Segment'. Unlike stack variables (which are temporary) or heap variables (which are manual), these variables exist for the entire duration of the program's execution, from start to finish.",
        "topic": "Memory Layout"
    },
    {
        "question": "Which segment of memory contains the actual compiled binary instructions (machine code) of the program?",
        "options": [
            "Stack",
            "Heap",
            "Data Segment",
            "Code Segment (or Text Segment)"
        ],
        "correct": 3,
        "explanation": "The 'Code Segment' is a read-only area of memory where the CPU reads the instructions to be executed. Separating code from data prevents a program from accidentally overwriting its own logic during execution.",
        "topic": "Memory Layout"
    },
    {
        "question": "What is the scholarly definition of 'Persistent Storage' in the context of C++ variables?",
        "options": [
            "Variables that are saved to the hard drive automatically.",
            "Variables allocated on the heap that exist until explicitly deleted.",
            "Variables that cannot be changed once initialized.",
            "Variables that are accessible from any function in the program."
        ],
        "correct": 1,
        "explanation": "Persistence refers to the 'lifetime' of a variable. Heap variables are persistent because their existence is not tied to the scope of a function. They stay alive as long as the programmer wants them to, providing flexibility for complex data structures like linked lists or trees.",
        "topic": "Memory Management"
    },
    {
        "question": "Which of the following describes the 'Free Store'?",
        "options": [
            "A website where you can download C++ compilers for free.",
            "Another name for the Heap segment used for dynamic allocation.",
            "The unused portion of the system stack.",
            "A library of pre-written C++ code used for file I/O."
        ],
        "correct": 1,
        "explanation": "The term 'Free Store' is frequently used in C++ literature and the CS201 handouts as a synonym for the 'Heap'. It represents the pool of memory available to the 'new' operator.",
        "topic": "Memory Management"
    },
    {
        "question": "What happens if a programmer attempts to allocate a very large amount of memory on the Stack (e.g., int hugeArr[1000000])?",
        "options": [
            "The program will run perfectly as the Stack is unlimited.",
            "The compiler will move the array to the heap automatically.",
            "The program will likely result in a 'Stack Overflow' and crash.",
            "The array will be truncated to fit the available space."
        ],
        "correct": 2,
        "explanation": "The Stack is relatively small compared to the Heap. Attempting to declare massive local arrays can exhaust the stack space, leading to a 'Stack Overflow' error. For large datasets, dynamic allocation on the Heap is the professional standard.",
        "topic": "Memory Management"
    },
    {
        "question": "In the statement 'int *p = new int(25);', what is the value stored in the newly allocated memory?",
        "options": [
            "Unpredictable garbage",
            "0",
            "25",
            "The memory address of p"
        ],
        "correct": 2,
        "explanation": "Using parentheses with 'new' (e.g., new int(25)) allocates space for a single integer AND initializes it with the value provided inside the parentheses. This is a shorthand for allocation and assignment in one step.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "Which of the following is true regarding 'Automatic Variables'?",
        "options": [
            "They are created using the 'new' operator.",
            "They are stored on the stack and are local to the block in which they are defined.",
            "They never lose their value, even after the program terminates.",
            "They must be manually deleted by the programmer."
        ],
        "correct": 1,
        "explanation": "Local variables declared inside functions are 'automatic' (historical keyword: 'auto'). Their memory is automatically managed by the system stack—pushed on when entering scope and popped off when leaving.",
        "topic": "Variable Scope"
    },
    {
        "question": "When using 'new', if the system cannot find enough free memory to fulfill the request, what does C++ typically do?",
        "options": [
            "It deletes other programs to make room.",
            "It throws an exception (std::bad_alloc) or returns a NULL pointer (in older standards).",
            "It waits indefinitely until memory becomes free.",
            "It uses the hard drive as if it were RAM automatically."
        ],
        "correct": 1,
        "explanation": "Memory is a finite resource. If the heap is exhausted, 'new' fails. In modern C++, it throws an exception that can be caught. In older or specifically configured environments, it might return a 'NULL' address. Robust programs always check if an allocation was successful.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "What is the output of: int *p = new int; *p = 50; cout << *p; delete p;",
        "options": [
            "50",
            "The address of p",
            "0",
            "Compilation Error"
        ],
        "correct": 0,
        "explanation": "The code correctly allocates an integer, assigns 50 to that location by dereferencing the pointer, prints the value, and finally cleans up the memory. This is the standard life cycle of a dynamic variable.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "Why is the use of 'Global Variables' generally discouraged in large software projects?",
        "options": [
            "They take up 10 times more memory than local variables.",
            "They make it difficult to track which part of the program changed the data, leading to bugs.",
            "They can only store integer values.",
            "They are only compatible with the 'while' loop."
        ],
        "correct": 1,
        "explanation": "Since global variables are accessible by every function, any part of the program can modify them at any time. This creates 'tight coupling' and makes debugging extremely difficult because the state of the variable is not localized.",
        "topic": "Structured Programming"
    },
    {
        "question": "In C++, 'Static' local variables are initialized:",
        "options": [
            "Every time the function is called.",
            "Only once, the first time the function is called.",
            "Only if the programmer provides a 'new' keyword.",
            "Automatically to a random garbage value."
        ],
        "correct": 1,
        "explanation": "A static local variable (e.g., static int count = 0;) is created and initialized exactly once. On subsequent calls to the function, the initialization line is skipped, and the variable retains its previous value from the last execution.",
        "topic": "Storage Classes"
    },
    {
        "question": "Which of the following is an example of 'Information Hiding' in structured programming?",
        "options": [
            "Using local variables so other functions cannot see or modify them.",
            "Encrypting the source code using a password.",
            "Deleting the 'cout' statements before finishing the program.",
            "Declaring all variables as 'global' to hide them from the heap."
        ],
        "correct": 0,
        "explanation": "By using local variables within functions, you 'hide' that data from the rest of the program. Other functions can only interact with that data if it is explicitly passed to them. This reduces errors and makes modules more independent.",
        "topic": "Structured Programming"
    },
    {
        "question": "What is the effect of 'delete p;' if 'p' is currently a NULL pointer?",
        "options": [
            "The program crashes immediately.",
            "The computer reboots.",
            "Nothing happens; it is a safe operation in C++.",
            "The compiler generates an error."
        ],
        "correct": 2,
        "explanation": "C++ is designed to handle this safely. Deleting a NULL pointer does nothing and does not cause a crash. This allows programmers to write 'delete p;' without always having to check 'if (p != NULL)' first.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "Which memory segment is typically used to store 'Constants' like \"Hello World\" in a program?",
        "options": [
            "Stack",
            "Heap",
            "Read-Only Data Segment",
            "Code Segment"
        ],
        "correct": 2,
        "explanation": "String literals and 'const' global variables are usually stored in a read-only portion of the Data Segment. This prevents the program from accidentally modifying values that are supposed to remain constant.",
        "topic": "Memory Layout"
    },
    {
        "question": "A 'Buffer' is best described as:",
        "options": [
            "A type of virus that slows down the CPU.",
            "A temporary storage area in memory used to hold data during transfer.",
            "A physical component inside the motherboard.",
            "A special character used to end a loop."
        ],
        "correct": 1,
        "explanation": "Buffers are used in many areas of computing (like File I/O or network streams). They allow the program to collect a block of data in memory before processing it all at once, which is more efficient than handling data byte-by-byte.",
        "topic": "I/O Streams"
    },
    {
        "question": "What is the primary technical function of the 'Heap Manager'?",
        "options": [
            "To organize the files on the hard drive.",
            "To keep track of which parts of the heap are currently used and which are free.",
            "To translate C++ code into machine language.",
            "To manage the temperature of the CPU."
        ],
        "correct": 1,
        "explanation": "The Heap Manager (part of the runtime library) maintains a map of the heap. When 'new' is called, it searches for a big enough free block. When 'delete' is called, it marks that block as free for future use.",
        "topic": "Memory Management"
    },
    {
        "question": "If 'int *p = new int[10];', what does 'sizeof(p)' return on a 32-bit system?",
        "options": [
            "40 bytes",
            "10 bytes",
            "4 bytes",
            "8 bytes"
        ],
        "correct": 2,
        "explanation": "This is a common VU exam trick. 'p' is a pointer. On a 32-bit system, every pointer is 4 bytes. 'sizeof' returns the size of the pointer variable itself, not the size of the memory block it is pointing to on the heap.",
        "topic": "Pointers and Memory"
    },
    {
        "question": "Which keyword in C++ is used to declare a variable that should be stored in a CPU register for faster access?",
        "options": [
            "fast",
            "static",
            "register",
            "volatile"
        ],
        "correct": 2,
        "explanation": "The 'register' keyword is a hint to the compiler that a variable will be used heavily and should be kept in a high-speed CPU register if possible. Modern compilers usually ignore this hint as they are better at optimizing register usage than humans.",
        "topic": "Storage Classes"
    },
    {
        "question": "What is 'Scope' in programming?",
        "options": [
            "The speed at which a function executes.",
            "The region of the program where a variable is defined and can be accessed.",
            "The total amount of memory a program uses.",
            "The number of errors found by the compiler."
        ],
        "correct": 1,
        "explanation": "Scope determines the visibility of an identifier. For example, a variable defined inside a function has 'local scope'—it 'exists' only within that function's braces.",
        "topic": "Variable Scope"
    },
    {
        "question": "In the context of the CS201 handouts, 'L-value' refers to:",
        "options": [
            "The value on the Left side of an assignment that represents a memory location.",
            "A value that is 'Low' in priority.",
            "A constant value that cannot be changed.",
            "A value that is returned by a function."
        ],
        "correct": 0,
        "explanation": "An L-value (Locator value) refers to an object that occupies some identifiable location in memory. For example, in 'x = 10;', 'x' is an L-value because it has an address. '10' is an R-value because it's just a data value.",
        "topic": "Assignment Operators"
    },
    {
        "question": "Which of the following is a disadvantage of dynamic memory allocation?",
        "options": [
            "It allows for variable-sized arrays.",
            "It makes the program more flexible.",
            "It increases the risk of memory leaks and is slightly slower than stack allocation.",
            "It can only be used with the 'int' data type."
        ],
        "correct": 2,
        "explanation": "Dynamic allocation introduces overhead because the Heap Manager must search for free blocks. It also places the burden of memory cleanup on the programmer, unlike the stack which is managed automatically.",
        "topic": "Memory Management"
    },
    {
        "question": "What does the statement 'delete p;' actually do to the variable 'p'?",
        "options": [
            "It removes 'p' from the stack.",
            "It sets 'p' to zero.",
            "It does nothing to 'p' itself; it only frees the memory 'p' was pointing to.",
            "It renames 'p' to a different identifier."
        ],
        "correct": 2,
        "explanation": "Crucially, 'delete' acts on the *address* stored in p. It goes to that address and frees the heap memory. The pointer variable 'p' still exists on the stack and still contains that address until the function ends or 'p' is reassigned.",
        "topic": "Dynamic Memory Allocation"
    },
    {
        "question": "In the growth curve of a cell suspension culture, which phase is most similar to 'Stack Allocation' in terms of being limited and rapid?",
        "options": [
            "Lag Phase",
            "Exponential Phase",
            "Stationary Phase",
            "Death Phase"
        ],
        "correct": 1,
        "explanation": "In both programming and biology, the 'Exponential' (or Log) phase represents the period of most rapid growth or activity within defined limits. In cell culture, it's the period of constant doubling; in programming, stack allocation is the fastest way to manage data during active function calls.",
        "topic": "Analogy/General Knowledge"
    },
    {
        "question": "Which of the following describes the 'Call by Value' mechanism when passing an argument to a function in C++?",
        "options": [
            "The function receives the actual memory address of the variable.",
            "A local copy of the variable's value is created within the function's stack frame.",
            "The function can modify the original variable in the calling function directly.",
            "The variable is moved from the stack to the heap for the duration of the call."
        ],
        "correct": 1,
        "explanation": "In 'Call by Value', the compiler creates a temporary copy of the data. Any modifications made to the parameter inside the function only affect this local copy and are lost when the function returns. The original variable in the calling scope remains unchanged, which provides high data security but incurs overhead for large objects.",
        "topic": "Function Parameters"
    },
    {
        "question": "What is the primary technical advantage of 'Call by Reference' over 'Call by Value' for large data structures like arrays or structures?",
        "options": [
            "It prevents the function from accessing the data at all.",
            "It eliminates the overhead of copying large amounts of data into the function's scope.",
            "It automatically encrypts the data during the function call.",
            "It allows the function to be executed by the GPU instead of the CPU."
        ],
        "correct": 1,
        "explanation": "When passing by reference (using pointers or references), only a memory address (typically 4 or 8 bytes) is passed, regardless of the size of the data structure. This is significantly faster and uses less memory than copying a massive array or a complex structure into a new stack frame.",
        "topic": "Function Parameters"
    },
    {
        "question": "In C++, the 'Reference' operator (&) used in a function signature (e.g., void func(int &x)) serves what purpose?",
        "options": [
            "It tells the compiler to find the address of the variable x.",
            "It creates an alias for the original variable, allowing direct modification without pointer syntax.",
            "It indicates that the function will return a hexadecimal address.",
            "It is a bitwise operator that performs an 'AND' operation on the parameter."
        ],
        "correct": 1,
        "explanation": "A reference is essentially a 'constant pointer' that is automatically dereferenced. Using '&' in the parameter list allows the function to interact with the original variable using standard variable syntax (x = 10) instead of pointer syntax (*ptr = 10), while still achieving the effect of modifying the original data.",
        "topic": "References"
    },
    {
        "question": "What happens to the actual parameters in the calling function when a 'Call by Reference' function modifies its formal parameters?",
        "options": [
            "The actual parameters remain unchanged.",
            "The actual parameters are updated to reflect the changes made within the function.",
            "The actual parameters are deleted to save memory.",
            "The program generates a syntax error if the values are different."
        ],
        "correct": 1,
        "explanation": "Because 'Call by Reference' provides the function with the address of the actual parameter, the function is working with the same memory location. Therefore, any assignment to the formal parameter within the function body is an assignment to the actual parameter in the calling scope.",
        "topic": "Function Parameters"
    },
    {
        "question": "Which of the following is a requirement for using 'Call by Reference' via pointers?",
        "options": [
            "The function must be declared with the 'static' keyword.",
            "The caller must pass the address of the variable using the '&' operator.",
            "The variable being passed must be a global variable.",
            "The function cannot have a return type."
        ],
        "correct": 1,
        "explanation": "If a function expects a pointer (e.g., void func(int *p)), the calling statement must provide a memory address. This is typically done by using the address-of operator on a variable (e.g., func(&myVar)). Passing 'myVar' directly would result in a type mismatch error.",
        "topic": "Pointers and Functions"
    },
    {
        "question": "In C++, what is the functional difference between passing a pointer by value and passing a variable by reference?",
        "options": [
            "There is no functional difference; both allow the function to modify the original data.",
            "Passing a pointer is only for integers; references are for strings.",
            "Pointers require manual dereferencing (*), whereas references act like aliases.",
            "Both Options 0 and 2 are correct."
        ],
        "correct": 3,
        "explanation": "Both methods achieve 'indirection'. However, pointers are variables themselves (storing an address) and require the '*' operator to access the data. References are not objects but 'aliases' for existing objects and provide a cleaner, safer syntax for the programmer.",
        "topic": "Pointers vs References"
    },
    {
        "question": "Which keyword can be combined with a reference parameter to prevent the function from modifying the original data while still avoiding the overhead of copying?",
        "options": [
            "static",
            "const",
            "void",
            "fixed"
        ],
        "correct": 1,
        "explanation": "Using 'const type &var' is a 'best practice' in C++. It provides the efficiency of 'Call by Reference' (no copying) with the safety of 'Call by Value' (the function is prohibited from changing the original data). If the function tries to modify a 'const' reference, the compiler will issue an error.",
        "topic": "References"
    },
    {
        "question": "When an array is passed to a function, why does it behave like 'Call by Reference' by default?",
        "options": [
            "Because C++ arrays are always stored on the heap.",
            "Because the name of an array decays into a pointer to its first element.",
            "Because arrays are too large to fit on the stack.",
            "Because the compiler automatically adds the '&' operator to all array names."
        ],
        "correct": 1,
        "explanation": "In C++, the identifier of an array represents the base address of that array. When you pass 'myArray' to a function, you are technically passing '&myArray[0]'. Since the function receives a memory address, it can modify the original contents of the array elements.",
        "topic": "Arrays and Functions"
    },
    {
        "question": "What is the scope of a variable defined within the parentheses of a function header (a formal parameter)?",
        "options": [
            "Global scope",
            "File scope",
            "Local scope (Function scope)",
            "Dynamic scope"
        ],
        "correct": 2,
        "explanation": "Formal parameters are treated as local variables within the function. They are created when the function is called and destroyed when the function returns. They are not accessible by the calling function or any other part of the program.",
        "topic": "Variable Scope"
    },
    {
        "question": "Which of the following describes 'Side Effects' in the context of function calls?",
        "options": [
            "The program crashing due to a hardware failure.",
            "Changes made by a function to variables outside its own local scope (e.g., via references).",
            "The time it takes for a function to return a value.",
            "The memory used by the compiler to optimize the code."
        ],
        "correct": 1,
        "explanation": "A 'side effect' occurs when a function modifies a state outside its local environment. While sometimes intentional (like updating a global counter or a passed-by-reference variable), uncontrolled side effects make programs harder to debug and understand.",
        "topic": "Functions"
    },
    {
        "question": "What is the resulting output? \nvoid test(int x) { x = x + 5; } \nint main() { int a = 10; test(a); cout << a; }",
        "options": [
            "15",
            "10",
            "5",
            "0"
        ],
        "correct": 1,
        "explanation": "This is 'Call by Value'. The function 'test' receives a copy of 'a'. It adds 5 to its local copy (making it 15), but the original 'a' in 'main' remains 10. The output is 10.",
        "topic": "Call by Value"
    },
    {
        "question": "What is the resulting output? \nvoid test(int *x) { *x = *x + 5; } \nint main() { int a = 10; test(&a); cout << a; }",
        "options": [
            "15",
            "10",
            "5",
            "0"
        ],
        "correct": 0,
        "explanation": "This is 'Call by Reference' via a pointer. The address of 'a' is passed. The function dereferences the pointer and adds 5 directly to the memory location of 'a'. The original 'a' becomes 15.",
        "topic": "Call by Reference"
    },
    {
        "question": "In a 'Structure' (struct), why is it common to pass the structure to a function by reference?",
        "options": [
            "Structures cannot be passed by value in C++.",
            "To avoid the time and memory cost of copying all member variables of the structure.",
            "To ensure the structure is stored in the code segment.",
            "To prevent the function from seeing the private members."
        ],
        "correct": 1,
        "explanation": "Structures can contain many data members. Passing by value requires the compiler to copy every single member into the function's stack frame. For a large structure (e.g., representing a database record), this is highly inefficient compared to passing a single memory address.",
        "topic": "Structures"
    },
    {
        "question": "Which of the following is the correct function prototype to pass an integer 'n' by reference?",
        "options": [
            "void calculate(int n);",
            "void calculate(int &n);",
            "void calculate(int *n);",
            "Both Options 1 and 2 are correct."
        ],
        "correct": 3,
        "explanation": "Option 1 uses C++ reference syntax. Option 2 uses pointer syntax. Both allow the function to access the original memory location of 'n' rather than a copy.",
        "topic": "Function Prototypes"
    },
    {
        "question": "A 'Reference' variable in C++ must be ________ at the time of declaration.",
        "options": [
            "Deleted",
            "Initialized",
            "Constant",
            "Global"
        ],
        "correct": 1,
        "explanation": "Unlike pointers, which can be declared and assigned later, a reference is an alias for an existing variable. It must be initialized to refer to a specific variable the moment it is created, and it cannot be 're-seated' to refer to a different variable later.",
        "topic": "References"
    },
    {
        "question": "What is the memory size of a 'Reference' variable?",
        "options": [
            "The same size as the variable it refers to.",
            "Typically 4 or 8 bytes (the size of a memory address).",
            "References occupy no memory of their own; they are just aliases.",
            "1 byte."
        ],
        "correct": 2,
        "explanation": "Under the hood, the compiler implements references using pointers. However, logically, a reference is not considered a separate object in memory; it is just another name for an existing object. Therefore, it does not occupy its own distinct space in the way a pointer variable does.",
        "topic": "References"
    },
    {
        "question": "In the statement 'int x = 10; int &y = x;', what is 'y'?",
        "options": [
            "A pointer to x.",
            "A copy of x.",
            "An alias for x.",
            "A constant integer."
        ],
        "correct": 2,
        "explanation": "'y' is a reference to 'x'. Any operation performed on 'y' (e.g., y++) is actually performed on 'x'. They are two names for the same memory location.",
        "topic": "References"
    },
    {
        "question": "Which of the following is a disadvantage of 'Call by Reference'?",
        "options": [
            "It is slower than Call by Value.",
            "It uses more memory than Call by Value.",
            "It can lead to accidental modification of data if not used with 'const'.",
            "It is not supported for integer data types."
        ],
        "correct": 2,
        "explanation": "Because 'Call by Reference' allows the function to change the original variable, it can lead to bugs where data is modified unexpectedly. This is why 'const references' are recommended for data that should not be changed.",
        "topic": "Function Parameters"
    },
    {
        "question": "Why can't you have a 'Reference to NULL' in C++?",
        "options": [
            "NULL is a reserved keyword for pointers only.",
            "A reference must always refer to a valid, existing object.",
            "NULL is an integer, and references only work for characters.",
            "Because references are stored on the hard drive."
        ],
        "correct": 1,
        "explanation": "A reference is an alias for an object. Since 'NULL' represents the absence of an object, you cannot create an alias for it. This makes references inherently 'safer' than pointers because a reference (if properly used) is guaranteed to point to a valid memory location.",
        "topic": "References"
    },
    {
        "question": "When returning a value from a function, 'return x;' usually performs which type of operation?",
        "options": [
            "Return by Reference",
            "Return by Value",
            "Return by Address",
            "Return by Pointer"
        ],
        "correct": 1,
        "explanation": "By default, C++ functions return values 'by value'. This means a copy of the local variable 'x' is created and passed back to the calling function, after which the local 'x' is destroyed.",
        "topic": "Return Values"
    },
    {
        "question": "Why is it dangerous to 'Return by Reference' a local variable from a function?",
        "options": [
            "Local variables are too small to be references.",
            "The local variable is destroyed when the function returns, leaving the reference 'dangling'.",
            "The compiler will automatically convert it to a global variable.",
            "It uses too much CPU power."
        ],
        "correct": 1,
        "explanation": "A local variable exists on the stack. When the function ends, that stack space is reclaimed. If you return a reference to that variable, the calling function receives an alias to a memory location that is no longer valid, leading to crashes or garbage data.",
        "topic": "Return by Reference"
    },
    {
        "question": "In 'Call by Value', the parameters in the function header are known as ________.",
        "options": [
            "Actual Parameters",
            "Formal Parameters",
            "Global Parameters",
            "Static Parameters"
        ],
        "correct": 1,
        "explanation": "Formal parameters are the 'placeholders' defined in the function's signature. Actual parameters (or arguments) are the real values or variables passed into the function during the call.",
        "topic": "Function Basics"
    },
    {
        "question": "Which of the following is true regarding 'Overloading' and function parameters?",
        "options": [
            "Functions can be overloaded based on the return type only.",
            "Functions can be overloaded if they have different parameter types or numbers of parameters.",
            "Overloading only works with 'Call by Value'.",
            "Overloading is not allowed in structured programming."
        ],
        "correct": 1,
        "explanation": "Function Overloading allows multiple functions to have the same name as long as their signatures (parameter list) are different. The compiler distinguishes them by the types and sequence of arguments provided in the call.",
        "topic": "Function Overloading"
    },
    {
        "question": "What is the primary role of the 'Stack' during a function call?",
        "options": [
            "To store the program's binary code.",
            "To store local variables, parameters, and the return address.",
            "To provide a large pool of memory for dynamic arrays.",
            "To manage the internet connection."
        ],
        "correct": 1,
        "explanation": "The stack is an 'automatic' memory area. Every time a function is called, a 'stack frame' is pushed onto it, containing everything needed for that specific call. When the function returns, the frame is popped off, and memory is reclaimed.",
        "topic": "Memory Management"
    },
    {
        "question": "In 'Call by Reference', the argument passed to the function must be a/an ________.",
        "options": [
            "Literal (e.g., 10)",
            "Variable (L-value)",
            "Expression (e.g., x + 5)",
            "Function call"
        ],
        "correct": 1,
        "explanation": "Because a reference needs a memory location to alias, you cannot pass a literal (which has no address) to a non-const reference parameter. You must pass an L-value—an object that has an identifiable location in memory.",
        "topic": "References"
    },
    {
        "question": "What is the significance of the 'base address' in array-function interaction?",
        "options": [
            "It is the address of the last element.",
            "It is the memory location of the first element (index 0).",
            "It is the total size of the array in bits.",
            "It is a pointer that points to the compiler's memory."
        ],
        "correct": 1,
        "explanation": "Passing an array to a function actually passes its base address. All indexing inside the function (e.g., arr[i]) is then calculated as an offset from this base address.",
        "topic": "Arrays"
    },
    {
        "question": "Which C++ feature allows a function to modify multiple values and 'return' them to the caller?",
        "options": [
            "A 'return' statement with multiple values.",
            "Using multiple reference parameters.",
            "Declaring the function as 'void'.",
            "Using the 'static' keyword."
        ],
        "correct": 1,
        "explanation": "A 'return' statement can only return a single value. To 'return' more data, programmers use reference parameters. Since the function modifies the original variables in the calling scope, the effect is equivalent to returning multiple results.",
        "topic": "Function Parameters"
    },
    {
        "question": "What happens if a function's formal parameter is 'int &x' and you pass a 'const int a = 5;' to it?",
        "options": [
            "The program runs correctly.",
            "The compiler generates an error because it cannot bind a non-const reference to a constant variable.",
            "The variable 'a' is automatically converted to a non-const variable.",
            "The function creates a copy of 'a'."
        ],
        "correct": 1,
        "explanation": "C++ protects 'const' data. A non-const reference implies the function might change the value. Since 'a' is constant and cannot be changed, the compiler forbids passing it to a parameter that might attempt to modify it.",
        "topic": "References"
    },
    {
        "question": "In the context of function calls, 'Indirection' is achieved by using:",
        "options": [
            "Global variables",
            "Pointers or References",
            "Large 'if' statements",
            "The 'main' function"
        ],
        "correct": 1,
        "explanation": "Indirection is the ability to refer to a value through another name or address. Pointers and references are the primary tools for indirection, allowing functions to act on data without having the data itself 'inside' the function.",
        "topic": "Pointers and References"
    },
    {
        "question": "Which of the following is true about 'Array-Pointer Duality' in function calls?",
        "options": [
            "Arrays and pointers are treated as the same thing by the compiler when passed to functions.",
            "Arrays are passed by value; pointers are passed by reference.",
            "Pointers can be indexed like arrays, but arrays cannot be used as pointers.",
            "It is a feature that only works in the Java language."
        ],
        "correct": 0,
        "explanation": "In function parameters, 'void func(int arr[])' and 'void func(int *arr)' are identical. In both cases, the function receives a pointer (the base address) and can use array-style indexing to access the memory.",
        "topic": "Function Parameters"
    },
    {
        "question": "Which C++ class is specifically designed to create a stream for reading data from an existing file on the disk?",
        "options": [
            "ofstream",
            "ifstream",
            "iostream",
            "fstream"
        ],
        "correct": 1,
        "explanation": "In C++, 'ifstream' stands for 'Input File Stream'. It is a specialized class used to open and read data from files. 'ofstream' (Option 0) is for output (writing), while 'fstream' (Option 3) can handle both but requires specific mode flags. Using the correct class ensures that the compiler provides the appropriate member functions for the task.",
        "topic": "File Handling"
    },
    {
        "question": "What is the primary function of the 'open()' member function in file processing?",
        "options": [
            "To create a new directory on the hard drive.",
            "To establish a logical connection between a file stream object and a physical file on the disk.",
            "To translate the file's text into binary machine code.",
            "To display the contents of a file directly on the monitor."
        ],
        "correct": 1,
        "explanation": "Before a file can be read from or written to, the program must link a stream object (like 'myFile') to a physical file name (like 'data.txt'). The 'open()' function performs this task. If the connection fails (e.g., the file is missing), the stream enters a 'fail' state that the programmer must check.",
        "topic": "File Handling"
    },
    {
        "question": "Which operator is used to 'insert' data into an 'ofstream' object to write it to a file?",
        "options": [
            ">>",
            "==",
            "<<",
            "&&"
        ],
        "correct": 2,
        "explanation": "The insertion operator (<<) is used for all output streams, whether it is 'cout' (screen) or an 'ofstream' (file). It 'inserts' the data from the right-hand operand into the stream on the left. The extraction operator (>>) is used for input streams like 'cin' or 'ifstream'.",
        "topic": "File I/O"
    },
    {
        "question": "What happens by default if you open an existing file using 'ofstream' without any special mode flags?",
        "options": [
            "The new data is appended to the end of the file.",
            "The file is deleted from the hard drive.",
            "The existing contents of the file are truncated (deleted) and overwritten.",
            "The program generates a runtime error because the file already exists."
        ],
        "correct": 2,
        "explanation": "By default, 'ofstream' opens a file in 'ios::out' mode. If the file already exists, C++ truncates its length to zero, effectively erasing all previous data. To preserve existing data, the programmer must explicitly use the 'ios::app' (append) flag.",
        "topic": "File Handling"
    },
    {
        "question": "Which member function should be called after a program finishes all I/O operations with a file to ensure data integrity?",
        "options": [
            "stop()",
            "finish()",
            "close()",
            "exit()"
        ],
        "correct": 2,
        "explanation": "The 'close()' function disconnects the stream from the physical file. This is a critical step because it flushes any remaining data from the memory buffer to the disk. Failing to close a file can lead to data loss or the file remaining 'locked' by the operating system.",
        "topic": "File Handling"
    },
    {
        "question": "The 'eof()' function returns 'true' when:",
        "options": [
            "The file is empty.",
            "A read operation attempts to move past the end of the file.",
            "The file fails to open.",
            "The file contains only integer data."
        ],
        "correct": 1,
        "explanation": "'eof()' stands for 'End Of File'. It is a Boolean function that returns true only after an input operation has attempted to read data that isn't there because the end of the file has been reached. It is commonly used as a condition for 'while' loops to process a whole file.",
        "topic": "Stream States"
    },
    {
        "question": "Which header file must be included to utilize file stream classes in C++?",
        "options": [
            "iostream",
            "fstream",
            "iomanip",
            "stdlib.h"
        ],
        "correct": 1,
        "explanation": "The <fstream> header contains the definitions for 'ifstream', 'ofstream', and 'fstream' classes. While <iostream> handles standard console I/O, <fstream> is required for external file manipulation.",
        "topic": "Pre-processor Directives"
    },
    {
        "question": "In the statement 'myFile.open(\"test.txt\", ios::app);', what does 'ios::app' signify?",
        "options": [
            "Open the file for reading only.",
            "Open the file and add new data to the end of the existing content.",
            "Open the file only if it is an application file.",
            "Open the file and clear its contents."
        ],
        "correct": 1,
        "explanation": "'ios::app' is the 'append' mode flag. It ensures that the file pointer is moved to the very end of the file before every write operation. This prevents the existing data from being lost, which is the standard practice for log files or adding to lists.",
        "topic": "File Modes"
    },
    {
        "question": "What is the return value of the '!myFile' expression if the file failed to open correctly?",
        "options": [
            "0 (false)",
            "1 (true)",
            "The file's size",
            "A random memory address"
        ],
        "correct": 1,
        "explanation": "C++ overloads the '!' operator for stream objects. If the stream is in a 'fail' state (for example, if 'open()' couldn't find the file), the stream object evaluates to false. Therefore, '!myFile' becomes true. This is the idiomatic way to check for file opening errors.",
        "topic": "Error Handling"
    },
    {
        "question": "Which function is used to read a single character from a file, including whitespace characters?",
        "options": [
            "get()",
            "read()",
            "extraction operator (>>)",
            "getline()"
        ],
        "correct": 0,
        "explanation": "The 'get()' member function (e.g., 'inFile.get(ch)') reads the next character in the file regardless of whether it is a letter, a space, or a newline. The '>>' operator (Option 2) is less suitable for character-by-character processing because it skips whitespace.",
        "topic": "Character I/O"
    },
    {
        "question": "A 'Binary File' differs from a 'Text File' because:",
        "options": [
            "It can only be read by the CPU.",
            "It stores data exactly as it appears in memory, without converting it to characters.",
            "It is much slower to process.",
            "It cannot be stored on a hard drive."
        ],
        "correct": 1,
        "explanation": "Text files convert data (like the number 65) into human-readable characters ('A'). Binary files store the raw bits (01000001). Binary files are more efficient for complex data types like structures because they avoid the conversion overhead and take up less space.",
        "topic": "Binary I/O"
    },
    {
        "question": "Which flag is used to open a file for both input and output simultaneously in an 'fstream' object?",
        "options": [
            "ios::in",
            "ios::out",
            "ios::in | ios::out",
            "ios::both"
        ],
        "correct": 2,
        "explanation": "Using the bitwise OR operator (|), you can combine multiple flags. 'ios::in | ios::out' allows the same file stream object to both read from and write to the file. This is common in database applications where a record is read, updated, and then written back.",
        "topic": "File Modes"
    },
    {
        "question": "What is the purpose of the 'seekg()' function in file processing?",
        "options": [
            "To search for a specific word in a text file.",
            "To move the 'get' (input) pointer to a specific byte location in the file.",
            "To see how many bytes are in the file.",
            "To check if the file is encrypted."
        ],
        "correct": 1,
        "explanation": "'seekg' stands for 'Seek Get'. It is used to move the read position within a file, allowing for 'Random Access'—jumping to any part of the file instead of reading sequentially from the start. 'seekp' is the equivalent for the write (put) pointer.",
        "topic": "Random Access"
    },
    {
        "question": "In C++, 'Sequential Access' means:",
        "options": [
            "Accessing data in any random order.",
            "Reading data one piece at a time from the beginning to the end.",
            "Using multiple CPU cores to read a file.",
            "Storing data on a CD-ROM."
        ],
        "correct": 1,
        "explanation": "Sequential access is the default behavior of file streams. You start at the first byte and move forward through the file. It is like a cassette tape, where you must pass through the first part of the tape to reach the middle.",
        "topic": "File Access"
    },
    {
        "question": "Which function returns the current byte position of the 'put' (output) pointer in a file?",
        "options": [
            "tellg()",
            "tellp()",
            "wherep()",
            "posp()"
        ],
        "correct": 1,
        "explanation": "'tellp' (Tell Put) returns the current index of the write pointer. 'tellg' (Tell Get) does the same for the read pointer. These are essential for keeping track of where you are in a file during complex operations.",
        "topic": "Random Access"
    },
    {
        "question": "What happens if a program tries to open a file for reading that does not exist?",
        "options": [
            "The program crashes immediately.",
            "The operating system creates a new empty file with that name.",
            "The stream enters a 'fail' state, and the open operation fails.",
            "The program waits until the user creates the file."
        ],
        "correct": 2,
        "explanation": "Unlike 'ofstream' (which creates a new file if it's missing), 'ifstream' requires the file to exist. If it doesn't, the stream's error bit is set, and any subsequent read operations will be ignored. Programmers should always check if the file opened successfully.",
        "topic": "Error Handling"
    },
    {
        "question": "Why is 'Buffer' management important in File I/O?",
        "options": [
            "It allows the program to run without RAM.",
            "It reduces the number of slow physical disk accesses by grouping data in memory.",
            "It is a type of security that prevents hacking.",
            "It automatically translates code into different languages."
        ],
        "correct": 1,
        "explanation": "Writing to a disk is thousands of times slower than writing to RAM. C++ uses a 'buffer' (a temporary memory area). It waits until the buffer is full before writing a large block to the disk all at once, which is much more efficient.",
        "topic": "Memory Management"
    },
    {
        "question": "Which of the following describes the 'ios::binary' flag?",
        "options": [
            "It converts the file contents into 0s and 1s on the screen.",
            "It tells the stream to process data in raw binary format without special character translations.",
            "It allows the file to be read by only two users at a time.",
            "It makes the file only 2 bytes in size."
        ],
        "correct": 1,
        "explanation": "In text mode, C++ might perform translations (like converting '\\n' to carriage-return/line-feed on Windows). In 'ios::binary' mode, these translations are disabled, and data is moved byte-for-byte exactly as it is. This is required for images, audio, or executable files.",
        "topic": "File Modes"
    },
    {
        "question": "To write a whole 'Structure' (struct) to a file in one operation, which function is most appropriate?",
        "options": [
            "put()",
            "write()",
            "insertion operator (<<)",
            "send()"
        ],
        "correct": 1,
        "explanation": "The 'write()' function (e.g., 'outFile.write((char*)&myStruct, sizeof(myStruct))') is designed for binary output. It takes the memory address of the struct and the number of bytes it occupies, copying the whole block to the file at once.",
        "topic": "Binary I/O"
    },
    {
        "question": "What is the result of 'myFile.clear()'?",
        "options": [
            "It deletes the content of the physical file on the disk.",
            "It resets the internal error state flags of the stream object to 'good'.",
            "It clears the computer's screen.",
            "It deallocates the stream object from the heap."
        ],
        "correct": 1,
        "explanation": "If a stream encounter an error (like reaching EOF), it stays in a 'fail' state even if you move the pointer back. 'clear()' resets these flags so you can continue using the stream for further operations.",
        "topic": "Stream States"
    },
    {
        "question": "The 'ios::trunc' flag is used to:",
        "options": [
            "Truncate a long filename to a shorter one.",
            "Delete the contents of an existing file upon opening it.",
            "Prevent the file from being opened by other users.",
            "Automatically round floating-point numbers in the file."
        ],
        "correct": 1,
        "explanation": "'trunc' is short for truncate. It is the default behavior of 'ios::out'. It ensures that if the file exists, its previous content is discarded so the program can start with a clean, empty file.",
        "topic": "File Modes"
    },
    {
        "question": "Which of the following is true about 'Random Access' in files?",
        "options": [
            "It is only possible in binary files.",
            "It allows reading any record by moving the file pointer to a specific offset.",
            "It is achieved using the 'random()' function.",
            "It causes the hard drive to spin in the opposite direction."
        ],
        "correct": 1,
        "explanation": "Random access is a powerful technique where you calculate the byte position of a record (e.g., record_number * record_size) and use 'seekg' to jump directly there. This is how databases retrieve specific information quickly without searching the whole file.",
        "topic": "Random Access"
    },
    {
        "question": "What does the 'fail()' member function check for?",
        "options": [
            "If the computer has run out of battery.",
            "If a logical error or a serious hardware failure has occurred on the stream.",
            "If the user has entered an incorrect password.",
            "If the program has more than 100 lines of code."
        ],
        "correct": 1,
        "explanation": "The 'fail()' function returns true if either the 'failbit' or 'badbit' is set. This happens during serious errors, such as trying to read an integer but finding letters in the file, or if the physical disk is unreadable.",
        "topic": "Stream States"
    },
    {
        "question": "Which function is used to read a block of data from a binary file into a memory address?",
        "options": [
            "get()",
            "read()",
            "extraction operator (>>)",
            "getline()"
        ],
        "correct": 1,
        "explanation": "The 'read()' function (e.g., 'inFile.read((char*)&buffer, size)') is the binary counterpart to 'write()'. It reads a specified number of raw bytes from the file and places them directly into memory at the given address.",
        "topic": "Binary I/O"
    },
    {
        "question": "What is the significance of the 'reinterpret_cast' or C-style cast often used in binary File I/O?",
        "options": [
            "It encrypts the data before writing.",
            "It tells the compiler to treat a pointer of one type (like a struct) as a pointer to a character array (bytes).",
            "It speeds up the disk's rotation speed.",
            "It translates the file into different languages."
        ],
        "correct": 1,
        "explanation": "The 'read' and 'write' functions expect a 'char*' (a pointer to bytes). Since our data is often in other forms (like a 'Student' struct), we must cast the address so the compiler allows the byte-by-byte transfer. Example: '(char*)&myStudent'.",
        "topic": "Binary I/O"
    },
    {
        "question": "How do you move the write pointer to the beginning of a file?",
        "options": [
            "myFile.seekp(0, ios::beg);",
            "myFile.seekg(0, ios::beg);",
            "myFile.start();",
            "myFile.rewind();"
        ],
        "correct": 0,
        "explanation": "'seekp' is for the 'put' (write) pointer. '0' is the offset, and 'ios::beg' indicates the starting point is the 'beginning' of the file. This resets the writer to the start, allowing it to overwrite data.",
        "topic": "Random Access"
    },
    {
        "question": "Which of the following is NOT a valid stream state flag in C++?",
        "options": [
            "goodbit",
            "eofbit",
            "failbit",
            "emptybit"
        ],
        "correct": 3,
        "explanation": "The four standard flags are 'goodbit' (no errors), 'eofbit' (end of file), 'failbit' (logical error), and 'badbit' (serious hardware error). There is no such thing as 'emptybit' in the C++ standard library.",
        "topic": "Stream States"
    },
    {
        "question": "What is a 'Stream' in C++ terminology?",
        "options": [
            "A fast-moving river of data.",
            "An abstraction that represents a flow of data between a source and a destination.",
            "A type of high-speed memory chip.",
            "A function that only runs during the daytime."
        ],
        "correct": 1,
        "explanation": "A stream is a 'logical device' that behaves the same way regardless of the 'physical device'. Whether you are reading from a keyboard, a file, or a network, the 'stream' interface remains consistent, making programming much easier.",
        "topic": "I/O Streams"
    },
    {
        "question": "The 'ios::ate' flag stands for 'At The End'. How does it differ from 'ios::app'?",
        "options": [
            "There is no difference.",
            "ios::ate moves to the end only when opened; ios::app moves to the end before every write.",
            "ios::ate is for reading; ios::app is for writing.",
            "ios::ate deletes the file; ios::app saves it."
        ],
        "correct": 1,
        "explanation": "Both move the pointer to the end of the file. However, 'ios::app' (append) is stricter; it forces every single write to happen at the end. 'ios::ate' just starts you at the end, but allows you to 'seekg' elsewhere to overwrite data in the middle.",
        "topic": "File Modes"
    },
    {
        "question": "What is the resulting output? \noffstream out(\"test.txt\"); \nout << \"CS201\"; \nout.close(); \nifstream in(\"test.txt\"); \nstring s; in >> s; cout << s;",
        "options": [
            "CS201",
            "Nothing (file is empty)",
            "An error message",
            "The memory address of s"
        ],
        "correct": 0,
        "explanation": "The code creates a file, writes \"CS201\" to it, closes it (saving the data), then opens it for reading, extracts the string, and prints it. This is the complete basic cycle of file persistence.",
        "topic": "File I/O"
    },
    {
        "question": "In C++, what is the primary technical difference between the 'Copy Constructor' and the 'Assignment Operator'?",
        "options": [
            "The Copy Constructor is used for integers; the Assignment Operator is for strings.",
            "The Copy Constructor initializes a new object using an existing one, while the Assignment Operator copies values into an already existing object.",
            "The Assignment Operator is called automatically by the compiler, but the Copy Constructor must be called manually.",
            "There is no difference; they both perform the same memory operation in the stack."
        ],
        "correct": 1,
        "explanation": "A Copy Constructor (e.g., Student s2 = s1;) is invoked when a new object is being created and initialized with an existing object's data. The Assignment Operator (e.g., s2 = s1;) is used when both objects already exist in memory and data is being transferred from one to the other. Distinguishing between them is crucial for managing dynamic memory and avoiding double-deletion errors.",
        "topic": "Copy Constructor vs Assignment Operator"
    },
    {
        "question": "Which of the following is a mandatory requirement when overloading the 'Assignment Operator' for a class that uses dynamic memory?",
        "options": [
            "It must return void.",
            "It must check for self-assignment (e.g., s1 = s1).",
            "It must be declared as a static function.",
            "It must only accept integer parameters."
        ],
        "correct": 1,
        "explanation": "Self-assignment checks are critical. If an object is assigned to itself, a naive implementation might delete the object's current memory before copying, effectively destroying the source data. Checking 'if (this == &source)' prevents this logical failure and potential program crashes.",
        "topic": "Operator Overloading"
    },
    {
        "question": "What is the specific role of the 'friend' keyword when applied to a class 'A' inside class 'B'?",
        "options": [
            "Class A can access all private and protected members of Class B.",
            "Class B can access all private members of Class A.",
            "Both classes can access each other's private members automatically.",
            "Class A becomes a parent (base) class of Class B."
        ],
        "correct": 0,
        "explanation": "Friendship in C++ is not mutual and is specifically granted. By declaring 'friend class A;' inside Class B, Class B is giving Class A permission to see its private 'secrets'. However, Class B does not gain access to Class A's private members unless Class A specifically declares B as a friend as well.",
        "topic": "Friend Classes"
    },
    {
        "question": "In the C++ memory model, where is a 'Static' data member of a class stored?",
        "options": [
            "Inside every object of the class on the stack.",
            "In a single, shared memory location in the data segment.",
            "On the heap only when the first object is created.",
            "In the CPU registers for faster access."
        ],
        "correct": 1,
        "explanation": "Static data members do not belong to individual objects; they belong to the class itself. Regardless of whether zero or one hundred objects are created, only one copy of a static member exists in the 'Global/Static' memory area. This allows all instances of the class to share a common piece of information, such as a counter for the total number of objects.",
        "topic": "Static Members"
    },
    {
        "question": "Which of the following describes the limitation of a 'Static Member Function'?",
        "options": [
            "It cannot return any value.",
            "It cannot access non-static (instance) data members or the 'this' pointer.",
            "It can only be called if at least one object of the class exists.",
            "It must be defined inside the main() function."
        ],
        "correct": 1,
        "explanation": "Because static member functions belong to the class and not a specific instance, they do not receive a 'this' pointer. Consequently, they have no way of knowing which object's data to access. They are restricted to interacting only with static data members or other static functions of that class.",
        "topic": "Static Functions"
    },
    {
        "question": "Why is it necessary to define (allocate memory for) a static data member outside the class body in the source (.cpp) file?",
        "options": [
            "To allow the linker to see the variable and allocate space in the static data segment.",
            "To prevent the compiler from making the variable private.",
            "Because C++ does not allow variables to be declared inside classes.",
            "To ensure the variable is stored on the hard drive instead of RAM."
        ],
        "correct": 0,
        "explanation": "The declaration inside the class only informs the compiler about the existence and type of the static member. The actual memory must be 'defined' outside to ensure that the linker allocates exactly one instance of that variable in the program's static memory. Failure to do this results in an 'unresolved external symbol' error.",
        "topic": "Static Members"
    },
    {
        "question": "In the context of 'Friendship', which statement is true regarding inheritance?",
        "options": [
            "Friendship is inherited; if A is a friend of B, then A's children are friends of B.",
            "Friendship is not inherited; a friend of a base class is not automatically a friend of a derived class.",
            "Friendship is transitive; if A is a friend of B and B is a friend of C, then A is a friend of C.",
            "Friendship can only be granted to base classes."
        ],
        "correct": 1,
        "explanation": "C++ strictly follows the rule that friendship is neither inherited nor transitive. Just because you trust a person (Class A) doesn't mean you automatically trust their children or their other friends. Every friendship must be explicitly declared within the class that is 'hiding' the data.",
        "topic": "Friendship"
    },
    {
        "question": "What does 'Operator Overloading' allow a programmer to do in C++?",
        "options": [
            "Create entirely new operators that don't exist in the language.",
            "Redefine the meaning of existing operators (like +, -, *) for user-defined types (classes).",
            "Change the behavior of operators for standard types like int and float.",
            "Speed up the execution of basic arithmetic operations."
        ],
        "correct": 1,
        "explanation": "Operator overloading provides 'syntactic sugar,' allowing objects to be used in expressions as if they were primitive types (e.g., adding two 'ComplexNumber' objects using the + sign). It makes the code more intuitive and readable. Note that you cannot change operators for primitive types or create brand new symbols.",
        "topic": "Operator Overloading"
    },
    {
        "question": "Which operator cannot be overloaded as a 'Global/Friend' function and MUST be a member function of the class?",
        "options": [
            "The addition operator (+)",
            "The assignment operator (=)",
            "The stream insertion operator (<<)",
            "The equality operator (==)"
        ],
        "correct": 1,
        "explanation": "Certain operators, including the assignment operator (=), subscript operator ([]), and function call operator (()), are strictly required by C++ standards to be non-static member functions. This ensures they have direct access to the 'this' pointer of the object they are modifying.",
        "topic": "Operator Overloading"
    },
    {
        "question": "What is the return type of a correctly overloaded assignment operator to allow 'Chained Assignments' (e.g., a = b = c)?",
        "options": [
            "void",
            "int",
            "A reference to the class type (e.g., Student&)",
            "A pointer to the class type (e.g., Student*)"
        ],
        "correct": 2,
        "explanation": "To support chaining, the operator must return the object that was just assigned to. By returning a reference to the current object ('return *this;'), the result of 'b = c' becomes an L-value that can then be used as the source for the next assignment 'a = ...'.",
        "topic": "Operator Overloading"
    },
    {
        "question": "When is the 'Default' Copy Constructor provided by the compiler insufficient?",
        "options": [
            "When the class contains only integer data members.",
            "When the class contains pointers to dynamically allocated memory (heap).",
            "When the class has more than five member functions.",
            "When the class is used inside a while loop."
        ],
        "correct": 1,
        "explanation": "The default copy constructor performs a 'Shallow Copy' (member-wise copy). If an object contains a pointer to the heap, the default constructor will copy the address. This results in two objects pointing to the same memory. When one is destroyed, the other is left with a 'dangling pointer', causing crashes.",
        "topic": "Copy Constructors"
    },
    {
        "question": "A 'Constant' object can only call member functions that are marked with which keyword?",
        "options": [
            "static",
            "const",
            "friend",
            "void"
        ],
        "correct": 1,
        "explanation": "If an object is declared as 'const', C++ enforces its immutability. To ensure the object's state isn't changed, the compiler only allows calls to 'const member functions'—functions that explicitly promise not to modify any data members of the class.",
        "topic": "Const Objects"
    },
    {
        "question": "In C++, 'Operator Overloading' follows the rules of which polymorphism type?",
        "options": [
            "Runtime Polymorphism",
            "Compile-time (Static) Polymorphism",
            "Dynamic Binding",
            "Encapsulated Polymorphism"
        ],
        "correct": 1,
        "explanation": "Operator overloading is resolved by the compiler based on the types of the operands at the time of compilation. This is a form of static polymorphism, similar to function overloading. The compiler replaces the operator symbol with a call to the specific operator function.",
        "topic": "OOP Principles"
    },
    {
        "question": "What is the consequence of declaring a member function as 'Static'?",
        "options": [
            "The function can only be accessed by one object at a time.",
            "The function can be called using the class name even if no objects exist.",
            "The function is stored in the heap instead of the code segment.",
            "The function's variables are automatically encrypted."
        ],
        "correct": 1,
        "explanation": "Static member functions are class-level functions. Since they don't rely on the 'this' pointer of an instance, they can be invoked using the syntax 'ClassName::FunctionName()'. This is useful for utility functions that relate to the class but don't require object-specific data.",
        "topic": "Static Members"
    },
    {
        "question": "Which of the following is true about 'Friend' functions?",
        "options": [
            "They are member functions of the class they are friends with.",
            "They must be called using the dot (.) operator.",
            "They are defined outside the class scope but can access private members.",
            "They cannot have any parameters."
        ],
        "correct": 2,
        "explanation": "Friend functions are NOT member functions; they are global functions or members of another class. They are not called 'on' an object (like obj.func()), but they can take an object as a parameter and access its private data members directly within their body.",
        "topic": "Friend Functions"
    },
    {
        "question": "To overload the '+' operator to add an 'int' to a 'Class' object (e.g., object + 5), the operator function should ideally be:",
        "options": [
            "A member function of the class.",
            "A global friend function.",
            "A static function inside main().",
            "It is impossible to add different types."
        ],
        "correct": 0,
        "explanation": "If the left-hand operand is an object of the class (Object + int), a member function 'operator+(int)' works perfectly. However, if the expression were (int + Object), a global/friend function would be required because the left-hand side is not a class object.",
        "topic": "Operator Overloading"
    },
    {
        "question": "What is the role of the 'this' pointer in the overloaded assignment operator?",
        "options": [
            "It represents the source object being copied from.",
            "It represents the target object being assigned to.",
            "It is used to delete the source object.",
            "It points to the compiler's temporary memory."
        ],
        "correct": 1,
        "explanation": "In 'obj1 = obj2;', the assignment operator is called on 'obj1'. Inside the function, the 'this' pointer points to 'obj1'. The function's logic involves copying data from the parameter (obj2) into the object pointed to by 'this'.",
        "topic": "This Pointer"
    },
    {
        "question": "What happens if you define a static data member inside the class but forget to initialize it outside?",
        "options": [
            "The program will run and use a default value of 0.",
            "The compiler will generate an 'Undefined Reference' linker error.",
            "The program will use the value of the first integer it finds in memory.",
            "The variable will be created on the stack instead."
        ],
        "correct": 1,
        "explanation": "Static members require a two-step process: declaration (inside the class) and definition/allocation (outside the class). If the definition is missing, the linker will not find a memory address for that symbol when trying to build the executable, resulting in a linker error.",
        "topic": "Static Members"
    },
    {
        "question": "Which of the following describes 'Deep Copy'?",
        "options": [
            "Copying only the addresses stored in pointers.",
            "Allocating new memory for the destination object and copying the actual data from the source memory.",
            "Using a while loop to copy variables one by one.",
            "Storing the copy in a different binary file."
        ],
        "correct": 1,
        "explanation": "Deep copying ensures that the new object has its own independent copy of dynamic resources. This prevents 'Aliasing' (where two objects share the same heap memory), which is the primary cause of double-free crashes in C++.",
        "topic": "Memory Management"
    },
    {
        "question": "When overloading the '==' operator, what is the most logical return type?",
        "options": [
            "int",
            "void",
            "bool",
            "double"
        ],
        "correct": 2,
        "explanation": "Since the equality operator is used to test a condition (Are these two objects equal?), it should return 'true' or 'false'. In C++, the 'bool' data type is the semantic standard for such logical results.",
        "topic": "Operator Overloading"
    },
    {
        "question": "Why would a programmer use a 'Static' counter in a class constructor?",
        "options": [
            "To count how many times a single object is modified.",
            "To keep track of the total number of objects of that class currently in existence.",
            "To increase the memory used by each object.",
            "To prevent more than one object from being created."
        ],
        "correct": 1,
        "explanation": "Because a static variable is shared, incrementing it in the constructor and decrementing it in the destructor allows the class to maintain a real-time count of all active instances. Individual (non-static) variables cannot do this because they are unique to each object.",
        "topic": "Static Members"
    },
    {
        "question": "In the statement 'obj2 = obj1;', which C++ function is invoked?",
        "options": [
            "Copy Constructor",
            "Assignment Operator Function",
            "Default Constructor",
            "Destructor"
        ],
        "correct": 1,
        "explanation": "Since both objects were already defined before this line, this is an assignment operation. C++ calls the 'operator=' function. If it is not overloaded by the user, the compiler performs a default member-wise copy.",
        "topic": "Classes"
    },
    {
        "question": "Which of the following is true regarding 'Friend' classes?",
        "options": [
            "A friend class can access private members, but its own members are still hidden from the original class.",
            "Friend classes are used to implement private inheritance.",
            "If Class A is a friend of Class B, Class B is automatically a friend of Class A.",
            "Friend classes can only have one member function."
        ],
        "correct": 0,
        "explanation": "Friendship is one-way. If B declares A as a friend, A can see B's private members. However, B still cannot see A's private members unless A explicitly returns the favor by declaring B as a friend as well.",
        "topic": "Friendship"
    },
    {
        "question": "What is 'Member-wise' assignment?",
        "options": [
            "Assigning every member of a class to zero.",
            "The default behavior where each data member of one object is copied to the corresponding member of another object.",
            "Only assigning the public members of a class.",
            "Using a pointer to assign a value."
        ],
        "correct": 1,
        "explanation": "Member-wise assignment is the built-in logic the compiler uses when the '=' operator is not overloaded. It works well for simple data but fails for classes managing dynamic memory (pointers).",
        "topic": "Classes"
    },
    {
        "question": "Can the 'this' pointer be used in a static member function?",
        "options": [
            "Yes, it always points to the first object created.",
            "No, because static functions are not associated with any specific object instance.",
            "Yes, but only if the function is public.",
            "Only if the class has no data members."
        ],
        "correct": 1,
        "explanation": "The 'this' pointer represents the address of the object that called the function. Since static functions are called on the class level (not by an object), there is no 'current object' to point to.",
        "topic": "This Pointer"
    },
    {
        "question": "Which operator is typically overloaded to allow custom objects to be printed using 'cout << obj'?",
        "options": [
            "The assignment operator (=)",
            "The stream insertion operator (<<)",
            "The stream extraction operator (>>)",
            "The plus operator (+)"
        ],
        "correct": 1,
        "explanation": "To make 'cout' recognize a user-defined class, the '<<' operator must be overloaded. This usually requires a friend function because the left-hand operand is an 'ostream' object, not an object of the user's class.",
        "topic": "Operator Overloading"
    },
    {
        "question": "What is the effect of 'const' in 'void display() const;'?",
        "options": [
            "The function returns a constant value.",
            "The function cannot modify any data members of the calling object.",
            "The function can only be called once.",
            "The function is stored in read-only memory."
        ],
        "correct": 1,
        "explanation": "This is a 'constant member function'. It treats the 'this' pointer as a pointer to a constant object, preventing any code inside the function from changing the object's data. This is essential for maintaining 'const correctness'.",
        "topic": "Member Functions"
    },
    {
        "question": "In the context of the CS201 handouts, what is the 'Heap'?",
        "options": [
            "A storage area for local variables.",
            "The segment of memory used for dynamic allocation during runtime.",
            "A collection of all static variables.",
            "The physical hard drive space used for paging."
        ],
        "correct": 1,
        "explanation": "The Heap (or Free Store) is the memory pool from which 'new' allocates space. Unlike the stack, memory here stays allocated until explicitly freed by 'delete'.",
        "topic": "Memory Management"
    },
    {
        "question": "Why is the return by reference ('return *this;') important in an assignment operator?",
        "options": [
            "To prevent the object from being deleted.",
            "To allow for assignment chaining like 'x = y = z;'.",
            "To make the code run on 64-bit systems.",
            "To automatically call the destructor."
        ],
        "correct": 1,
        "explanation": "Chaining works right-to-left. 'y = z' executes first; if it returns a reference to 'y', then the next operation becomes 'x = (result of y=z)', allowing the value to flow through the entire chain.",
        "topic": "Operator Overloading"
    },
    {
        "question": "A static data member must be initialized ________.",
        "options": [
            "In the constructor of the class.",
            "Outside the class definition, usually in a source file.",
            "Inside the main function only.",
            "Inside the class braces using the '=' sign."
        ],
        "correct": 1,
        "explanation": "Static members are defined globally (though scoped to the class). Their initialization happens once at the file level to ensure the linker provides a single memory location for all objects to share.",
        "topic": "Static Members"
    },
    {
        "question": "What is the primary motivation for using 'Templates' in C++ programming?",
        "options": [
            "To increase the execution speed of the program by bypassing the compiler.",
            "To write generic code that can work with different data types without rewriting the same logic.",
            "To encrypt the source code so it cannot be read by other programmers.",
            "To allow a function to return multiple different data types simultaneously."
        ],
        "correct": 1,
        "explanation": "Templates are the foundation of 'Generic Programming'. They allow a programmer to define a function or a class once with a placeholder type (like 'T') and then use it for integers, floats, or custom objects. This significantly reduces code redundancy and makes maintenance easier, as a single fix in the template applies to all data types used.",
        "topic": "Template Basics"
    },
    {
        "question": "Which keyword is mandatory when declaring a template function or class in C++?",
        "options": [
            "generic",
            "type",
            "template",
            "placeholder"
        ],
        "correct": 2,
        "explanation": "The 'template' keyword tells the compiler that the following code block is a template. It is usually followed by a template parameter list in angle brackets, such as <class T> or <typename T>. This informs the compiler that 'T' is a placeholder for a data type that will be specified later.",
        "topic": "Template Syntax"
    },
    {
        "question": "In the declaration 'template <class T>', what does 'T' represent?",
        "options": [
            "A constant integer value used for loop control.",
            "A formal parameter representing a generic data type.",
            "A pointer to the system stack.",
            "A specific library included from the disk."
        ],
        "correct": 1,
        "explanation": "'T' is a conventional name for a template parameter (though any valid identifier can be used). It acts as a placeholder for a data type. When the template function is called with a specific type (like int), the compiler replaces 'T' with 'int' to generate the actual machine code.",
        "topic": "Template Parameters"
    },
    {
        "question": "Which of the following describes the 'Instantiation' of a template?",
        "options": [
            "The process of deleting a template from memory.",
            "The process where the compiler generates a specific version of a function or class for a particular data type.",
            "The act of renaming a template to avoid linker errors.",
            "Converting a template into a global variable."
        ],
        "correct": 1,
        "explanation": "Templates themselves are not code; they are 'recipes' for code. Instantiation occurs when the compiler sees a template being used with a specific type (e.g., 'add<int>(5, 3)'). The compiler then 'instantiates' a real function by replacing the placeholder with the actual type. This happens at compile-time.",
        "topic": "Template Instantiation"
    },
    {
        "question": "What is the primary difference between 'Function Templates' and 'Class Templates'?",
        "options": [
            "Function templates are for math; class templates are for strings.",
            "Function templates define generic algorithms; class templates define generic data structures.",
            "Function templates must be static; class templates must be dynamic.",
            "There is no difference; the terms are interchangeable."
        ],
        "correct": 1,
        "explanation": "Function templates allow you to write generic functions (like sorting or swapping) that work on any type. Class templates allow you to create generic containers or data structures (like a Stack or a Linked List) that can store elements of any data type specified by the user.",
        "topic": "Function vs Class Templates"
    },
    {
        "question": "When calling a template function, the process where the compiler determines the data type from the arguments provided is called:",
        "options": [
            "Type Casting",
            "Template Argument Deduction",
            "Dynamic Binding",
            "Encapsulation"
        ],
        "correct": 1,
        "explanation": "In many cases, you don't need to specify the type explicitly (e.g., 'myFunc<int>(a, b)'). If you just call 'myFunc(a, b)', the compiler looks at the types of 'a' and 'b' and 'deduces' what 'T' should be. This makes template usage more seamless and similar to calling regular functions.",
        "topic": "Argument Deduction"
    },
    {
        "question": "Which of the following is a potential disadvantage of using templates (often called 'Code Bloat')?",
        "options": [
            "The code becomes slower to execute.",
            "The compiler generates a separate copy of the code for every distinct data type used, increasing the executable size.",
            "Templates can only be used with the 'int' data type.",
            "Templates prevent the use of pointers."
        ],
        "correct": 1,
        "explanation": "Because the compiler creates a unique instance of the function/class for every data type you use (int, double, char, etc.), the final binary file (.exe) can become significantly larger. This is known as code bloat. However, modern systems usually have enough memory to handle this without issue.",
        "topic": "Template Efficiency"
    },
    {
        "question": "How do you declare a template class 'Stack' that can hold elements of any type?",
        "options": [
            "class Stack <T> { ... };",
            "template <class T> class Stack { ... };",
            "generic Stack { T elements; };",
            "template Stack(T) { ... };"
        ],
        "correct": 1,
        "explanation": "The correct syntax for a class template is to place the template prefix immediately before the class definition: 'template <class T> class Name { ... };'. The 'T' can then be used inside the class to define data members, return types, or function parameters.",
        "topic": "Class Templates"
    },
    {
        "question": "What is 'Template Specialization'?",
        "options": [
            "Creating a version of a template that only works on 64-bit systems.",
            "Providing a specific implementation of a template for a particular data type that requires different logic.",
            "Restricting a template so it can only be used by friend classes.",
            "Using a template inside another template."
        ],
        "correct": 1,
        "explanation": "Sometimes a generic algorithm doesn't work for a specific type (e.g., comparing two C-style strings requires 'strcmp' instead of '>'). Template specialization allows the programmer to write a custom version of the template specifically for that type, which the compiler will prefer over the generic one.",
        "topic": "Template Specialization"
    },
    {
        "question": "In the context of the CS201 handouts, which standard library uses templates extensively to provide generic containers like vectors and lists?",
        "options": [
            "Standard Template Library (STL)",
            "Standard Graphics Library (SGL)",
            "Input Output Library (IOL)",
            "Dynamic Memory Library (DML)"
        ],
        "correct": 0,
        "explanation": "The STL is a powerful set of C++ template classes that provide common data structures (vectors, lists, queues) and algorithms (sorting, searching). Because it is built with templates, these containers can store any data type, making the STL highly versatile and a staple of professional C++ development.",
        "topic": "STL"
    },
    {
        "question": "Which of the following can be used interchangeably with 'class' inside a template parameter list?",
        "options": [
            "struct",
            "typename",
            "typedef",
            "typeid"
        ],
        "correct": 1,
        "explanation": "In the parameter list, 'template <class T>' and 'template <typename T>' are functionally identical. 'typename' was introduced later to clarify that 'T' represents a data type, but 'class' remains valid for backward compatibility and is still widely used.",
        "topic": "Template Syntax"
    },
    {
        "question": "Why must template definitions often be placed in header (.h) files rather than separate .cpp files?",
        "options": [
            "Because header files are faster to read.",
            "Because the compiler needs to see the full source code to instantiate the template when it is used in different parts of the program.",
            "Because templates are too small for .cpp files.",
            "Because the linker cannot see code inside .cpp files."
        ],
        "correct": 1,
        "explanation": "Unlike regular functions (where only the prototype is needed), templates require the full implementation to be available at the point of use. If the compiler doesn't have the source code during instantiation, it cannot generate the type-specific version, leading to unresolved external errors at the linking stage.",
        "topic": "Template Compilation"
    },
    {
        "question": "Which of the following describes a 'Non-Type' template parameter?",
        "options": [
            "A parameter that represents a character instead of an integer.",
            "A parameter that is a specific value (like an integer) instead of a data type.",
            "A parameter that is passed by value instead of by reference.",
            "A parameter that is only used by the destructor."
        ],
        "correct": 1,
        "explanation": "Templates can accept values as well as types. For example, 'template <class T, int size> class Array' allows you to specify the array size at compile-time (e.g., 'Array<int, 10>'). The '10' is a non-type parameter that acts as a constant within the class.",
        "topic": "Non-Type Parameters"
    },
    {
        "question": "What is the correct syntax for defining a member function of a template class 'Container' outside the class body?",
        "options": [
            "void Container::func() { ... }",
            "template <class T> void Container<T>::func() { ... }",
            "T Container::func() { ... }",
            "void Container<T>::func() { ... }"
        ],
        "correct": 1,
        "explanation": "When defining template class members externally, you must re-declare the template prefix and specify the template arguments for the class name using the scope resolution operator: 'template <class T> ReturnType ClassName<T>::FunctionName()'.",
        "topic": "Class Templates"
    },
    {
        "question": "If a template class 'Box<T>' is defined, how do you create an instance for storing a 'double'?",
        "options": [
            "Box b = 5.5;",
            "Box(double) b;",
            "Box<double> b;",
            "double Box b;"
        ],
        "correct": 2,
        "explanation": "Unlike template functions (where deduction is possible), template classes usually require the type to be explicitly specified in angle brackets during declaration. 'Box<double> b;' tells the compiler to use the 'double' version of the Box class.",
        "topic": "Class Templates"
    },
    {
        "question": "Can a template function be overloaded with a regular (non-template) function?",
        "options": [
            "No, this causes a signature conflict.",
            "Yes, and the compiler will prefer the regular function if it is an exact match for the arguments.",
            "Yes, but only if the regular function is defined as static.",
            "Only if the template function is defined inside a class."
        ],
        "correct": 1,
        "explanation": "C++ allows mixing templates and regular functions. When a call is made, the compiler looks for the best match. If a regular function exactly matches the argument types, it is chosen over instantiating a new version from a template. This is useful for providing specific logic for certain types.",
        "topic": "Template Overloading"
    },
    {
        "question": "What is the role of 'typename' when referring to a nested type within a template parameter?",
        "options": [
            "It makes the code execute on any operating system.",
            "It tells the compiler that a dependent name is a type and not a static member variable.",
            "It allows the template to be used as a friend.",
            "It is used to delete the template from the heap."
        ],
        "correct": 1,
        "explanation": "Inside a template, the compiler might not know if 'T::SomeName' refers to a sub-type or a variable. Using 'typename T::SomeName' clarifies that it is a type, preventing ambiguity during the first pass of compilation.",
        "topic": "Templates"
    },
    {
        "question": "Which of the following is true regarding 'Static' members in a template class?",
        "options": [
            "Every instance of the template class (e.g., Stack<int> and Stack<char>) shares the same static variable.",
            "Each distinct instantiation (e.g., Stack<int>) has its own separate copy of the static variable.",
            "Static variables cannot be used in template classes.",
            "Static variables in templates are stored on the hard drive."
        ],
        "correct": 1,
        "explanation": "This is a key nuance. 'Stack<int>' and 'Stack<char>' are considered entirely different classes by the compiler. Therefore, the static members of 'Stack<int>' are shared only among all integer stacks, and are separate from those of the character stacks.",
        "topic": "Static Members in Templates"
    },
    {
        "question": "The 'Divide and Conquer' strategy applied to templates means:",
        "options": [
            "Breaking a program into multiple small binary files.",
            "Writing generic logic for the main problem and using specialization for specific cases.",
            "Using as many different data types as possible.",
            "Dividing the memory between the stack and the heap."
        ],
        "correct": 1,
        "explanation": "In a template context, you use the generic template to solve the general case (the 'conquer' part) and use specialization to handle 'special cases' that deviate from the standard logic (the 'divide' part).",
        "topic": "Structured Programming"
    },
    {
        "question": "Which of the following is the correct header for the C++ Standard Template Library's dynamic array?",
        "options": [
            "<array_list>",
            "<vector>",
            "<dynarray>",
            "<list>"
        ],
        "correct": 1,
        "explanation": "The 'vector' is the most widely used STL container. It represents a dynamic array that can grow or shrink in size and provides the efficiency of contiguous memory storage while using templates to handle any data type.",
        "topic": "STL Containers"
    },
    {
        "question": "When a template is instantiated for a data type, where is the resulting code stored?",
        "options": [
            "In the Code Segment of the executable file.",
            "In the Data Segment.",
            "In the Heap memory.",
            "In a separate .txt file."
        ],
        "correct": 0,
        "explanation": "Once a template is instantiated, it becomes regular machine code. Like all other functions, this executable code is placed in the 'Code Segment' (or Text Segment) of the final program.",
        "topic": "Memory Layout"
    },
    {
        "question": "What happens if you try to use a template function with a data type that doesn't support an operator used in the template (e.g., using '+' in a template for a class that hasn't overloaded '+')?",
        "options": [
            "The compiler will ignore the error and use 0.",
            "The compiler will generate an error during instantiation.",
            "The program will crash only when that specific line is executed.",
            "The compiler will automatically create the '+' operator for that class."
        ],
        "correct": 1,
        "explanation": "Template code is checked for syntax errors when defined, but it is only checked for 'logical validity' with a specific type during instantiation. If 'T' doesn't support an operation used in the template body, the compiler will fail to build the program.",
        "topic": "Template Instantiation"
    },
    {
        "question": "Which of the following is NOT an advantage of templates?",
        "options": [
            "Type safety is maintained compared to using void pointers.",
            "Development time is reduced as algorithms are written once.",
            "Executable size is always reduced.",
            "The code is more portable and reusable."
        ],
        "correct": 2,
        "explanation": "Actually, templates can *increase* executable size due to code bloat (multiple instantiations). The other options—type safety, reduced development time, and reusability—are the primary advantages of the template system.",
        "topic": "Template Benefits"
    },
    {
        "question": "Can a template class inherit from a non-template class?",
        "options": [
            "No, templates can only inherit from other templates.",
            "Yes, this is a common way to provide generic behavior to a specific base structure.",
            "Only if the base class is declared as static.",
            "Yes, but the base class must be defined in the same file."
        ],
        "correct": 1,
        "explanation": "Templates follow standard inheritance rules. A template class can inherit from a regular class, and a regular class can inherit from a specific instantiation of a template (e.g., 'class MyIntStack : public Stack<int>').",
        "topic": "Inheritance"
    },
    {
        "question": "What is the primary technical function of 'Generic Programming'?",
        "options": [
            "To write programs that run on any operating system.",
            "To write code that focuses on the logic of the algorithm rather than the data types it operates on.",
            "To use as few variables as possible.",
            "To replace Object-Oriented Programming entirely."
        ],
        "correct": 1,
        "explanation": "Generic programming aims to abstract algorithms. By using templates, you separate 'what to do' (the logic) from 'what to do it to' (the data type). This makes your code more like a mathematical formula that can be applied to any number.",
        "topic": "Programming Paradigms"
    },
    {
        "question": "In the statement 'vector<int> myVec(5);', what does '5' represent?",
        "options": [
            "The value to be stored in the first element.",
            "The initial capacity or number of elements in the vector.",
            "The maximum size the vector can ever reach.",
            "The index of the vector."
        ],
        "correct": 1,
        "explanation": "For an STL vector, the constructor can take an integer argument that specifies the initial number of elements to allocate. In this case, 'myVec' will start with 5 integer elements, all initialized to zero.",
        "topic": "STL Containers"
    },
    {
        "question": "How many template parameters can a single template have?",
        "options": [
            "Exactly one.",
            "Up to two.",
            "As many as the programmer needs, separated by commas.",
            "Only as many as the CPU has registers."
        ],
        "correct": 2,
        "explanation": "Templates are not limited to one type. You can have multiple types and non-type parameters. For example, 'template <class K, class V> class Map' uses two placeholders for Key and Value types.",
        "topic": "Template Syntax"
    },
    {
        "question": "What does the compiler use to identify a template specialization in the code?",
        "options": [
            "The 'special' keyword.",
            "Empty angle brackets 'template <>' before the specialized definition.",
            "A comment saying '// Specialization'.",
            "The 'static' keyword."
        ],
        "correct": 1,
        "explanation": "To define a full specialization, you use the 'template <>' prefix. This tells the compiler that you are providing a specific version for a previously declared template. For example: 'template <> class Box<char> { ... };'.",
        "topic": "Template Specialization"
    },
    {
        "question": "In C++, 'Templates' are an example of which type of binding?",
        "options": [
            "Early (Static) Binding",
            "Late (Dynamic) Binding",
            "Recursive Binding",
            "L-value Binding"
        ],
        "correct": 0,
        "explanation": "Because the compiler generates the specific code for the types during the compilation phase, templates are a form of static (early) binding. This makes template code just as fast as if you had written the type-specific code by hand.",
        "topic": "Binding"
    },
    {
        "question": "Which of the following is true regarding 'Default' template arguments?",
        "options": [
            "Default arguments are not allowed in templates.",
            "You can provide a default data type (e.g., <class T = int>) that is used if no type is specified.",
            "Default arguments can only be used for the 'char' type.",
            "Default arguments are only used when the program crashes."
        ],
        "correct": 1,
        "explanation": "Similar to function parameters, templates can have default types. 'template <class T = int> class MyClass' allows a user to declare 'MyClass<> obj;' which the compiler will treat as 'MyClass<int>'.",
        "topic": "Template Syntax"
    },
    {
        "question": "Which of the following best describes the 'Is-A' relationship in Object-Oriented Programming?",
        "options": [
            "A class containing an object of another class as a member.",
            "A derived class inheriting the characteristics and behaviors of a base class.",
            "A function that returns an object of a different class type.",
            "A pointer that points to a specific memory address on the heap."
        ],
        "correct": 1,
        "explanation": "The 'Is-A' relationship is the conceptual foundation of Inheritance. For example, if a 'Car' class inherits from a 'Vehicle' class, we say 'A Car is a Vehicle'. This allows the Car to reuse the code of the Vehicle class. In contrast, 'Composition' (Option 0) represents a 'Has-A' relationship.",
        "topic": "Inheritance Basics"
    },
    {
        "question": "When a class 'Derived' inherits from class 'Base' using 'public' inheritance, what happens to the 'protected' members of the Base class?",
        "options": [
            "They become private in the Derived class.",
            "They become public in the Derived class.",
            "They remain protected in the Derived class.",
            "They are not inherited and cannot be accessed."
        ],
        "correct": 2,
        "explanation": "In public inheritance, the access levels are preserved as much as possible: public remains public, and protected remains protected. Protected members are unique because they are accessible within the class itself and any class derived from it, but they remain hidden from the 'outside' world (non-member functions).",
        "topic": "Access Specifiers in Inheritance"
    },
    {
        "question": "In C++, which member of a base class is NEVER inherited by a derived class?",
        "options": [
            "Public data members.",
            "Constructors and Destructors.",
            "Protected member functions.",
            "Static variables."
        ],
        "correct": 1,
        "explanation": "While a derived class inherits all data members and functions, it does not inherit the base class's constructors, destructors, or assignment operators. However, the derived class's constructor is required to call a base class constructor to properly initialize the inherited portion of the object.",
        "topic": "Inheritance"
    },
    {
        "question": "What is the order of execution for constructors in a derived class relationship?",
        "options": [
            "The derived class constructor executes first, then the base class constructor.",
            "The base class constructor executes first, then the derived class constructor.",
            "They execute simultaneously using multi-threading.",
            "Only the derived class constructor executes."
        ],
        "correct": 1,
        "explanation": "Logic dictates that the 'foundation' (the base class) must be built before the 'specialization' (the derived class). Therefore, when an object of a derived class is created, C++ calls the base class constructor first, followed by the derived class constructor.",
        "topic": "Constructor Execution"
    },
    {
        "question": "Which keyword is used in a derived class to explicitly call a specific constructor of the base class?",
        "options": [
            "super",
            "base",
            "The base class name in the initialization list.",
            "this"
        ],
        "correct": 2,
        "explanation": "Unlike Java or C# which use 'super' or 'base', C++ requires the programmer to use the base class name followed by arguments in the constructor's initialization list (e.g., `Derived() : Base(10) { ... }`). If this is omitted, the compiler attempts to call the base class's default (parameterless) constructor.",
        "topic": "Base Class Initialization"
    },
    {
        "question": "What happens to the 'private' members of a base class during inheritance?",
        "options": [
            "They become public in the derived class.",
            "They are inherited but remain inaccessible to the derived class functions.",
            "They are not inherited at all.",
            "They become protected in the derived class."
        ],
        "correct": 1,
        "explanation": "Private members are strictly local to the class that defines them. They are physically part of the derived class object (memory is allocated for them), but the derived class's member functions cannot access them directly. To interact with them, the derived class must use public or protected member functions provided by the base class.",
        "topic": "Access Specifiers"
    },
    {
        "question": "In 'private' inheritance (class Derived : private Base), what do the public and protected members of the Base class become in the Derived class?",
        "options": [
            "They remain public and protected.",
            "They all become private.",
            "They all become protected.",
            "They are deleted."
        ],
        "correct": 1,
        "explanation": "Private inheritance is a restrictive form of inheritance. It means 'is-implemented-in-terms-of'. Every member inherited from the base (whether it was public or protected) is downgraded to 'private' in the derived class, effectively cutting off any further inheritance of those features by subsequent classes.",
        "topic": "Inheritance Types"
    },
    {
        "question": "Which of the following is the correct syntax for a class 'Manager' to inherit publicly from class 'Employee'?",
        "options": [
            "class Manager : Employee { };",
            "class Manager : public Employee { };",
            "class Manager inherits Employee { };",
            "class Manager extends Employee { };"
        ],
        "correct": 1,
        "explanation": "The colon (:) is the symbol for inheritance in C++. It is followed by an access specifier (like public) and the name of the base class. Option 0 would result in private inheritance by default, which is rarely what is intended in standard polymorphic design.",
        "topic": "Inheritance Syntax"
    },
    {
        "question": "What is 'Multiple Inheritance'?",
        "options": [
            "A single class acting as a base for many different derived classes.",
            "A class inheriting from more than one base class.",
            "An object containing multiple pointers to the same class.",
            "A constructor calling multiple functions."
        ],
        "correct": 1,
        "explanation": "Multiple inheritance occurs when a derived class has more than one direct base class (e.g., `class Amphibian : public LandVehicle, public WaterVehicle`). While powerful, it can lead to complexity and ambiguity issues, such as the 'Diamond Problem'.",
        "topic": "Multiple Inheritance"
    },
    {
        "question": "When a derived class object is destroyed, what is the order of execution for the destructors?",
        "options": [
            "Base first, then Derived.",
            "Derived first, then Base.",
            "Only the Derived destructor is called.",
            "They are called in a random order based on memory layout."
        ],
        "correct": 1,
        "explanation": "Destruction happens in the exact reverse order of construction. The 'specialized' layer (Derived) is cleaned up first, followed by the 'foundational' layer (Base). This ensures that the base class resources are still available while the derived class is performing its own cleanup.",
        "topic": "Destructor Execution"
    },
    {
        "question": "What is the 'Diamond Problem' in C++ inheritance?",
        "options": [
            "A memory leak caused by too many pointers.",
            "An ambiguity that arises when a class inherits from two classes that both inherit from the same base class.",
            "The difficulty of converting a class into a binary file.",
            "A syntax error caused by missing braces."
        ],
        "correct": 1,
        "explanation": "The Diamond Problem occurs in multiple inheritance. If Class D inherits from B and C, and both B and C inherit from A, Class D ends up with two copies of Class A's members. This creates ambiguity when D tries to access a member of A. This is solved in C++ using 'Virtual Inheritance'.",
        "topic": "Multiple Inheritance"
    },
    {
        "question": "Which access specifier is specifically designed to allow access to derived classes while maintaining privacy from the rest of the program?",
        "options": [
            "public",
            "private",
            "protected",
            "internal"
        ],
        "correct": 2,
        "explanation": "The 'protected' specifier is the 'middle ground'. It acts like 'private' in that it blocks access from the outside (like main()), but it acts like 'public' for derived classes, allowing them to use the base class variables directly. This is essential for the 'Is-A' relationship to function efficiently.",
        "topic": "Access Specifiers"
    },
    {
        "question": "In the context of the CS201 curriculum, what is 'Method Overriding'?",
        "options": [
            "A function with the same name but different parameters in the same class.",
            "A derived class providing a new implementation for a function that already exists in the base class with the same signature.",
            "A function that calls itself recursively.",
            "A function that is declared as static."
        ],
        "correct": 1,
        "explanation": "Overriding allows a derived class to provide a specific version of a behavior. For example, 'Dog' might override the 'makeSound()' function of 'Animal' to produce a bark instead of a generic sound. For true polymorphism, the base function should be marked as 'virtual'.",
        "topic": "Function Overriding"
    },
    {
        "question": "Which of the following describes 'Single Inheritance'?",
        "options": [
            "A class that has only one data member.",
            "A derived class that inherits from exactly one base class.",
            "A class that cannot be used to create objects.",
            "A function that is only called once."
        ],
        "correct": 1,
        "explanation": "Single inheritance is the simplest form of inheritance where one class is derived from one parent class. This forms a linear hierarchy and is the most common type of inheritance used in software design.",
        "topic": "Inheritance Types"
    },
    {
        "question": "In C++, 'Multi-level Inheritance' refers to:",
        "options": [
            "A class inheriting from multiple base classes.",
            "A chain of inheritance where a class is derived from another derived class (A -> B -> C).",
            "Using multiple pointers to access a single object.",
            "An object that contains multiple constructors."
        ],
        "correct": 1,
        "explanation": "Multi-level inheritance occurs when a derived class becomes the base class for another class. For example, a 'SportsCar' inherits from 'Car', which in turn inherits from 'Vehicle'. The 'SportsCar' possesses the features of both 'Car' and 'Vehicle'.",
        "topic": "Multi-level Inheritance"
    },
    {
        "question": "What is the primary technical benefit of using 'Inheritance'?",
        "options": [
            "It makes the program run faster on modern CPUs.",
            "It promotes code reusability and establishes a natural hierarchy.",
            "It automatically deletes unused variables.",
            "It prevents the use of pointers in the program."
        ],
        "correct": 1,
        "explanation": "Inheritance allows programmers to reuse existing code. Instead of writing common features for 'Manager' and 'Programmer' from scratch, both can inherit from a common 'Employee' class. This reduces errors and makes the system easier to maintain.",
        "topic": "OOP Benefits"
    },
    {
        "question": "Can a derived class access the 'private' data members of its base class?",
        "options": [
            "Yes, inheritance gives full access to all members.",
            "No, private members are only accessible by the base class itself.",
            "Only if the derived class is declared as static.",
            "Only if the 'friend' keyword is used in the derived class."
        ],
        "correct": 1,
        "explanation": "Private members are the most restricted. Even a child class cannot see its parent's private data. If a parent wants to share data with its children but keep it hidden from everyone else, it should use the 'protected' specifier.",
        "topic": "Access Specifiers"
    },
    {
        "question": "What happens if a derived class does not provide its own constructor?",
        "options": [
            "The program will fail to compile.",
            "The compiler provides a default constructor that calls the base class's default constructor.",
            "The base class constructor is skipped.",
            "All members are initialized to NULL."
        ],
        "correct": 1,
        "explanation": "C++ always ensures that an object is properly constructed. If you don't write a constructor for the derived class, the compiler creates one. This implicit constructor will automatically call the parent's default constructor to ensure the base portion of the object is ready.",
        "topic": "Constructors"
    },
    {
        "question": "In 'public' inheritance, what does a 'public' member of the base class become in the derived class?",
        "options": [
            "private",
            "protected",
            "public",
            "It is not inherited."
        ],
        "correct": 2,
        "explanation": "Public inheritance is meant to preserve the interface. Therefore, anything that was public in the parent (accessible to everyone) remains public in the child.",
        "topic": "Access Specifiers"
    },
    {
        "question": "The 'protected' access specifier provides less privacy than ________ but more privacy than ________.",
        "options": [
            "private, public",
            "public, private",
            "static, extern",
            "void, int"
        ],
        "correct": 0,
        "explanation": "Protected is the 'in-between' level. It is more open than 'private' (because children can see it) but more closed than 'public' (because the general public cannot see it).",
        "topic": "Access Specifiers"
    },
    {
        "question": "Which of the following describes 'Hierarchical Inheritance'?",
        "options": [
            "A chain of inheritance (A -> B -> C).",
            "Multiple classes inheriting from a single base class.",
            "A class inheriting from multiple base classes.",
            "A class that contains a pointer to itself."
        ],
        "correct": 1,
        "explanation": "Hierarchical inheritance is when many subclasses descend from a single superclass. For example, 'Triangle', 'Square', and 'Circle' all inheriting from 'Shape'.",
        "topic": "Inheritance Types"
    },
    {
        "question": "Why is 'Composition' (Has-A) sometimes preferred over 'Inheritance' (Is-A)?",
        "options": [
            "Composition is faster to execute.",
            "Composition provides better encapsulation and flexibility without the strict binding of inheritance.",
            "Composition uses less RAM.",
            "Composition is the only way to use the 'new' operator."
        ],
        "correct": 1,
        "explanation": "While inheritance is powerful, it is a very 'strong' relationship. Composition is more flexible because you can change the contained object at runtime or mix different types of objects without being locked into a rigid class hierarchy.",
        "topic": "OOP Design"
    },
    {
        "question": "When calling a base class constructor from a derived class, where does the call appear?",
        "options": [
            "Inside the body of the derived constructor.",
            "In the initialization list of the derived constructor.",
            "In the destructor of the base class.",
            "In the main() function."
        ],
        "correct": 1,
        "explanation": "To pass parameters to a parent constructor, you must use the initializer list: `Derived(int x) : Base(x) { ... }`. By the time the code inside the `{ }` of the Derived constructor runs, the Base class must already be finished.",
        "topic": "Constructors"
    },
    {
        "question": "What is 'Reusability' in the context of inheritance?",
        "options": [
            "Deleting a variable and creating it again.",
            "The ability to use existing code from a base class in a derived class without rewriting it.",
            "Running the program multiple times.",
            "Using the same pointer to point to different addresses."
        ],
        "correct": 1,
        "explanation": "Reusability is the 'Holy Grail' of software engineering. Inheritance allows you to write the common logic once (in the base class) and reuse it across many different derived classes, saving time and effort.",
        "topic": "OOP Benefits"
    },
    {
        "question": "Which of the following is true about 'Protected' inheritance (class Derived : protected Base)?",
        "options": [
            "Public members of the base become protected in the derived class.",
            "Protected members of the base become private in the derived class.",
            "All members become public.",
            "Nothing is inherited."
        ],
        "correct": 0,
        "explanation": "In protected inheritance, the 'ceiling' for access is 'protected'. Anything that was public is 'pushed down' to protected. This ensures that only the derived class and its future children can see the inherited members.",
        "topic": "Inheritance Types"
    },
    {
        "question": "In a derived class, if you define a function with the exact same name and parameters as a base class function, what happens when you call that function on a derived object?",
        "options": [
            "The base class version is called.",
            "The derived class version is called (the base version is hidden).",
            "The program crashes due to ambiguity.",
            "Both versions are called simultaneously."
        ],
        "correct": 1,
        "explanation": "This is called 'Function Hiding' or 'Overriding'. The local (more specific) version in the derived class takes priority over the inherited (more general) version from the base class.",
        "topic": "Function Overriding"
    },
    {
        "question": "What is the purpose of 'Virtual Inheritance' in C++?",
        "options": [
            "To allow the program to run in a virtual machine.",
            "To resolve ambiguities in the Diamond Problem by ensuring only one copy of a base class is inherited.",
            "To make the class run faster.",
            "To prevent any other class from inheriting from it."
        ],
        "correct": 1,
        "explanation": "Virtual inheritance (`class B : virtual public A`) ensures that if multiple paths exist to the same base class, only one 'shared' instance of the base class exists in the final derived object, thus solving the Diamond Problem.",
        "topic": "Multiple Inheritance"
    },
    {
        "question": "In the C++ memory layout, a 'Derived' object contains:",
        "options": [
            "Only its own new data members.",
            "Only the data members of the base class.",
            "The data members of the base class followed by its own data members.",
            "Nothing; it only contains pointers to functions."
        ],
        "correct": 2,
        "explanation": "When you create a child object, the computer allocates a single block of memory. This block contains all the data from the parent first, followed by the new data added by the child. This is why a pointer to a child can be safely treated as a pointer to a parent.",
        "topic": "Memory Management"
    },
    {
        "question": "Which of the following is NOT a type of inheritance supported by C++?",
        "options": [
            "Single Inheritance",
            "Multiple Inheritance",
            "Circular Inheritance (A inherits from B, B inherits from A)",
            "Multi-level Inheritance"
        ],
        "correct": 2,
        "explanation": "Inheritance must be a 'Directed Acyclic Graph'. You cannot have a loop where parents are children of their own children. This would create an infinite loop of construction and is prohibited by the compiler.",
        "topic": "Inheritance Types"
    },
    {
        "question": "In C++, the 'Base' class is also known as the ________ and the 'Derived' class is also known as the ________.",
        "options": [
            "Superclass, Subclass",
            "Child class, Parent class",
            "Pointer class, Variable class",
            "Static class, Dynamic class"
        ],
        "correct": 0,
        "explanation": "These are the standard academic terms. 'Super' implies being 'above' in the hierarchy (parent), and 'Sub' implies being 'below' (child).",
        "topic": "OOP Terminology"
    },
    {
        "question": "What is the primary technical purpose of 'Polymorphism' in C++?",
        "options": [
            "To allow a single function name to handle multiple data types at compile-time only.",
            "To allow a single interface to represent different underlying forms (objects) at runtime.",
            "To hide the implementation details of a class from the user.",
            "To automatically manage the allocation and deallocation of heap memory."
        ],
        "correct": 1,
        "explanation": "Polymorphism, meaning 'many forms', allows a programmer to treat objects of different classes (within the same hierarchy) through a common base class pointer. This enables the program to decide which specific function to execute at runtime based on the actual object type, rather than the pointer type. This is the cornerstone of extensible software design.",
        "topic": "Polymorphism"
    },
    {
        "question": "Which keyword is essential in a base class function declaration to enable 'Dynamic Binding' (Runtime Polymorphism)?",
        "options": [
            "static",
            "friend",
            "virtual",
            "inline"
        ],
        "correct": 2,
        "explanation": "The 'virtual' keyword tells the C++ compiler that the function should be subject to dynamic binding. When a function is virtual, the compiler doesn't link the function call at compile-time; instead, it looks at the 'V-Table' of the object at runtime to find the correct overridden version in the derived class.",
        "topic": "Virtual Functions"
    },
    {
        "question": "What is a 'Pure Virtual Function'?",
        "options": [
            "A function that is written in assembly language for speed.",
            "A virtual function with no implementation in the base class, declared with '= 0'.",
            "A function that can only be called by a static member function.",
            "A function that is shared by all classes in a program."
        ],
        "correct": 1,
        "explanation": "A pure virtual function is a placeholder in a base class (e.g., `virtual void draw() = 0;`). It forces any non-abstract derived class to provide its own implementation of that function. This ensures that all derived objects follow a specific interface but allows each to define its own specific behavior.",
        "topic": "Abstract Classes"
    },
    {
        "question": "A class that contains at least one 'Pure Virtual Function' is technically known as a/an:",
        "options": [
            "Concrete Class",
            "Static Class",
            "Abstract Base Class",
            "Friend Class"
        ],
        "correct": 2,
        "explanation": "An Abstract Base Class (ABC) cannot be used to instantiate objects. Its sole purpose is to act as a parent for other classes. If you attempt to create an object of an ABC, the compiler will generate an error because the class is 'incomplete' due to the pure virtual function.",
        "topic": "Abstract Classes"
    },
    {
        "question": "What is the consequence of failing to provide an implementation for an inherited pure virtual function in a derived class?",
        "options": [
            "The derived class also becomes an abstract class and cannot be instantiated.",
            "The compiler automatically provides a default empty implementation.",
            "The program will crash during the linking phase.",
            "The function will return a value of zero by default."
        ],
        "correct": 0,
        "explanation": "If a child class does not 'override' and implement the pure virtual functions of its parent, it 'inherits' the abstract nature of the parent. To create a 'Concrete Class' (one that can have objects), every pure virtual function in the hierarchy must eventually be implemented.",
        "topic": "Inheritance and Abstraction"
    },
    {
        "question": "In the context of the CS201 handouts, what is the 'V-Table' (Virtual Table)?",
        "options": [
            "A table in a database that stores user credentials.",
            "A hidden array of function pointers created by the compiler for classes with virtual functions.",
            "A physical component of the RAM used for video rendering.",
            "A list of all global variables used in a program."
        ],
        "correct": 1,
        "explanation": "The V-Table is the mechanism C++ uses to achieve runtime polymorphism. Each class with virtual functions has a V-Table containing the addresses of those functions. Each object of that class contains a hidden 'vptr' (virtual pointer) that points to the V-Table, allowing the program to find the right function at execution time.",
        "topic": "Virtual Functions"
    },
    {
        "question": "Which of the following describes 'Early Binding' (Static Binding)?",
        "options": [
            "The compiler matches a function call with a function definition at compile-time.",
            "The program chooses the function at runtime based on user input.",
            "Linking a program to a website for updates.",
            "Loading the program into the CPU registers early."
        ],
        "correct": 0,
        "explanation": "Early binding occurs with regular (non-virtual) functions and overloaded functions. The decision of which code to run is made by the compiler before the program ever starts. This is faster than dynamic binding but less flexible for polymorphic behavior.",
        "topic": "Binding"
    },
    {
        "question": "Why is it highly recommended to make the 'Destructor' virtual in a base class that has virtual functions?",
        "options": [
            "To speed up the deletion of objects.",
            "To ensure that the derived class destructor is called when deleting an object through a base class pointer.",
            "To prevent the use of the 'delete' keyword.",
            "To allow the destructor to have parameters."
        ],
        "correct": 1,
        "explanation": "If the base destructor is not virtual, deleting a derived object through a base pointer (e.g., `Base *p = new Derived(); delete p;`) will only call the base destructor. This leads to a memory leak because the derived part of the object is never cleaned up. Making it virtual ensures the full chain of destructors is executed.",
        "topic": "Virtual Destructors"
    },
    {
        "question": "Can a 'Constructor' be declared as virtual in C++?",
        "options": [
            "Yes, to allow derived classes to initialize the base class differently.",
            "No, because an object's type must be fully known during its creation.",
            "Only if the class has no data members.",
            "Only if the class is a friend of the main function."
        ],
        "correct": 1,
        "explanation": "Virtual functions depend on the existence of a 'V-Table' and an object. Since the object is not fully 'born' yet during the constructor call, virtual mechanics cannot work. Therefore, C++ does not support virtual constructors.",
        "topic": "Virtual Functions"
    },
    {
        "question": "In a polymorphic call, such as `shapePtr->draw();`, where `shapePtr` is a `Shape*` pointing to a `Circle` object, which version of `draw()` is executed if it is virtual?",
        "options": [
            "The Shape version.",
            "The Circle version.",
            "Both versions sequentially.",
            "Neither; it results in a syntax error."
        ],
        "correct": 1,
        "explanation": "Because the function is virtual, the program performs dynamic binding. It ignores the type of the pointer (`Shape*`) and looks at the type of the actual object being pointed to (`Circle`). It then executes the `draw()` function defined in the `Circle` class.",
        "topic": "Polymorphism"
    },
    {
        "question": "What is the return type of a 'Pure Virtual Function'?",
        "options": [
            "It must always be void.",
            "It can be any valid C++ data type.",
            "It must be an integer (0 or 1).",
            "It cannot have a return type."
        ],
        "correct": 1,
        "explanation": "The '= 0' syntax refers to the implementation (the lack thereof), not the return type. A pure virtual function can return an int, a float, an object, or void, just like a regular function.",
        "topic": "Abstract Classes"
    },
    {
        "question": "Which of the following is true about 'Static' member functions and the 'virtual' keyword?",
        "options": [
            "Static functions are always virtual by default.",
            "Static functions cannot be declared as virtual.",
            "Static functions can only be virtual if they are private.",
            "Virtual functions must be static."
        ],
        "correct": 1,
        "explanation": "Static functions belong to the class, not to any instance (they have no 'this' pointer). Virtual functions rely on instance-specific 'vptrs' to find their V-Table. Since there is no object instance involved in a static call, the 'virtual' concept does not apply.",
        "topic": "Virtual Functions"
    },
    {
        "question": "What is 'Late Binding' another name for?",
        "options": [
            "Static Binding",
            "Dynamic Binding",
            "Early Binding",
            "Recursive Binding"
        ],
        "correct": 1,
        "explanation": "Late Binding (or Dynamic Binding) refers to the delay of the function link until the program is actually running (late). This allows the code to be flexible enough to handle objects that were not even created when the program was compiled.",
        "topic": "Polymorphism"
    },
    {
        "question": "How do you declare a class 'Animal' as an abstract class?",
        "options": [
            "abstract class Animal { };",
            "class Animal { virtual void speak() = 0; };",
            "class Animal { static void speak(); };",
            "class Animal { void speak() { } };"
        ],
        "correct": 1,
        "explanation": "In C++, a class becomes abstract by including at least one pure virtual function (using the `= 0` notation). There is no 'abstract' keyword for classes as there is in languages like Java.",
        "topic": "Abstract Classes"
    },
    {
        "question": "In the context of the VU final lecture, what does the 'vptr' point to?",
        "options": [
            "The next object in memory.",
            "The start of the V-Table for that object's class.",
            "The 'main' function address.",
            "The heap manager."
        ],
        "correct": 1,
        "explanation": "The 'vptr' is a hidden pointer added by the compiler to every object of a class that has virtual functions. It points to the class's Virtual Table (V-Table), which contains the actual addresses of the virtual methods.",
        "topic": "Virtual Functions"
    },
    {
        "question": "Can an abstract class have 'Data Members' (variables)?",
        "options": [
            "No, it can only contain functions.",
            "Yes, it can have data members that are inherited by derived classes.",
            "Only if they are declared as virtual.",
            "Only if they are private."
        ],
        "correct": 1,
        "explanation": "An abstract class is still a class. It can have constructors, destructors, and data members. For example, an abstract `Shape` class might have a `color` data member that all concrete shapes (like `Circle` and `Square`) inherit.",
        "topic": "Abstract Classes"
    },
    {
        "question": "Which of the following is an example of 'Runtime Polymorphism'?",
        "options": [
            "Function Overloading",
            "Operator Overloading",
            "Virtual Functions",
            "Template Classes"
        ],
        "correct": 2,
        "explanation": "Function and Operator overloading are resolved at compile-time (Static Polymorphism). Virtual functions are the only mechanism in C++ that allows for runtime decision-making regarding which function implementation to execute.",
        "topic": "Polymorphism Types"
    },
    {
        "question": "What is the primary benefit of the 'Override' keyword (available in modern C++)?",
        "options": [
            "It makes the function run faster.",
            "It tells the compiler to check if a function actually overrides a base class virtual function, preventing typos.",
            "It allows a function to access private base data.",
            "It deletes the base class function."
        ],
        "correct": 1,
        "explanation": "The `override` keyword is a safety feature. It ensures that the function signature exactly matches a virtual function in the base class. If there is a mismatch (e.g., different parameters), the compiler will flag an error instead of treating it as a new, separate function.",
        "topic": "Modern C++"
    },
    {
        "question": "Can you have an 'Array of Pointers' to an abstract base class?",
        "options": [
            "No, because you cannot create objects of an abstract class.",
            "Yes, and each pointer can point to a concrete derived object.",
            "Only if the array is static.",
            "Only if the pointers are void pointers."
        ],
        "correct": 1,
        "explanation": "While you cannot create an *object* of an abstract class, you *can* create a *pointer* to one. An array of `Shape*` can store pointers to `Circle`, `Rectangle`, and `Triangle` objects, allowing you to iterate through the array and call `draw()` polymorphically on each.",
        "topic": "Polymorphism"
    },
    {
        "question": "What is the result of calling a virtual function inside a 'Constructor'?",
        "options": [
            "It correctly calls the derived class override.",
            "It calls the base class version because the derived object is not yet fully constructed.",
            "The program crashes immediately.",
            "The call is ignored."
        ],
        "correct": 1,
        "explanation": "During construction, the virtual mechanism is disabled. C++ ensures that the function called is the one belonging to the class currently being constructed. This prevents a base constructor from calling a derived function that might rely on derived data that hasn't been initialized yet.",
        "topic": "Virtual Functions"
    },
    {
        "question": "Which of the following describes a 'Concrete Class'?",
        "options": [
            "A class that contains only pure virtual functions.",
            "A class that has no virtual functions and can be instantiated.",
            "A class that provides implementations for all its inherited virtual functions.",
            "Both Options 1 and 2 are correct."
        ],
        "correct": 3,
        "explanation": "A concrete class is simply any class that is 'complete' enough to have objects created from it. This includes regular classes with no virtual functions and derived classes that have implemented all the abstract behaviors of their parents.",
        "topic": "OOP Terminology"
    },
    {
        "question": "In the hierarchy `Shape -> Polygon -> Triangle`, if `Shape` has a pure virtual function `area()`, which class must implement it to be concrete?",
        "options": [
            "Shape",
            "Polygon",
            "Triangle",
            "None of them"
        ],
        "correct": 2,
        "explanation": "Triangle is the 'leaf' class intended for instantiation. It must implement `area()` to be concrete. If `Polygon` implements it, `Triangle` can inherit that implementation; if neither does, neither can have objects.",
        "topic": "Abstract Classes"
    },
    {
        "question": "What is the size of an object of a class that contains virtual functions compared to one that doesn't?",
        "options": [
            "It is the same size.",
            "It is larger by the size of a pointer (to hold the vptr).",
            "It is smaller because functions are removed.",
            "It is exactly 100 bytes larger."
        ],
        "correct": 1,
        "explanation": "Every object of a class with virtual functions must store the hidden 'vptr'. This adds 4 bytes (on 32-bit systems) or 8 bytes (on 64-bit systems) to the memory footprint of every single instance of that class.",
        "topic": "Memory Management"
    },
    {
        "question": "If a base class function is NOT virtual, but a derived class provides a function with the same signature, this is called:",
        "options": [
            "Overloading",
            "Overriding",
            "Function Hiding (Shadowing)",
            "Abstraction"
        ],
        "correct": 2,
        "explanation": "True 'Overriding' requires the base function to be virtual. Without the `virtual` keyword, the derived class merely 'hides' or 'shadows' the base version. A base pointer pointing to a derived object would still call the base version, which is not polymorphic.",
        "topic": "Inheritance"
    },
    {
        "question": "Which of the following is NOT true about Abstract Base Classes?",
        "options": [
            "They can be used as parameter types in functions.",
            "They can be used as return types for functions.",
            "They can be used to create an instance with 'new'.",
            "They can have static member functions."
        ],
        "correct": 2,
        "explanation": "You cannot instantiate an ABC (using `new` or otherwise). However, you can use pointers or references to an ABC as parameters (e.g., `void paint(Shape &s)`) to allow any derived shape to be passed in.",
        "topic": "Abstract Classes"
    },
    {
        "question": "What is the primary technical reason for using 'Interfaces' (Abstract Classes with only pure virtual functions)?",
        "options": [
            "To save disk space.",
            "To define a strict 'contract' that all derived classes must follow.",
            "To prevent inheritance.",
            "To hide the main function."
        ],
        "correct": 1,
        "explanation": "An interface specifies 'what' must be done (e.g., a `Printable` class with a `print()` function) without saying 'how'. This forces every developer who inherits from it to implement the logic, ensuring a consistent interface across the whole software system.",
        "topic": "Software Design"
    },
    {
        "question": "In C++, 'Dynamic Casting' is primarily used to:",
        "options": [
            "Convert a base class pointer back to a derived class pointer safely at runtime.",
            "Convert an integer to a float.",
            "Delete a virtual function.",
            "Encrypt a pointer address."
        ],
        "correct": 0,
        "explanation": "Dynamic casting (`dynamic_cast<Derived*>(basePtr)`) uses the V-Table information to check if a base pointer is actually pointing to a specific derived type. If it is, the cast succeeds; if not, it returns `nullptr`, making it a safe way to 'down-cast' in a polymorphic hierarchy.",
        "topic": "Advanced OOP"
    },
    {
        "question": "The 'virtual' keyword should be placed in ________.",
        "options": [
            "The base class declaration only.",
            "The derived class declaration only.",
            "Both base and derived class declarations.",
            "The main function."
        ],
        "correct": 0,
        "explanation": "Technically, once a function is declared virtual in the base class, it remains virtual in all subsequent derived classes automatically. While repeating the `virtual` keyword in derived classes is allowed for clarity, it is not strictly required by the compiler.",
        "topic": "Virtual Functions"
    },
    {
        "question": "What happens if you try to call a pure virtual function of an object within the abstract base class's constructor?",
        "options": [
            "It executes successfully.",
            "It results in 'undefined behavior' or a runtime error (like 'pure virtual method call').",
            "It calls the derived class implementation.",
            "It is treated as a comment."
        ],
        "correct": 1,
        "explanation": "Since a pure virtual function has no implementation and the derived implementation is not yet 'active' during the base constructor, this results in a critical error. The program has no code to jump to.",
        "topic": "Abstract Classes"
    },
    {
        "question": "Which of the following summarizes 'Polymorphism' for a VU exam?",
        "options": [
            "Different classes inheriting from the same parent.",
            "Different objects responding to the same message in their own unique way.",
            "Using as many classes as possible in one file.",
            "A way to make the compiler ignore errors."
        ],
        "correct": 1,
        "explanation": "The essence of polymorphism is the 'common interface'. The same call (`draw()`) results in different behaviors (a circle vs. a square) depending on the object that receives the message.",
        "topic": "OOP Principles"
    },
    {
        "question": "Which of the following describes the technical process of 'Template Instantiation' in C++?",
        "options": [
            "The programmer manually writing code for every possible data type.",
            "The compiler generating a specific function or class definition when a template is used with a particular data type.",
            "The linker combining multiple template files into a single binary.",
            "The operating system allocating heap memory for template variables at runtime."
        ],
        "correct": 1,
        "explanation": "Templates are 'blueprints' for code. The compiler does not generate machine code for a template until it is actually used (instantiated) with a specific type (e.g., int or float). This allows C++ to maintain type safety and performance while providing the flexibility of generic programming.",
        "topic": "Templates"
    },
    {
        "question": "What is the primary characteristic of the 'Stack' data structure discussed in the final lectures?",
        "options": [
            "First-In, First-Out (FIFO)",
            "Last-In, First-Out (LIFO)",
            "Random access to any element via an index.",
            "Hierarchical storage using parent-child nodes."
        ],
        "correct": 1,
        "explanation": "A stack is a linear data structure that follows the LIFO principle. This means the last element added (pushed) to the stack is the first one to be removed (popped). This behavior is fundamental to how computer systems manage function calls and local variables.",
        "topic": "Data Structures"
    },
    {
        "question": "Which two operations are essential for a 'Stack' implementation?",
        "options": [
            "Insert and Delete",
            "Enqueue and Dequeue",
            "Push and Pop",
            "Add and Subtract"
        ],
        "correct": 2,
        "explanation": "'Push' is the operation of adding an element to the top of the stack, and 'Pop' is the operation of removing the top element. In a C++ class implementation, these are typically member functions that manage an underlying array or linked list.",
        "topic": "Stack Operations"
    },
    {
        "question": "In a stack implemented using an array, what happens during a 'Stack Overflow'?",
        "options": [
            "The stack is empty, and a pop operation is attempted.",
            "The array is full, and a push operation is attempted.",
            "The computer runs out of power during execution.",
            "The stack is converted into a queue automatically."
        ],
        "correct": 1,
        "explanation": "Stack Overflow occurs when the fixed-size container (like an array) used to store stack elements reaches its maximum capacity, but the program tries to add another element. This is a critical error that must be handled to prevent memory corruption or crashes.",
        "topic": "Stack Implementation"
    },
    {
        "question": "What is 'Stack Underflow'?",
        "options": [
            "Trying to push an element onto a full stack.",
            "Trying to pop an element from an empty stack.",
            "When the stack elements are all equal to zero.",
            "When the stack uses the heap segment instead of the stack segment."
        ],
        "correct": 1,
        "explanation": "Stack Underflow happens when the program attempts to remove (pop) or view (top) an element from a stack that contains no data. In a professional C++ class, a 'bool isEmpty()' function is usually used to check the state before performing these operations.",
        "topic": "Stack Implementation"
    },
    {
        "question": "Which of the following is a real-world application of the 'Stack' data structure in computing?",
        "options": [
            "Managing a printer's document queue.",
            "Implementing the 'Undo' feature in text editors.",
            "Sorting a database in alphabetical order.",
            "Sending emails to multiple recipients."
        ],
        "correct": 1,
        "explanation": "The LIFO nature of a stack makes it perfect for tracking history. In an 'Undo' operation, the most recent action (the last one pushed onto the stack) is the first one reversed (popped). Managing function calls in a CPU (the call stack) is another primary application.",
        "topic": "Data Structures"
    },
    {
        "question": "Why are 'Templates' considered more efficient than using 'void pointers' for generic programming in C++?",
        "options": [
            "Templates use less RAM at runtime.",
            "Templates allow for compile-time type checking, whereas void pointers bypass type safety.",
            "Void pointers can only point to integers.",
            "Templates are written in a faster dialect of C++."
        ],
        "correct": 1,
        "explanation": "Templates provide 'Type Safety'. Because the compiler instantiates a specific version of the code for each type, it can catch errors (like trying to add a string to an int) during compilation. Void pointers require dangerous type-casting at runtime, which often leads to bugs.",
        "topic": "Templates"
    },
    {
        "question": "In the context of the CS201 course conclusion, what is the 'Software Life Cycle'?",
        "options": [
            "The time it takes for a hard drive to fail.",
            "A series of phases including requirements, design, coding, testing, and maintenance.",
            "The process of upgrading a computer's RAM.",
            "The physical age of the programmer."
        ],
        "correct": 1,
        "explanation": "The Software Development Life Cycle (SDLC) represents the systematic approach to building software. It ensures that the final product is reliable, meets user needs, and is maintainable over time. Programming (coding) is only one phase of this cycle.",
        "topic": "Software Engineering"
    },
    {
        "question": "Which phase of the Software Life Cycle involves fixing bugs and making small improvements after the software is released?",
        "options": [
            "Design",
            "Coding",
            "Maintenance",
            "Analysis"
        ],
        "correct": 2,
        "explanation": "The Maintenance phase is the longest phase of the software life cycle. It involves correcting errors discovered by users, adapting the software to new hardware, and improving performance or usability based on feedback.",
        "topic": "Software Engineering"
    },
    {
        "question": "What is 'Generic Programming'?",
        "options": [
            "Writing code that only works on one specific operating system.",
            "Writing code that focuses on logic and algorithms independent of specific data types.",
            "Writing code without using any comments or documentation.",
            "Programming for low-end, 'generic' hardware."
        ],
        "correct": 1,
        "explanation": "Generic programming is the paradigm that allows algorithms (like sorting or searching) to be defined in their most abstract form. By using C++ templates, these algorithms can be applied to any data type that supports the required operations.",
        "topic": "Programming Paradigms"
    },
    {
        "question": "How is the 'Top' of the stack represented in a simple array-based implementation?",
        "options": [
            "By the value 0.",
            "By an integer variable (index) that increments on push and decrements on pop.",
            "By the total size of the array.",
            "By a pointer to the hard drive."
        ],
        "correct": 1,
        "explanation": "A 'top' variable or index tracks the position of the most recently added element. Initially, it might be -1 (empty). When an item is pushed, 'top' is incremented to 0, and the item is stored at array[0].",
        "topic": "Stack Implementation"
    },
    {
        "question": "Which of the following is true regarding 'Function Templates'?",
        "options": [
            "They must always be declared as static.",
            "The compiler can often deduce the template arguments from the function's parameters.",
            "They cannot be used with user-defined structures.",
            "They must return void."
        ],
        "correct": 1,
        "explanation": "Template argument deduction allows you to call a template function just like a regular one (e.g., `max(5, 10)`) without explicitly specifying `<int>`. The compiler sees the integers and automatically instantiates the correct version.",
        "topic": "Templates"
    },
    {
        "question": "In C++, 'Class Templates' are often used to create:",
        "options": [
            "Containers like Vectors, Stacks, and Lists.",
            "Low-level hardware drivers.",
            "Operating system kernels.",
            "Binary number systems."
        ],
        "correct": 0,
        "explanation": "Class templates are the backbone of the Standard Template Library (STL). They allow developers to create 'containers' that can hold any type of data, such as a stack of integers or a stack of strings, using the same underlying logic.",
        "topic": "Templates"
    },
    {
        "question": "What is the primary technical function of the 'Analysis' phase in software development?",
        "options": [
            "Writing the actual machine code.",
            "Understanding the user's requirements and defining the problem to be solved.",
            "Deleting the old version of the software.",
            "Purchasing new computers for the office."
        ],
        "correct": 1,
        "explanation": "Analysis is about 'what' the system should do. It involves gathering requirements from stakeholders and documenting them clearly before any design or coding begins. This prevents the costly mistake of building the 'wrong' software.",
        "topic": "Software Engineering"
    },
    {
        "question": "Which of the following is an advantage of 'Modular Programming'?",
        "options": [
            "It makes the program much larger and slower.",
            "It allows different programmers to work on different parts (modules) of the program simultaneously.",
            "It prevents the use of functions.",
            "It requires the programmer to use only global variables."
        ],
        "correct": 1,
        "explanation": "By breaking a large program into independent modules, development becomes more organized. This allows for parallel development, easier testing of individual parts, and better code reusability across different projects.",
        "topic": "Structured Programming"
    },
    {
        "question": "What does 'Debugging' refer to in the software development cycle?",
        "options": [
            "The process of gathering requirements.",
            "The process of finding and fixing errors in the code.",
            "The process of writing the help manual.",
            "The process of selling the software to customers."
        ],
        "correct": 1,
        "explanation": "Debugging is the systematic process of identifying the cause of a program's incorrect behavior and fixing it. It is distinct from 'Testing', which is the process of finding the existence of bugs.",
        "topic": "Software Engineering"
    },
    {
        "question": "In the statement `template <class T> void swap(T &a, T &b)`, what is the purpose of the references (&)?",
        "options": [
            "To tell the compiler that T is a pointer.",
            "To allow the function to modify the original variables passed as arguments.",
            "To speed up the computer's CPU.",
            "To encrypt the variables a and b."
        ],
        "correct": 1,
        "explanation": "Using references is essential for a 'swap' function. It ensures that the function works on the actual variables from the calling scope rather than local copies, allowing the values to be successfully exchanged in memory.",
        "topic": "Templates"
    },
    {
        "question": "Which of the following is a key attribute of 'Good Software' according to the handouts?",
        "options": [
            "It must be the most expensive software on the market.",
            "It must be user-friendly, efficient, and free of critical bugs.",
            "It must be written in assembly language.",
            "It must be compatible with only one brand of hardware."
        ],
        "correct": 1,
        "explanation": "Software quality is measured by several factors including usability (is it easy to use?), efficiency (does it use resources wisely?), and reliability (does it work correctly without crashing?).",
        "topic": "Software Quality"
    },
    {
        "question": "In a template class `Array<T>`, how do you declare an object for an array of characters?",
        "options": [
            "Array char myArr;",
            "Array<char> myArr;",
            "char Array myArr;",
            "template Array<char> myArr;"
        ],
        "correct": 1,
        "explanation": "When instantiating a class template, you must specify the desired data type inside angle brackets `< >`. This tells the compiler to use the 'char' version of the blueprint to create the object.",
        "topic": "Templates"
    },
    {
        "question": "What is the role of the 'Linker' in the final stage of software creation?",
        "options": [
            "To check for syntax errors in the source code.",
            "To combine object files and library files into a single executable (.exe) file.",
            "To translate user comments into English.",
            "To upload the program to the internet."
        ],
        "correct": 1,
        "explanation": "The linker resolves external references and combines the machine code from your compiled files with pre-compiled code from libraries (like iostream) to create the final file that the user can run.",
        "topic": "Program Development"
    },
    {
        "question": "Which of the following describes the 'Waterfall Model' of software development?",
        "options": [
            "A process where each phase must be completed before the next one begins.",
            "A process where coding is done first and requirements are analyzed last.",
            "A method for cooling down server rooms using water.",
            "A programming technique that uses only 'while' loops."
        ],
        "correct": 0,
        "explanation": "The Waterfall model is a linear and sequential approach. It assumes that requirements are stable and that the project moves through defined stages (Analysis -> Design -> Coding -> Testing) in a one-way flow.",
        "topic": "Software Engineering"
    },
    {
        "question": "What is the primary technical function of 'Code Optimization'?",
        "options": [
            "To make the code look more colorful in the editor.",
            "To improve the program's execution speed or reduce its memory usage.",
            "To hide the logic from other programmers.",
            "To add more features to the software."
        ],
        "correct": 1,
        "explanation": "Optimization is the process of modifying the code so it performs more efficiently. This can involve making algorithms faster or ensuring the program uses as little RAM as possible, which is critical for system performance.",
        "topic": "Software Engineering"
    },
    {
        "question": "Which C++ feature is used to implement 'Polymorphism', allowing a base class pointer to call derived class methods?",
        "options": [
            "Templates",
            "Virtual Functions",
            "Static Variables",
            "Friend Functions"
        ],
        "correct": 1,
        "explanation": "Virtual functions enable runtime polymorphism. They allow the program to decide which version of a function to call based on the actual object type at runtime, which is essential for building flexible class hierarchies.",
        "topic": "Object-Oriented Programming"
    },
    {
        "question": "The 'Design' phase of the software life cycle focuses on:",
        "options": [
            "Fixing bugs in the final product.",
            "Determining 'how' the system will be built, including data structures and architecture.",
            "Negotiating the price of the software with clients.",
            "Writing the machine code for the CPU."
        ],
        "correct": 1,
        "explanation": "While analysis focuses on 'what', design focuses on 'how'. During this phase, programmers decide which algorithms and data structures (like Stacks or Arrays) to use and how different modules will interact.",
        "topic": "Software Engineering"
    },
    {
        "question": "In C++, the `Standard Template Library (STL)` provides:",
        "options": [
            "A set of pre-written templates for common data structures and algorithms.",
            "A physical template for printing CDs.",
            "A way to write code without using a compiler.",
            "A list of all users on the Virtual University network."
        ],
        "correct": 0,
        "explanation": "The STL is a massive resource for C++ developers. It includes highly optimized templates for vectors, lists, stacks, and algorithms like sorting and searching, allowing programmers to focus on their unique logic rather than reinventing standard tools.",
        "topic": "Templates"
    },
    {
        "question": "What does 'Black-Box Testing' refer to?",
        "options": [
            "Testing the internal logic and code of a module.",
            "Testing the software's functionality based on inputs and outputs without knowing the internal code.",
            "Painting the computer case black before testing.",
            "Testing the software only after it has crashed."
        ],
        "correct": 1,
        "explanation": "In black-box testing, the tester treats the software as a 'black box'. They provide specific inputs and check if the output is correct according to the requirements, regardless of how the code is written inside.",
        "topic": "Software Engineering"
    },
    {
        "question": "Which data member in a C++ class should usually be 'private' according to encapsulation principles?",
        "options": [
            "Member functions that define the interface.",
            "The actual data variables (state) of the object.",
            "The name of the class.",
            "The 'include' directives."
        ],
        "correct": 1,
        "explanation": "Encapsulation dictates that an object's state (data) should be protected. By making variables private and providing public methods to access them, the class can ensure the data remains valid and secure.",
        "topic": "Object-Oriented Programming"
    },
    {
        "question": "What is 'White-Box Testing'?",
        "options": [
            "Testing the software based on internal logic and code structure.",
            "Testing the software using only white-colored computers.",
            "Testing the user manual for spelling errors.",
            "Testing the software after it has been deleted."
        ],
        "correct": 0,
        "explanation": "White-box testing (or clear-box testing) involves examining the internal structure of the code. The tester ensures that all logical paths, loops, and conditions are executed and working correctly.",
        "topic": "Software Engineering"
    },
    {
        "question": "In the concluding lecture of CS201, what is emphasized as the key to becoming a successful programmer?",
        "options": [
            "Memorizing every single keyword in C++.",
            "Constant practice, experimentation, and keeping up with new developments.",
            "Using the fastest computer available.",
            "Only writing code that other people have already written."
        ],
        "correct": 1,
        "explanation": "The instructor concludes that while fundamentals are essential, programming is a skill developed through constant practice. A sound fundamental knowledge allows a programmer to adapt to any new language or tool throughout their career.",
        "topic": "Career Advice"
    },
    {
        "question": "What is the final goal of the 'Introduction to Programming' course?",
        "options": [
            "To make students experts in every programming language.",
            "To provide a sound fundamental knowledge and the ability to solve problems using a computer.",
            "To teach students how to build hardware.",
            "To encourage students to stop using computers."
        ],
        "correct": 1,
        "explanation": "The course aims to build a strong foundation. With these fundamentals, students are equipped to tackle real-world problems and learn advanced concepts in computer science and software engineering.",
        "topic": "Course Objectives"
    },
    {
        "question": "Which of the following describes the technical role of 'Stream Manipulators' in C++ output?",
        "options": [
            "They are used to delete existing data from the output buffer.",
            "They are objects used to change the formatting of the data being sent to a stream.",
            "They are functions that encrypt the data for secure transmission.",
            "They are hardware components that increase the speed of the monitor."
        ],
        "correct": 1,
        "explanation": "Stream manipulators (like 'endl', 'setw', and 'hex') are used to change the appearance or behavior of a stream. For example, 'setw(10)' creates a field width of 10 characters for the next data item. These are essential for creating neat, tabular, and professional-looking reports in C++ applications.",
        "topic": "Stream Manipulation"
    },
    {
        "question": "What is the resulting output of the expression 'cout << hex << 255;'?",
        "options": [
            "255",
            "ff",
            "11111111",
            "0x255"
        ],
        "correct": 1,
        "explanation": "The 'hex' manipulator tells the output stream to display subsequent integer values in hexadecimal (base-16) format. The decimal value 255 is equivalent to 'ff' in hexadecimal. Note that once 'hex' is used, the stream stays in that mode until it is changed back using 'dec'.",
        "topic": "Stream Manipulation"
    },
    {
        "question": "In C++, which specific bitwise operator is used to perform a 'Bitwise AND' operation?",
        "options": [
            "&&",
            "&",
            "||",
            "|"
        ],
        "correct": 1,
        "explanation": "The single ampersand (&) is the bitwise AND operator. It compares each bit of two integers; the resulting bit is 1 only if both corresponding bits are 1. The double ampersand (&&) is the logical AND operator, which is used for Boolean true/false comparisons.",
        "topic": "Bitwise Operators"
    },
    {
        "question": "What is the primary function of the 'Bitwise OR' (|) operator?",
        "options": [
            "To find the common bits between two numbers.",
            "To set specific bits to 1 if at least one of the corresponding bits is 1.",
            "To flip all the bits of a single integer.",
            "To shift the bits to the left by one position."
        ],
        "correct": 1,
        "explanation": "The bitwise OR (|) compares bits and results in 1 if either bit (or both) is 1. This is frequently used in systems programming to 'turn on' specific flags or bits within a status register without affecting other bits.",
        "topic": "Bitwise Operators"
    },
    {
        "question": "Which bitwise operator is used to perform a 'Left Shift' and what is its mathematical effect on an integer?",
        "options": [
            ">>, divides the number by 2.",
            "<<, multiplies the number by 2 for each position shifted.",
            "~, negates the number.",
            "^, finds the remainder of the number."
        ],
        "correct": 1,
        "explanation": "The '<<' operator shifts the bits of a number to the left. Shifting a binary number one position to the left is equivalent to multiplying it by 2 (base-2). For example, 0010 (2) becomes 0100 (4). This is a high-speed alternative to standard multiplication in performance-critical code.",
        "topic": "Bitwise Operators"
    },
    {
        "question": "What does the 'Bitwise NOT' (~) operator do to an 8-bit integer like 00001111?",
        "options": [
            "It leaves the number unchanged.",
            "It changes it to 11110000 (flips all bits).",
            "It changes it to 00000000.",
            "It adds one to the binary value."
        ],
        "correct": 1,
        "explanation": "The '~' is a unary operator that performs a 'one's complement'. It reverses every bit in the operand: every 0 becomes 1 and every 1 becomes 0. This is often used in masking operations.",
        "topic": "Bitwise Operators"
    },
    {
        "question": "Which manipulator is used to ensure that a 'floating-point' number is always displayed with a decimal point and a specific number of trailing zeros?",
        "options": [
            "hex",
            "fixed",
            "scientific",
            "left"
        ],
        "correct": 1,
        "explanation": "When used with 'setprecision()', the 'fixed' manipulator forces the output to show a specific number of decimal places, even if they are zero. This is crucial for financial applications where values like $5.00 must be shown exactly, not as $5.",
        "topic": "Stream Manipulation"
    },
    {
        "question": "In the context of the CS201 handouts, what is 'Code Portability'?",
        "options": [
            "The ability to carry a computer from one room to another.",
            "The ease with which source code can be compiled and run on different hardware or operating systems.",
            "The process of converting a program into a mobile application.",
            "The speed at which a program can be uploaded to the cloud."
        ],
        "correct": 1,
        "explanation": "Portability is a hallmark of good software. Since C++ is a standardized language, code written following standard rules can be moved between Windows, Linux, and Mac with minimal changes. Using system-specific 'hacks' reduces portability and makes software harder to maintain.",
        "topic": "Software Quality"
    },
    {
        "question": "Which of the following describes the 'Bitwise XOR' (^) operator?",
        "options": [
            "The result is 1 if both bits are the same.",
            "The result is 1 only if the bits are different (one is 0, the other is 1).",
            "The result is always 0.",
            "It performs addition without carry."
        ],
        "correct": 1,
        "explanation": "Bitwise Exclusive OR (XOR) returns 1 only if the bits are different. This unique property makes it useful for simple encryption, toggling bits, and detecting changes between two sets of data.",
        "topic": "Bitwise Operators"
    },
    {
        "question": "What is 'Software Documentation' and why is it essential?",
        "options": [
            "A collection of images used in the software.",
            "The written text (comments and manuals) that explains how the code works and how to use it.",
            "The legal contract between the programmer and the client.",
            "The process of deleting old versions of the source code."
        ],
        "correct": 1,
        "explanation": "Documentation is vital for maintainability. High-quality code includes internal documentation (comments for other programmers) and external documentation (manuals for users). Without it, even the original author may struggle to understand the code months later.",
        "topic": "Software Engineering"
    },
    {
        "question": "Which header file is required to use manipulators like 'setw' and 'setfill'?",
        "options": [
            "iostream",
            "iomanip",
            "math.h",
            "stdlib.h"
        ],
        "correct": 1,
        "explanation": "While 'endl' and 'hex' are in <iostream>, parameterized manipulators like 'setw' (which take an argument) are defined in the <iomanip> header. Programmers must include this header to perform advanced text formatting.",
        "topic": "Pre-processor Directives"
    },
    {
        "question": "The 'setfill(char c)' manipulator is used to:",
        "options": [
            "Delete all characters from a file.",
            "Specify the character used to fill the empty spaces in a 'setw' field.",
            "Automatically capitalize all letters in a string.",
            "Fill the heap memory with zero values."
        ],
        "correct": 1,
        "explanation": "By default, 'setw' fills empty space with blanks. 'setfill('*')' would change that so that an output like '***42' is produced instead of '   42'. This is commonly used in printing checks or formatted tables.",
        "topic": "Stream Manipulation"
    },
    {
        "question": "What is the scholarly definition of 'Maintenance' in the software development life cycle?",
        "options": [
            "Writing the initial requirements for the project.",
            "The ongoing process of fixing bugs and updating software after its release.",
            "Physically cleaning the computer hardware.",
            "Compiling the code into an executable file."
        ],
        "correct": 1,
        "explanation": "Maintenance is often the most expensive and longest phase of software development. It ensures the software continues to work as the environment changes (e.g., new OS versions) and addresses issues found by real-world users.",
        "topic": "Software Engineering"
    },
    {
        "question": "Which operator is used to 'Right Shift' bits, and what is its effect on a positive integer?",
        "options": [
            "<<, it doubles the value.",
            ">>, it performs integer division by 2 for each position shifted.",
            "&, it extracts the last bit.",
            "|, it sets the first bit."
        ],
        "correct": 1,
        "explanation": "The '>>' operator moves bits to the right. For positive integers, shifting right by one is equivalent to dividing by 2 and discarding any remainder. For example, 1010 (10) shifted right becomes 0101 (5).",
        "topic": "Bitwise Operators"
    },
    {
        "question": "In C++, the 'dec' manipulator is used to:",
        "options": [
            "Decrement a variable by one.",
            "Reset the stream to display numbers in decimal (base-10) format.",
            "Delete the current line of output.",
            "Declare a new pointer."
        ],
        "correct": 1,
        "explanation": "'dec' stands for decimal. If a stream was previously set to 'hex' or 'oct', 'dec' is used to return it to the standard base-10 format that humans are most familiar with.",
        "topic": "Stream Manipulation"
    },
    {
        "question": "What is a 'Bit Mask'?",
        "options": [
            "A type of security software that hides your IP address.",
            "A binary pattern used with bitwise operators to isolate or modify specific bits within a variable.",
            "A physical cover for the computer's monitor.",
            "A syntax error caused by too many 1s and 0s."
        ],
        "correct": 1,
        "explanation": "Masking is a powerful low-level technique. For example, to find the value of the 3rd bit of a number, you 'AND' it with a mask like 00000100. If the result is non-zero, the bit was 1. This is essential for controlling hardware pins or compact data storage.",
        "topic": "Bitwise Operations"
    },
    {
        "question": "Which of the following is true regarding 'Internal Documentation'?",
        "options": [
            "It is written only for the end-user of the software.",
            "It consists of comments within the source code to explain complex logic to developers.",
            "It is illegal in professional C++ programming.",
            "It automatically generates a website for the software."
        ],
        "correct": 1,
        "explanation": "Internal documentation (comments) is written for the 'maintenance programmer'. Good comments don't explain *what* the code is doing (the code shows that), but *why* it is doing it, helping future developers avoid breaking the logic.",
        "topic": "Coding Standards"
    },
    {
        "question": "What happens if you use 'setprecision(2)' without the 'fixed' manipulator on the number 123.456?",
        "options": [
            "It displays 123.45.",
            "It displays 1.2e+02 (scientific notation with 2 significant digits).",
            "It displays 12.",
            "It crashes the stream."
        ],
        "correct": 1,
        "explanation": "By default, 'setprecision' controls the total number of *significant digits*, not just the decimal places. Without 'fixed', 123.456 might be rounded to 1.2e+02 to fit the precision limit. Using 'fixed' changes the meaning of 'setprecision' to 'digits after the decimal point'.",
        "topic": "Stream Manipulation"
    },
    {
        "question": "The 'oct' manipulator is used to display numbers in which base?",
        "options": [
            "Base-2 (Binary)",
            "Base-8 (Octal)",
            "Base-10 (Decimal)",
            "Base-16 (Hexadecimal)"
        ],
        "correct": 1,
        "explanation": "'oct' stands for octal. It represents numbers using digits 0-7. While less common today than hex or decimal, octal is still used in some computing areas like Unix file permissions.",
        "topic": "Number Systems"
    },
    {
        "question": "In bitwise operations, what is 'Toggling' a bit?",
        "options": [
            "Setting a bit to 0 regardless of its current state.",
            "Changing a 0 to 1, or a 1 to 0 (reversing its state).",
            "Deleting a bit from memory.",
            "Copying a bit to another variable."
        ],
        "correct": 1,
        "explanation": "Toggling is achieved using the XOR (^) operator with a mask of 1. If you XOR a bit with 1, it will flip. If you XOR it with 0, it stays the same. This is useful for 'on/off' switches in software.",
        "topic": "Bitwise Operations"
    },
    {
        "question": "What is the primary technical reason for using 'Bitwise Shift' operators for multiplication or division by powers of 2?",
        "options": [
            "They are easier for humans to read.",
            "They are executed much faster by the CPU than standard multiplication/division instructions.",
            "They are the only way to handle negative numbers.",
            "They prevent the computer from overheating."
        ],
        "correct": 1,
        "explanation": "Multiplication and division are complex operations for a CPU. Shifting bits is a very 'cheap' and fast operation. In high-performance graphics or real-time systems, programmers use shifts to squeeze the maximum speed out of the hardware.",
        "topic": "Bitwise Operators"
    },
    {
        "question": "Which manipulator is used to align output to the 'left' of a field created by 'setw'?",
        "options": [
            "left",
            "right",
            "internal",
            "flush"
        ],
        "correct": 0,
        "explanation": "By default, 'setw' is right-aligned. The 'left' manipulator changes the alignment so the data appears at the beginning of the field and the padding (fill characters) appears at the end.",
        "topic": "Stream Manipulation"
    },
    {
        "question": "According to the CS201 handouts, what makes software 'Robust'?",
        "options": [
            "The software is very large in size.",
            "The software can handle unexpected inputs or errors without crashing.",
            "The software is written in many different languages.",
            "The software requires a very powerful computer."
        ],
        "correct": 1,
        "explanation": "Robustness refers to the stability of the program. A robust program validates user input and handles potential file errors gracefully, ensuring that it doesn't simply 'quit' when something unusual happens.",
        "topic": "Software Quality"
    },
    {
        "question": "What is the result of '10 & 7' in binary?",
        "options": [
            "2",
            "10",
            "7",
            "17"
        ],
        "correct": 0,
        "explanation": "In binary, 10 is 1010 and 7 is 0111. Performing a bitwise AND: \n1010\n0111\n----\n0010 (which is 2 in decimal).",
        "topic": "Bitwise Operators"
    },
    {
        "question": "The 'flush' manipulator is used to:",
        "options": [
            "Delete the contents of the hard drive.",
            "Force the output buffer to be written to the destination (screen or file) immediately.",
            "Change the color of the text on the screen.",
            "Restart the program."
        ],
        "correct": 1,
        "explanation": "To improve speed, C++ often waits until a buffer is full before sending it to the screen. 'flush' forces the stream to send the data immediately. This is often used in debugging to see exactly where a program is before a crash occurs.",
        "topic": "Stream Manipulation"
    },
    {
        "question": "Which of the following is NOT a bitwise operator in C++?",
        "options": [
            "&",
            "|",
            "%",
            "^"
        ],
        "correct": 2,
        "explanation": "The '%' operator is the 'modulo' operator (remainder of division). The bitwise operators are AND (&), OR (|), XOR (^), NOT (~), and shifts (<<, >>).",
        "topic": "Bitwise Operators"
    },
    {
        "question": "What is the result of '5 | 3' in binary?",
        "options": [
            "1",
            "7",
            "8",
            "15"
        ],
        "correct": 1,
        "explanation": "In binary, 5 is 101 and 3 is 011. Performing a bitwise OR:\n101\n011\n---\n111 (which is 7 in decimal).",
        "topic": "Bitwise Operators"
    },
    {
        "question": "In the statement 'cout << showpoint << 5.0;', what does 'showpoint' do?",
        "options": [
            "It displays the memory address of the number.",
            "It forces the display of a decimal point and trailing zeros even for whole numbers.",
            "It draws a point on the physical screen.",
            "It converts the number to an integer."
        ],
        "correct": 1,
        "explanation": "By default, C++ might show 5.0 as just '5'. 'showpoint' ensures the decimal point is visible, which is helpful for maintaining consistent formatting in scientific or mathematical output.",
        "topic": "Stream Manipulation"
    },
    {
        "question": "Why is 'Reliability' a key concern for programmers?",
        "options": [
            "Because reliable software is more colorful.",
            "Because users expect the software to perform its intended functions correctly over time.",
            "Because reliable software doesn't need a CPU.",
            "Because reliability makes the computer weigh less."
        ],
        "correct": 1,
        "explanation": "Reliability means the software produces consistent and correct results. In fields like medicine, aviation, or banking, reliability is the most important attribute of the entire system.",
        "topic": "Software Quality"
    },
    {
        "question": "What is the binary result of shifting 1 (0001) to the left by 3 positions?",
        "options": [
            "0011",
            "1000",
            "0111",
            "1111"
        ],
        "correct": 1,
        "explanation": "Shifting 1 left by 3 positions: \n0001 -> 0010 (shift 1)\n0010 -> 0100 (shift 2)\n0100 -> 1000 (shift 3). \nThis result is 8 in decimal (2 to the power of 3).",
        "topic": "Bitwise Operators"
    },
    {
        "question": "Which component of the Standard Template Library (STL) is responsible for managing the physical storage and organization of data in memory?",
        "options": [
            "Algorithms",
            "Iterators",
            "Containers",
            "Function Objects"
        ],
        "correct": 2,
        "explanation": "STL Containers (like vector, list, and deque) are template classes that handle the storage of data. They manage the memory allocation and deallocation for the elements they store. Algorithms (Option 0) perform operations on the data, while Iterators (Option 1) act as the bridge between containers and algorithms.",
        "topic": "Standard Template Library (STL)"
    },
    {
        "question": "What is the primary technical function of an 'Iterator' in the STL?",
        "options": [
            "To perform mathematical calculations on integers.",
            "To act as a generic pointer that allows an algorithm to traverse the elements of a container.",
            "To delete objects from the heap automatically.",
            "To convert a class into a binary file."
        ],
        "correct": 1,
        "explanation": "Iterators provide a uniform way to access elements in different types of containers. Because algorithms use iterators rather than specific container details, a single 'sort' algorithm can work on a vector, a list, or an array. This is a key implementation of the 'Generic Programming' paradigm.",
        "topic": "STL Iterators"
    },
    {
        "question": "In the context of the STL, what is a 'Sequence Container'?",
        "options": [
            "A container that stores data in a sorted tree structure.",
            "A container that maintains the linear order of elements as they are inserted.",
            "A container that only stores even numbers.",
            "A container that automatically encrypts its contents."
        ],
        "correct": 1,
        "explanation": "Sequence containers (such as 'vector' and 'list') store elements in a linear fashion. The position of an element depends on when and where it was added, not on its value. Associative containers (like 'set' and 'map') use sorted structures for faster searching based on keys.",
        "topic": "STL Containers"
    },
    {
        "question": "Which of the following is an example of an 'Associative Container' in the STL?",
        "options": [
            "vector",
            "list",
            "map",
            "deque"
        ],
        "correct": 2,
        "explanation": "A 'map' is an associative container that stores data in key-value pairs. It uses a balanced binary tree (usually a Red-Black tree) to keep keys sorted, allowing for very fast retrieval. Vector, list, and deque are all sequence containers.",
        "topic": "STL Containers"
    },
    {
        "question": "What are 'Command-Line Arguments' in C++?",
        "options": [
            "Comments written at the beginning of a program.",
            "Parameters passed to the main() function from the operating system when the program is executed.",
            "Error messages displayed by the compiler.",
            "Instructions for the linker to include specific libraries."
        ],
        "correct": 1,
        "explanation": "Command-line arguments allow users to pass information to a program at startup (e.g., `myprog.exe data.txt`). This data is received by the `main(int argc, char *argv[])` function. `argc` counts the arguments, and `argv` is an array of strings containing the actual data.",
        "topic": "Command-Line Arguments"
    },
    {
        "question": "In the standard main function signature `int main(int argc, char *argv[])`, what does `argc` represent?",
        "options": [
            "The memory address of the first variable.",
            "The Argument Count (the number of items passed on the command line).",
            "The Argument Character (the first letter of the program name).",
            "The total size of the executable file in bytes."
        ],
        "correct": 1,
        "explanation": "The `argc` (Argument Count) integer always includes at least one value: the name of the program itself. If a user types `myprog hello world`, `argc` will be 3.",
        "topic": "Command-Line Arguments"
    },
    {
        "question": "Which of the following is true regarding `argv[0]` in a C++ program?",
        "options": [
            "It contains the first word of the user's input.",
            "It contains the full path or name of the executing program.",
            "It is always a NULL pointer.",
            "It contains the number of arguments as a character."
        ],
        "correct": 1,
        "explanation": "By convention, the operating system always passes the name of the executable as the first argument (`argv[0]`). This allows the program to know its own name or its location on the disk.",
        "topic": "Command-Line Arguments"
    },
    {
        "question": "What is a 'Function Object' (or Functor) in C++?",
        "options": [
            "A function that returns an object.",
            "A class that overloads the function call operator `operator()` so its objects can be used like functions.",
            "A static function that belongs to a friend class.",
            "A pointer to the main() function."
        ],
        "correct": 1,
        "explanation": "Function objects are objects that behave like functions. Because they are objects of a class, they can maintain state (internal data) across multiple calls, making them more powerful than simple function pointers for complex STL algorithms.",
        "topic": "Function Objects"
    },
    {
        "question": "The 'Vector' container is preferred over a standard 'Array' because:",
        "options": [
            "It is faster to access elements by index.",
            "It can grow or shrink in size dynamically as needed.",
            "It uses less memory than a static array.",
            "It does not require a data type during declaration."
        ],
        "correct": 1,
        "explanation": "Standard arrays have a fixed size determined at compile-time. A `std::vector` manages its own memory on the heap; if you add an element when it is full, it automatically reallocates a larger block of memory. This flexibility is essential for modern software.",
        "topic": "STL Containers"
    },
    {
        "question": "Which STL algorithm would you use to find a specific value within a range defined by two iterators?",
        "options": [
            "std::search()",
            "std::find()",
            "std::locate()",
            "std::query()"
        ],
        "correct": 1,
        "explanation": "The `std::find()` algorithm takes a starting iterator, an ending iterator, and a value. It returns an iterator to the first occurrence of the value, or the end iterator if the value is not found.",
        "topic": "STL Algorithms"
    },
    {
        "question": "What is the complexity of accessing an element in a `std::vector` by its index?",
        "options": [
            "O(1) - Constant Time",
            "O(n) - Linear Time",
            "O(log n) - Logarithmic Time",
            "O(n^2) - Quadratic Time"
        ],
        "correct": 0,
        "explanation": "Like a primitive array, a vector stores elements in contiguous memory. This allows the computer to calculate the address of any element immediately using simple math (Base Address + Index * Size), resulting in constant time access.",
        "topic": "Algorithm Complexity"
    },
    {
        "question": "Which container is most efficient for frequently inserting and deleting elements at the 'front' or 'middle' of a sequence?",
        "options": [
            "std::vector",
            "std::list",
            "std::stack",
            "std::array"
        ],
        "correct": 1,
        "explanation": "A `std::list` is a doubly-linked list. To insert or delete, it only needs to change a few pointers. A vector (Option 0) must shift all subsequent elements to make room or fill the gap, which is very slow for large sequences.",
        "topic": "STL Containers"
    },
    {
        "question": "In the STL, 'Algorithms' are separated from 'Containers' to achieve ________.",
        "options": [
            "Higher security.",
            "Maximum reusability through abstraction.",
            "Smaller executable files.",
            "Easier translation into other languages."
        ],
        "correct": 1,
        "explanation": "By making algorithms work with iterators rather than specific container types, the STL achieves great reusability. A single 'sort' algorithm can sort any container that provides random-access iterators, meaning the STL doesn't need a separate sort function for every container.",
        "topic": "STL Architecture"
    },
    {
        "question": "What does the `push_back()` member function do in a vector?",
        "options": [
            "It deletes the last element.",
            "It adds a new element to the end of the vector.",
            "It moves the first element to the back.",
            "It reverses the order of the vector."
        ],
        "correct": 1,
        "explanation": "`push_back` is the standard way to grow a vector. It appends the value to the end and increments the vector's size.",
        "topic": "STL Containers"
    },
    {
        "question": "Which iterator type is required by the `std::sort()` algorithm?",
        "options": [
            "Forward Iterator",
            "Input Iterator",
            "Random Access Iterator",
            "Bidirectional Iterator"
        ],
        "correct": 2,
        "explanation": "Efficient sorting algorithms (like Quicksort used in `std::sort`) require the ability to jump to any position in the sequence instantly. Therefore, it only works on containers like `vector` and `deque` that provide random access iterators.",
        "topic": "STL Iterators"
    },
    {
        "question": "What is the primary difference between a `std::stack` and a `std::vector`?",
        "options": [
            "A stack is much faster.",
            "A stack restricts access to only the top element (LIFO), whereas a vector allows access to any element.",
            "A stack can only store characters.",
            "A vector is an associative container; a stack is not."
        ],
        "correct": 1,
        "explanation": "A `std::stack` is a 'container adapter'. It uses an underlying container (like a deque or vector) but restricts the interface to follow the Last-In-First-Out (LIFO) principle, providing only `push`, `pop`, and `top` operations.",
        "topic": "Container Adapters"
    },
    {
        "question": "In C++, `char *argv[]` is essentially a/an ________.",
        "options": [
            "Array of integers.",
            "Array of strings (character pointers).",
            "Single character variable.",
            "Pointer to a function."
        ],
        "correct": 1,
        "explanation": "Since a string in C-style is a `char*`, an array of these pointers represents a collection of strings—the arguments passed from the command line.",
        "topic": "Command-Line Arguments"
    },
    {
        "question": "Which function is used to convert a command-line argument string (like \"123\") into an actual integer for calculation?",
        "options": [
            "atoi()",
            "itoa()",
            "convert()",
            "toInt()"
        ],
        "correct": 0,
        "explanation": "`atoi` stands for 'ASCII to Integer'. Since command-line arguments are always received as text, `atoi` is needed to transform that text into a numerical format that can be used in arithmetic.",
        "topic": "Data Conversion"
    },
    {
        "question": "What is 'Template Metaprogramming' in the context of the STL?",
        "options": [
            "A way to write programs that only run on servers.",
            "Using templates to perform calculations or logic at compile-time instead of runtime.",
            "Writing templates that can only be used by friend classes.",
            "Automatically deleting objects from the heap."
        ],
        "correct": 1,
        "explanation": "Because templates are handled by the compiler, complex logic can be performed during the build process. This shifts the computational load from the user's computer (runtime) to the developer's computer (compile-time), resulting in faster executables.",
        "topic": "Advanced Templates"
    },
    {
        "question": "Which of the following describes a 'Predicate' in STL algorithms?",
        "options": [
            "A function or function object that returns a Boolean value.",
            "A variable that stores the size of a container.",
            "A pointer to the end of a file.",
            "An algorithm that only works on integers."
        ],
        "correct": 0,
        "explanation": "Predicates are used by algorithms to make decisions. For example, `std::find_if` uses a predicate to determine if a specific element meets a condition (like 'is this number even?').",
        "topic": "STL Algorithms"
    },
    {
        "question": "What is the purpose of `std::deque` (Double-Ended Queue)?",
        "options": [
            "To store data in a circular buffer.",
            "To allow efficient insertion and deletion at both the beginning and the end of the sequence.",
            "To prevent duplicate elements from being stored.",
            "To sort data automatically as it is entered."
        ],
        "correct": 1,
        "explanation": "A deque is similar to a vector but is optimized for operations at both ends. While a vector is slow when inserting at the front, a deque handles it efficiently.",
        "topic": "STL Containers"
    },
    {
        "question": "Which operator is typically overloaded to create a Function Object?",
        "options": [
            "operator+",
            "operator[]",
            "operator()",
            "operator->"
        ],
        "correct": 2,
        "explanation": "The function call operator `()` allows an object to be used with the same syntax as a function call: `myObj(args)`. This is the defining feature of a functor.",
        "topic": "Function Objects"
    },
    {
        "question": "In the STL, 'Generic Algorithms' are defined as ________.",
        "options": [
            "Global functions that work on any container through iterators.",
            "Member functions of the base class.",
            "Functions that can only be used with integers.",
            "Static variables that count object instances."
        ],
        "correct": 0,
        "explanation": "Because they are not members of any specific container, these algorithms are highly flexible and 'generic'.",
        "topic": "STL Algorithms"
    },
    {
        "question": "What does the `begin()` member function of a container return?",
        "options": [
            "The value of the first element.",
            "An iterator pointing to the first element.",
            "The memory address of the container.",
            "An integer representing index 0."
        ],
        "correct": 1,
        "explanation": "Iterators are the language of the STL. `begin()` gives the starting point for traversal, and `end()` gives the stopping point.",
        "topic": "STL Iterators"
    },
    {
        "question": "What is 'Code Reusability' in the context of the STL?",
        "options": [
            "Copying and pasting code from one file to another.",
            "Using pre-written, highly optimized template classes and algorithms for various data types.",
            "Running the same program multiple times.",
            "Using the same pointer address twice."
        ],
        "correct": 1,
        "explanation": "The STL is the ultimate example of reusability. Instead of every programmer writing their own sort or list, they use the standardized, efficient versions provided by the library.",
        "topic": "STL Benefits"
    },
    {
        "question": "If a user runs a program as `myprog.exe input.txt output.txt`, what is the value of `argc`?",
        "options": [
            "2",
            "3",
            "1",
            "0"
        ],
        "correct": 1,
        "explanation": "1 (myprog.exe) + 1 (input.txt) + 1 (output.txt) = 3 total arguments.",
        "topic": "Command-Line Arguments"
    },
    {
        "question": "Which of the following is NOT an advantage of using STL containers over C-style arrays?",
        "options": [
            "Automatic memory management.",
            "Built-in bounds checking (when using .at()).",
            "Faster execution in all possible scenarios.",
            "Support for complex algorithms."
        ],
        "correct": 2,
        "explanation": "While STL containers are very efficient, a raw C-style array has absolutely zero overhead, making it slightly faster in extremely specific low-level tasks. However, the benefits of safety and flexibility usually outweigh this tiny performance difference.",
        "topic": "STL vs Arrays"
    },
    {
        "question": "A 'set' container in the STL is unique because:",
        "options": [
            "It can only store 10 elements.",
            "It automatically sorts elements and ensures all elements are unique.",
            "It uses more RAM than a vector.",
            "It is only available in 64-bit C++."
        ],
        "correct": 1,
        "explanation": "A set is an associative container. It keeps its elements in order and will not allow a duplicate value to be inserted. If you try to insert '5' twice, the second attempt will be ignored.",
        "topic": "STL Containers"
    },
    {
        "question": "In the statement `vector<int>::iterator it;`, what is `it`?",
        "options": [
            "An integer variable.",
            "A specific iterator type that can navigate a vector of integers.",
            "A pointer to a character.",
            "A member function of the vector class."
        ],
        "correct": 1,
        "explanation": "Since iterators are specific to the container type they traverse, you must specify the container type when declaring the iterator.",
        "topic": "STL Iterators"
    },
    {
        "question": "What is the final message regarding 'Fundamentals' in the CS201 course handouts?",
        "options": [
            "Programming is only about learning syntax.",
            "Strong fundamentals allow a programmer to learn and adapt to any new language or technology.",
            "Fundamentals are only for beginners.",
            "Students should only focus on the C++ language."
        ],
        "correct": 1,
        "explanation": "The course concludes by emphasizing that while languages change, the core principles of programming—logic, data structures, and problem-solving—remain constant.",
        "topic": "Course Conclusion"
    }
]